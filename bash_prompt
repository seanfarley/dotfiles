# @gf3’s Sexy Bash Prompt, inspired by "Extravagant Zsh Prompt"
# Shamelessly copied from https://github.com/gf3/dotfiles

# Powerline fonts from: https://github.com/Lokaltog/powerline-fonts
# On Mavericks, the powerline font was about 1px off, so followed:
# https://gist.github.com/qrush/1595572
# on the powerline-fontpatcher repo and settled on just using the y offset

# Helper functions are borrowed from liquidprompt:
# https://github.com/nojhan/liquidprompt

# exit if we terminal can't do colors
if [[ ! -t 0 ]] || [[ "$TERM" == "dumb" ]]; then
  return
fi

##
# colored highlighting is awesome
##

if [[ "$TERM" != "dumb" ]] && [[ -x "$(which dircolors 2>/dev/null)" ]]; then
  eval "$(dircolors -b ~/.dir_colors)"
fi

RESET="\[$(tput sgr0)\]"
BOLD=$(tput bold)

# NOTE how to find these codes? use the print_all_colors function to get a table
# of colors with their codes; this works with any theme so there doesn't need to
# be any guessing

USER_COLOR=001
HOST_COLOR=172
SHLVL_COLOR=214
JOBS_COLOR=105
CWD_COLOR=004
VE_COLOR=003
PROMPT_COLOR=243

# VCS COLORS
BRANCH_COLOR=243
MOD_COLOR=001
UNTRACKED_COLOR=003
STAGED_COLOR=002
CONFLICT_COLOR=003
MERGE_COLOR=110
STASH_COLOR=139
REMOTE_COLOR=248

PROMPT_SHOW_OS_VERSION=1

function print_color() {
  for c; do
    printf '\e[48;5;%dm%03d' "$c" "$c"
  done
  printf '\e[0m \n'
}

function print_all_colors() {
  IFS=$' \t\n'
  print_color {0..15}
  for ((i=0;i<6;i++)); do
    print_color $(seq $((i*36+16)) $((i*36+51)))
  done
  print_color {232..255}
}

function colorize () {
  # optional arg 2 could be bold or reset or both or whatevs
  printf '%s' "\[$2\]\[$(tput setaf "$1")\]"
}

function bp_segment () {
  printf '%s' "$(colorize "$2" "$BOLD")$1$RESET"
}

function bp_user () {
  printf '%s' " $USER"
}

function bp_os_type () {
  local os_icon=""
  local pver=""
  local NAME=""
  local VERSION_ID=""

  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    os_icon=""
    if [ -f /etc/os-release ]; then
      # disabling since the warning is a false positive
      # shellcheck disable=SC1091
      source /etc/os-release
      OS="$NAME"
      VER="$VERSION_ID"
    else
      # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
      OS=$(uname -s)
      VER=$(uname -r)
    fi

    if [[ "$OS" == *"Ubuntu"* ]]; then
      os_icon=""
    elif [[ "$OS" == *"Debian"* ]]; then
     os_icon=""
    elif [[ "$OS" == "SLES" ]]; then
      os_icon=""
    elif [[ "$OS" == *"CentOS"* ]]; then
      os_icon=""
    elif [[ "$OS" == *"BSD"* ]]; then
      os_icon=""
    fi

  elif [[ "$OSTYPE" == "darwin"* ]]; then
    os_icon=""
    VER=$(echo "$OSTYPE" | cut -d n -f 2 | cut -d . -f 1)
    if [[ $VER == 21 ]]; then
      VER="Monterey"
    elif [[ $VER == 20 ]]; then
      VER="Big Sur"
    elif [[ $VER == 19 ]]; then
      VER="Catalina"
    elif [[ $VER == 18 ]]; then
      VER="Mojave"
    fi
  elif [[ "$OSTYPE" == "freebsd"* ]]; then
    os_icon=""
  fi

  # remove spaces
  VER=${VER//[[:blank:]]/}
  # the double comma lowercases everything
  [[ $PROMPT_SHOW_OS_VERSION != 0 ]] && pver=" (${VER,,})"

  printf ' %s' "$os_icon $(hostname)$pver"
}

function pretty_dir () {
  # decent default values
  local max_len=27
  local mask=" … "
  local keep=2
  local ret=""
  local p=${PWD/#$HOME/"~"}

  if (( ${#p} <= max_len )); then
    ret="$p"
  else
    local tmp=${p//\//}
    local -i delims=$(( ${#p} - ${#tmp} ))

    for (( dir=0; dir < keep; dir++ )); do
      (( "${dir}" == "${delims}" )) && break

      local left="${p#*/}"
      local name="${p:0:${#p} - ${#left}}"
      p="${left}"
      ret="${ret}${name%/}/"
    done

    if (( delims <= keep )); then
      # no dirs between LP_PATH_KEEP leading dirs and current dir
      ret="${ret}${p##*/}"
    else
      local base="${p##*/}"

      p="${p:0:${#p} - ${#base}}"

      [[ ${ret} != "/" ]] && ret="${ret%/}" # strip trailing slash

      local -i len_left=$(( max_len - ${#ret} - ${#base} - ${#mask} ))

      ret="${ret}${mask}${p:${#p} - ${len_left}}${base}"
    fi
  fi

  printf ' %s' "${ret//\\/\\\\}"
}

# Search upwards through a directory structure looking for a file/folder with
# the given name.  Used to avoid invoking 'git', hg', 'bzr', etc.
_bp_upwards_find()
{
    local dir
    dir="$PWD"
    while [[ -n "$dir" ]]; do
        [[ -d "$dir/$1" || -f "$dir/$1" ]] && printf '%s' "$dir" && return 0
        dir="${dir%/*}"
    done
    return 1
}

function _lp_git_branch() {
  local gitdir
  gitdir="$([[ $(\git ls-files . 2>/dev/null | wc -l) -gt 0 ]] && \git rev-parse --git-dir 2>/dev/null)"
  [[ $? -ne 0 || ! $gitdir =~ (.*\/)?\.git.* ]] && return
  local branch
  # Recent versions of Git support the --short option for symbolic-ref, but
  # not 1.7.9 (Ubuntu 12.04)
  if branch="$(\git symbolic-ref -q HEAD)"; then
    printf '%s' "${branch#refs/heads/}"
  else
    # In detached head state, use commit instead
    # No escape needed
    \git rev-parse --short -q HEAD
  fi
}

function bp_git() {
  # https://joshdick.net/2017/06/08/my_git_prompt_for_zsh_revisited.html
  # for performance reasons and, ironically enough, spacing/coloring reasons,
  # put all the git operations in a single function; therefore we put the colors
  # into this function
  local prompt
  local repo_dir
  local git_st
  local remote
  local status
  local merge_info

  repo_dir=$(_bp_upwards_find .git)

  [[ -z "$repo_dir" ]] && return

  # space is padded here since this is a specialized function
  prompt="$(bp_segment " " $BRANCH_COLOR)"

  git_st="$(git status 2> /dev/null)"

  [[ "$git_st" == *"Changes not staged for commit:"* ]] && status="$(bp_segment ● $MOD_COLOR)"
  [[ "$git_st" == *"Untracked files:"* ]] && status="$status$(bp_segment ● $UNTRACKED_COLOR)"
  [[ "$git_st" == *"Changes to be committed:"* ]] && status="$status$(bp_segment ● $STAGED_COLOR)"
  [[ -n "$status" ]] && prompt="$prompt $status"

  [[ "$git_st" == *"You have unmerged paths."* ]] && merge_info="$(bp_segment ⚡ $CONFLICT_COLOR)"
  [[ -f "$repo_dir/.git/MERGE_HEAD" ]] && merge_info="$merge_info$(bp_segment  $MERGE_COLOR)"
  [[ -n "$merge_info" ]] && prompt="$prompt $merge_info"

  [[ -n "$(\git stash list 2>/dev/null)" ]] && prompt="$prompt $(bp_segment  $STASH_COLOR)"

  prompt="$prompt $(bp_segment "$(_lp_git_branch)" $BRANCH_COLOR)"

  if [[ "$git_st" == *"Your branch is"* ]]; then
    remote="$(echo "$git_st" | perl -lne 'print " $2$1" if /Your branch is (ahead|behind).*?(\d+) comm/' | perl -pe 's,behind,⇣,' | perl -pe 's,ahead,⇡,')"
  else
    remote="$(echo "$git_st" | perl -lne 'print " $1⇡$2⇣" if /and have (\d+) and (\d+) diff/')"
  fi

  prompt="$prompt$(bp_segment "$remote" $REMOTE_COLOR)"

  printf '%s' "$prompt"
}

################
# Related jobs #
################

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
function bp_jobs () {
    local running=$(( $(jobs -r | wc -l) ))
    local stopped=$(( $(jobs -s | wc -l) ))
    local m_stop="z"
    local m_run="&"
    local ret=""

    if [[ $running != "0" ]] ; then
        ret="${ret}${running}${m_run}"
    fi

    if [[ $stopped != "0" ]] ; then
        ret="${ret}${stopped}${m_stop}"
    fi

    [[ -n "$ret" ]] && ret=" $ret"

    printf '%s' "$ret"
}

function bp_virtualenv() {
  [[ -n "$VIRTUAL_ENV" ]] && printf ' %s' " ${VIRTUAL_ENV##*/}"
}

function bp_shlvl() {
  [[ $SHLVL -gt 0 ]] && printf ' %s' "⟱️$SHLVL"
}

# note: unless the last portion of PS1 is a newline, then calling functions will have a
# problem as described here:
# http://stackoverflow.com/questions/6592077/bash-prompt-and-echoing-colors-inside-a-function
function update_ps1 () {
  # this function will build the PS1 string in-place as opposed to embedding bash
  # functions in the string due craziness with escape sequences as mentioned in the
  # stackoverflow link above
  local err=$?

  # prompt variable to build
  local prompt

  prompt="$(bp_segment "$(bp_user)" $USER_COLOR)"

  prompt="$prompt$(bp_segment "$(bp_os_type)" $HOST_COLOR)"

  prompt="$prompt$(bp_segment "$(bp_shlvl)" $SHLVL_COLOR)"

  prompt="$prompt$(bp_segment "$(bp_jobs)" $JOBS_COLOR)"

  # creates a string with a shortened path
  prompt="$prompt$(bp_segment "$(pretty_dir)" $CWD_COLOR)"

  prompt="$prompt$(bp_git)"

  prompt="$prompt$(bp_segment "$(bp_virtualenv)" $VE_COLOR)"

  local character=""
  [[ $err -ne 0 ]] && character="✖"

  # remove "update_terminal_cwd; "
  PROMPT_COMMAND="${PROMPT_COMMAND//update_terminal_cwd; /}"

  PS1="
$(bp_segment "┌─" $PROMPT_COLOR)$prompt$RESET
$(bp_segment "└─$character" $PROMPT_COLOR) "

  export PS1
}

export PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND ;} update_ps1"
