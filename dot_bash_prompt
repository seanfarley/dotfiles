# @gf3’s Sexy Bash Prompt, inspired by "Extravagant Zsh Prompt"
# Shamelessly copied from https://github.com/gf3/dotfiles

# Helper functions are borrowed from liquidprompt:
# https://github.com/nojhan/liquidprompt

# exit if we terminal can't do colors
if [[ ! -t 0 ]] || [[ "$TERM" == "dumb" ]]; then
  return
fi

##
# colored highlighting is awesome
##

if [[ "$TERM" != "dumb" ]] && [[ -x "$(which dircolors 2>/dev/null)" ]]; then
  eval "$(dircolors -b ~/.dir_colors)"
fi

RESET="\[$(tput sgr0)\]"
BOLD=$(tput bold)

# NOTE how to find these codes? use the print_all_colors function to get a table
# of colors with their codes; this works with any theme so there doesn't need to
# be any guessing

USER_COLOR=001
HOST_COLOR=172
SHLVL_COLOR=214
JOBS_COLOR=105
CWD_COLOR=004
VE_COLOR=003
PROMPT_COLOR=243

# VCS COLORS
BRANCH_COLOR=243
MOD_COLOR=001
UNTRACKED_COLOR=003
STAGED_COLOR=002
CONFLICT_COLOR=003
MERGE_COLOR=110
STASH_COLOR=139
REMOTE_COLOR=248

PROMPT_SHOW_OS_VERSION=1

function print_color() {
  for c; do
    printf '\e[48;5;%dm%03d' "$c" "$c"
  done
  printf '\e[0m \n'
}

function print_all_colors() {
  IFS=$' \t\n'
  print_color {0..15}
  for ((i=0;i<6;i++)); do
    print_color $(seq $((i*36+16)) $((i*36+51)))
  done
  print_color {232..255}
}

function colorize () {
  # optional arg 2 could be bold or reset or both or whatevs
  printf '%s' "\[$2\]\[$(tput setaf "$1")\]"
}

function bp_segment () {
  printf '%s' "$(colorize "$2" "$BOLD")$1$RESET"
}

function bp_user () {
  printf '%s' " $USER"
}

function bp_os_type () {
  local os_icon=""
  local pver=""
  local NAME=""
  local VERSION_ID=""

  if [[ "$OSTYPE" == "linux"* ]]; then
    os_icon=""
    if [ -f /etc/os-release ]; then
      # disabling since the warning is a false positive
      # shellcheck disable=SC1091
      source /etc/os-release
      OS="$NAME"
      VER="$VERSION_ID"
    else
      # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
      OS=$(uname -s)
      VER=$(uname -r)
    fi

    if [[ "$OS" == *"Ubuntu"* ]]; then
      os_icon=""
    elif [[ "$OS" == *"Debian"* ]]; then
     os_icon=""
    elif [[ "$OS" == "SLES" ]]; then
      os_icon=""
    elif [[ "$OS" == *"CentOS"* ]]; then
      os_icon=""
    elif [[ "$OS" == *"BSD"* ]]; then
      os_icon=""
    fi

  elif [[ "$OSTYPE" == "darwin"* ]]; then
    os_icon=""
    VER=$(echo "$OSTYPE" | cut -d n -f 2 | cut -d . -f 1)
    if [[ $VER == 21 ]]; then
      VER="Monterey"
    elif [[ $VER == 20 ]]; then
      VER="Big Sur"
    elif [[ $VER == 19 ]]; then
      VER="Catalina"
    elif [[ $VER == 18 ]]; then
      VER="Mojave"
    fi
  elif [[ "$OSTYPE" == "freebsd"* ]]; then
    os_icon=""
  fi

  # remove spaces
  VER=${VER//[[:blank:]]/}
  # the double comma lowercases everything
  [[ $PROMPT_SHOW_OS_VERSION != 0 ]] && pver=" (${VER,,})"

  printf ' %s' "$os_icon $(hostname)$pver"
}

function pretty_dir () {
  local DIRS
  local str_len

  IFS='/' read -ra DIRS <<< "${PWD//$HOME/'~'}"

  # don't shorten the CWD
  for (( i=0; i<${#DIRS[@]}-1; i++ )); do
    # just take the first letter of the directory (exactly what xonsh does);
    # could do more fancy things here
    str_len=1
    [[ ${DIRS[i]:0:1} == "." ]] && str_len=2
    DIRS[i]=${DIRS[i]:0:$str_len}
  done

  printf ' %s' " $(IFS=/; printf '%s' "${DIRS[*]}")"
}

# Search upwards through a directory structure looking for a file/folder with
# the given name.  Used to avoid invoking 'git', hg', 'bzr', etc.
bp_upwards_find()
{
    local dir
    dir="$PWD"
    while [[ -n "$dir" ]]; do
        [[ -d "$dir/$1" || -f "$dir/$1" ]] && printf '%s' "$dir" && return 0
        dir="${dir%/*}"
    done
    return 1
}

function bp_git_branch() {
  local gitdir
  gitdir="$([[ $(\git ls-files . 2>/dev/null | wc -l) -gt 0 ]] && \git rev-parse --git-dir 2>/dev/null)"
  [[ $? -ne 0 || ! $gitdir =~ (.*\/)?\.git.* ]] && return
  local branch
  # Recent versions of Git support the --short option for symbolic-ref, but
  # not 1.7.9 (Ubuntu 12.04)
  if branch="$(\git symbolic-ref -q HEAD)"; then
    printf '%s' "${branch#refs/heads/}"
  else
    # In detached head state, use commit instead
    # No escape needed
    \git rev-parse --short -q HEAD
  fi
}

function bp_git() {
  # https://joshdick.net/2017/06/08/my_git_prompt_for_zsh_revisited.html
  # for performance reasons and, ironically enough, spacing/coloring reasons,
  # put all the git operations in a single function; therefore we put the colors
  # into this function
  local prompt
  local repo_dir
  local git_st
  local remote
  local status
  local merge_info

  repo_dir=$(bp_upwards_find .git)

  [[ -z "$repo_dir" ]] && return

  # space is padded here since this is a specialized function
  prompt="$(bp_segment " " $BRANCH_COLOR)"

  git_st="$(git status 2> /dev/null)"

  [[ "$git_st" == *"Changes not staged for commit:"* ]] && status="$(bp_segment ● $MOD_COLOR)"
  [[ "$git_st" == *"Untracked files:"* ]] && status="$status$(bp_segment ● $UNTRACKED_COLOR)"
  [[ "$git_st" == *"Changes to be committed:"* ]] && status="$status$(bp_segment ● $STAGED_COLOR)"
  [[ -n "$status" ]] && prompt="$prompt $status"

  [[ "$git_st" == *"You have unmerged paths."* ]] && merge_info="$(bp_segment ⚡ $CONFLICT_COLOR)"
  [[ -f "$repo_dir/.git/MERGE_HEAD" ]] && merge_info="$merge_info$(bp_segment  $MERGE_COLOR)"
  [[ -n "$merge_info" ]] && prompt="$prompt $merge_info"

  [[ -n "$(\git stash list 2>/dev/null)" ]] && prompt="$prompt $(bp_segment  $STASH_COLOR)"

  prompt="$prompt $(bp_segment "$(bp_git_branch)" $BRANCH_COLOR)"

  if [[ "$git_st" == *"Your branch is"* ]]; then
    remote="$(echo "$git_st" | perl -lne 'print " $2$1" if /Your branch is (ahead|behind).*?(\d+) comm/' | perl -pe 's,behind,⇣,' | perl -pe 's,ahead,⇡,')"
  else
    remote="$(echo "$git_st" | perl -lne 'print " $1⇡$2⇣" if /and have (\d+) and (\d+) diff/')"
  fi

  prompt="$prompt$(bp_segment "$remote" $REMOTE_COLOR)"

  printf '%s' "$prompt"
}

################
# Related jobs #
################

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
function bp_jobs () {
    local running=$(( $(jobs -r | wc -l) ))
    local stopped=$(( $(jobs -s | wc -l) ))
    local m_stop="z"
    local m_run="&"
    local ret=""

    if [[ $running != "0" ]] ; then
        ret="${ret}${running}${m_run}"
    fi

    if [[ $stopped != "0" ]] ; then
        ret="${ret}${stopped}${m_stop}"
    fi

    [[ -n "$ret" ]] && ret=" $ret"

    printf '%s' "$ret"
}

function bp_virtualenv() {
  # https://starship.rs/config/#python
  local repo_dir

  # assume a git directory is a project
  repo_dir="$(bp_upwards_find .git)"

  [[ -z "$repo_dir" ]] && repo_dir=/dev/null

  if [[ -n "$(ls ./*.py 2>/dev/null)" ||
          -n "$VIRTUAL_ENV" ||
          ( -n "$repo_dir" &&
              (-f "$repo_dir/.python-version" ||
                 -f "$repo_dir/pyproject.toml" ||
                 -f "$repo_dir/requirement.txt" ||
                 -f "$repo_dir/tox.ini" ||
                 -f "$repo_dir/setup.py" ) ) ]]; then
    printf ' %s' " $(python3 --version | sed 's,Python ,,')"

    [[ -n "$VIRTUAL_ENV" ]] && printf ' %s' "(${VIRTUAL_ENV##*/})"
  fi
}

function bp_shlvl() {
  [[ $SHLVL -gt 1 ]] && printf ' %s' "⟱️$SHLVL"
}

function update_ps1 () {
  local err=$?

  # prompt variable to build
  local prompt

  prompt="$(bp_segment "$(bp_user)" $USER_COLOR)"

  prompt="$prompt$(bp_segment "$(bp_os_type)" $HOST_COLOR)"

  prompt="$prompt$(bp_segment "$(bp_shlvl)" $SHLVL_COLOR)"

  prompt="$prompt$(bp_segment "$(bp_jobs)" $JOBS_COLOR)"

  # creates a string with a shortened path
  prompt="$prompt$(bp_segment "$(pretty_dir)" $CWD_COLOR)"

  prompt="$prompt$(bp_git)"

  prompt="$prompt$(bp_segment "$(bp_virtualenv)" $VE_COLOR)"

  local character=""
  [[ $err -ne 0 ]] && character="✖"

  # remove "update_terminal_cwd; "
  PROMPT_COMMAND="${PROMPT_COMMAND//update_terminal_cwd; /}"
  PROMPT_COMMAND="${PROMPT_COMMAND//update_terminal_cwd ; /}"

  PS1="
$(bp_segment "┌─" $PROMPT_COLOR)$prompt$RESET
$(bp_segment "└─$character" $PROMPT_COLOR) "

  export PS1
}

PROMPT_COMMAND="_z --add $(command pwd -P 2>/dev/null) 2>/dev/null; update_ps1; history -a"
export PROMPT_COMMAND
