#+OPTIONS: toc:2

* Sean Farley's Emacs Configuration

** Preamble

As my editor of choice I run Emacs. One of the benefits of Emacs is
that it'll install basically anywhere.

This configuration is designed to run in shells as well as on
desktops. There are some platform specific optimisations as well.

This excellent configuration was forked from [[https://github.com/bradleywright/emacs.d][Bradley Wright]].

*** What is this?

It's built using [[http://orgmode.org][Org mode]]'s [[http://orgmode.org/manual/Extracting-source-code.html#Extracting-source-code][tangling functionality]].

My entire Emacs configuration is thus written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style,
and is contained entirely in this file.

*** Installing

Just check it out straight to the right directory, and use Make to
install it:

: cd ~/Projects/emacs.d && make

*** Platform specific configuration

**** OS X desktop (Emacs.app)

- Left =option= key is remapped to =M-=
- We use the [[https://github.com/bbatsov/solarized-emacs][Solarized Dark]] theme
- Font is [[https://github.com/Lokaltog/powerline-fonts/tree/master/SourceCodePro][Source (Sauce) Code Pro]]

**** OS X CLI in iTerm2

- When the [[https://github.com/altercation/solarized/blob/master/iterm2-colors-solarized/Solarized%20Dark.itermcolors][Solarized Dark iTerm2 theme]] is installed, we use the
  =solarized-dark= color theme
- Cut/paste are made to write/read from the clipboard (via =pbcopy=
  and =pbpaste=)
- Mouse highlighting works via xTerm capabilities

***** Required iTerm 2 Configuration

     - Re-map left =option= key to =+Esc=
     - Untick =Smart cursor color=

*** Included libraries

The following libraries are included in non-attributable ways, i.e not
via package install or via a Git submodule:

- [[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]] was a very big early influence, and continues to
  be helpful.

*** License and copyright

Copyright 2010-2014 Bradley Wright.
Copyright 2014 Sean Farley.

Files are licensed under the same license as Emacs (GPL) unless
otherwise specified. See the =COPYING= file for more information.

Any external/third party works included in this work are licensed under
their own licenses - refer to the submodules or packages for more
information.

** Conventions

Functions and variables defined exclusively for my use are prefixed with my
initials and a slash =smf/= to namespace them.

** Setup

Emacs looks in [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Loading-Files.html][load-path]] for Emacs lisp files. =require= and other loading
constructs use this when looking for implicit names.

First we define a convenience function =smf/add-to-load-path= that adds the
passed in directory to =load-path=:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-to-load-path (dir)
    "Adds `dir' to load-path"
    (add-to-list 'load-path dir))
#+END_SRC

and a convenience function for making a proper path out of two strings:

#+begin_src emacs-lisp
  (defun smf/join-dirs (prefix suffix)
    "Joins `prefix' and `suffix' into a directory"
    (file-name-as-directory (concat prefix suffix)))
#+end_src

*** Base load path

Define a base directory =smf/dotfiles-dir= that's relative to the currently
loading file (this file). This means if I deliberately start Emacs with a file
loaded:

#+BEGIN_SRC
$ emacs -q -l ~/src/emacs/init.el
#+END_SRC

then =smf/dotfiles-dir= will be =~/src/emacs=.

#+BEGIN_SRC emacs-lisp
  (defconst smf/dotfiles-dir
    (file-name-directory
     (or (buffer-file-name) load-file-name))
    "Base path for customised Emacs configuration")
#+END_SRC

This variable is important because all other directories I load things from are
relative to it, which means my Emacs config doesn't need to live in
=user-emacs-directory=.

*** Temporary directory

Emacs has many packages which need to store state in files. Generally these are
in =~= or =user-emacs-directory= - since my entire =~/.emacs.d= is versioned,
I'd rather all temporary files were stored in a known place, =smf/tmp-local-dir=.
This directory is created if it doesn't exist.

#+begin_src emacs-lisp
  (make-directory
   (setq smf/tmp-local-dir
         (smf/join-dirs smf/dotfiles-dir ".tmp")) t)
#+end_src

*** Backups

Emacs automatically [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Backup.html][backs up files]] while you're editing them. The default
configuration isn't great though.

First, set up some directories to keep backups:

#+begin_src emacs-lisp
  (make-directory
   (setq smf/tmp-backups-dir
         (smf/join-dirs smf/tmp-local-dir "backups")) t)
  (make-directory
   (setq smf/tmp-autosaves-dir
         (smf/join-dirs smf/tmp-local-dir "autosaves")) t)
#+end_src

Now use those directories for backups and autosave files:

#+begin_src emacs-lisp
  (setq backup-directory-alist `((".*" . ,smf/tmp-backups-dir))
        auto-save-file-name-transforms `((".*" ,smf/tmp-autosaves-dir)))
#+end_src

Always copy files when backing up to avoid breaking symlinks:

#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

Delete old versions automatically, and keep a limited number around:

#+begin_src emacs-lisp
  (setq delete-old-versions t
        kept-new-versions 2
        kept-old-versions 2)
#+end_src

Finally, use version numbers in the filenames:

#+begin_src emacs-lisp
  (setq version-control t)
#+end_src

** =after-load=

First let's define a convenient macro that wraps typical =eval-after-load= in
such a way that we don't need to use =progn= to contain the callback logic. This
macro was gotten from [[https://github.com/purcell/emacs.d/blob/aa789c9745b13612c4fea6e638d81d8ebbfecdf8/init-utils.el#L1-L5][Steve Purcell's emacs.d repo]]:

#+begin_src emacs-lisp
  (defmacro after-load (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body)))
#+end_src

** Client/server

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server][client/server]] model for editing. The client is invoked via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Invoking-emacsclient.html][the
=emacsclient= command]]. More information on configuration is available on the
[[http://www.emacswiki.org/emacs/EmacsClient][EmacsWiki EmacsClient page]].

We make sure the server is running, additionally guarded to check if the version
of Emacs we're using supports the server package:

#+begin_src emacs-lisp
  (setq server-use-tcp t)
  (when (require 'server nil t)
    (unless (server-running-p)
      (server-start)))
#+end_src

** Editing defaults

Emacs comes with a collection of strange defaults. See [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's
=sane-defaults.el= file]] for some commentary.

*** Line widths and wrapping

The default wrap width (known as [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Filling.html][filling]]) for Emacs is 70 characters. Modern
conventions state that 80 characters is the standard:

#+begin_src emacs-lisp
  (setq-default fill-column 80)
#+end_src

I don't type double-space sentences, so make sure that Emacs doesn't look for
double-spaces after periods to fill paragraphs correctly:

#+begin_src emacs-lisp
  (setq-default sentence-end-double-space nil)
#+end_src

*** Trailing whitespace

Most UNIX tools work best when there's a trailing newline on all files. Enable
that option:

#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

Emacs has lots of other options for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Useless-Whitespace.html][managing superfluous whitespace]].

*** Indentation

I don't use tabstops in files, and my default tab width is 4 characters.

It's worth noting that Emacs can override either of those on a per-file/mode
basis, so Makefiles, Ruby etc. will still get the correct indentation rules.

#+begin_src emacs-lisp
  (setq-default
   indent-tabs-mode nil
   tab-width 4
   tab-stop-list (number-sequence 4 120 4)
   sh-basic-offset 2
   sh-indentation 2
   c-basic-offset 4
   web-mode-code-indent-offset 4
   web-mode-markup-indent-offset 4
   web-mode-css-indent-offset 4
   web-mode-sql-indent-offset 4)
#+end_src

**** Auto-indentation

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Indent-Convenience.html][Electric indent mode]] was added in Emacs 24.1, and it enables automatic indentation when typing a newline. [[http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation][More about electric indent mode on Emacs Redux]].

First we define convenience toggling functions we can use in a hook (or interactively):

#+begin_src emacs-lisp
  (defun smf/turn-on-electric-indent-mode ()
    "Turns on electric-indent-mode"
    (interactive)
    (electric-indent-mode 1))

  (defun smf/turn-off-electric-indent-mode ()
    "Turns off electric-indent-mode"
    (interactive)
    (electric-indent-mode -1))
#+end_src

then we enable it for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Program-Modes.html][the generic abstract programming mode =prog-mode=,
introduced in Emacs 24.1]] ([[http://emacsredux.com/blog/2013/04/05/prog-mode-the-parent-of-all-programming-modes/][more about =prog-mode= on Emacs Redux]]):

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'smf/turn-on-electric-indent-mode)
#+end_src

*** Encoding

I want to have [[http://en.wikipedia.org/wiki/UTF-8][UTF-8]] by default. [[http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/][Emacs unfortunately has a few settings that
govern encoding]], so we should set them all at once:

#+begin_src emacs-lisp
  ;; Utf-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
#+end_src

*** Smart =beginning-of-line=

=C-a= is mapped to =beginning-of-line= by default, which moves point to position
0 on the current line. [[http://irreal.org/blog/?p=1946][The irreal blog suggests a smarter alternative]] that moves
the point to the first non-whitespace character first, and then position 0, with
extra presses toggling the position:

#+begin_src emacs-lisp
  (defadvice move-beginning-of-line (around smarter-bol activate)
    ;; Move to requested line if needed.
    (let ((arg (or (ad-get-arg 0) 1)))
      (when (/= arg 1)
        (forward-line (1- arg))))
    ;; Move to indentation on first call, then to actual BOL on second.
    (let ((pos (point)))
      (back-to-indentation)
      (when (= pos (point))
        ad-do-it)))
#+end_src

This functionality uses the Emacs concept of [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][advice]], which is a way of modifying
existing functions in-place without redefining the entire thing.

*** Fix minibuffer behaviour

When changing focus to the minibuffer, stop allowing point to move over the
prompt. Code taken from [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][ergoemacs]].

#+begin_src emacs-lisp
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'minibuffer-avoid-prompt))
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'point-entered))
#+end_src

While we're at it, let's allow recursive minibuffers.

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

Also, let's save the minibuffer history between sessions. It's 2014. We have the
technology.

#+begin_src emacs-lisp
  (savehist-mode t)
  (setq history-length 1000)
#+end_src

*** Deleting files

Move files to the trash when deleting:

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash t)
#+end_src

*** Compressed files

Transparently open compressed files:

#+begin_src emacs-lisp
  (auto-compression-mode t)
#+end_src

*** Active region

Got these from [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's =sane-defaults.el=]]. Show the active region,

#+begin_src emacs-lisp
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+end_src

Remove text in active region if inserting text,

#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

*** Pop mark

When popping the mark, continue popping until the cursor actually moves. Also,
if the last command was a copy - skip past all the expand-region cruft.

#+begin_src emacs-lisp
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+end_src

** Keyboard

*** Modifier keys

- =C-= means =Control= in combination with another key, eg =C-x= means =Ctrl + x=
- =M-= means =Meta= in combination with another key. This is usually =Alt=, or
  =⌘= on OS X (by default). =Esc= also serves as =Meta= if it's not separately
  bound. On OS X I want to use left =⌥= for =Meta=, and leave right =⌥= alone:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-alternate-modifier 'meta)
    (setq mac-option-modifier 'meta)
    (setq ns-right-alternate-modifier nil))
#+END_SRC

- =s-= means [[http://en.wikipedia.org/wiki/Super_key_(keyboard_button)][super key]]. On OS X I want this to be =⌘=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-command-modifier 'super)
    (setq mac-command-modifier 'super)) ;; for EmacsMac.app
#+END_SRC

- =H-= means [[http://en.wikipedia.org/wiki/Hyper_key][hyper key]]. On OS X I want this to be =fn=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-function-modifier 'hyper)
    (setq mac-function-modifier 'hyper)) ;; for EmacsMac.app
#+END_SRC

*** Basic remappings

The below are some remappings I got from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's Effective Emacs]] article.
They're designed to map some slightly difficult but very common mappings to
things that are easier to type.

**** Invoke =M-x= without the Alt key

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item2][Yegge's Item 2]]. This unmaps the difficult =M-x= (usually =Alt+x=) to =C-x
m=, and then add a fat-finger combination of =C-x C-m=:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'execute-extended-command)
  (global-set-key (kbd "C-x C-m") 'execute-extended-command)
#+end_src

**** Prefer =backward-kill-word= over Backspace

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item3][Yegge's Item 3]]. This emulates readline =C-w= command to
=backward-kill-word=. The command that used to live there (=kill-region=) is not
needed since the backspace key works just fine in that case.

#+begin_src emacs-lisp
  ;; deletes backward until a space is hit
  (defun smf/backward-kill-word ()
    (interactive)
    (if (and transient-mark-mode mark-active)
        (kill-region (point) (mark))
      (progn
        (delete-region (point) (save-excursion (skip-syntax-backward " ") (point)))
        (delete-region (point) (save-excursion (skip-syntax-backward "^ ") (point))))))

  (global-set-key (kbd "C-w") 'smf/backward-kill-word)
#+end_src

**** Quick window switching

Usually one must type =C-x o= to switch between windows - make that quicker by
also mapping =M-o=:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
  ;; Moving between windows
  (global-set-key (kbd "C-s-<up>") 'windmove-up)
  (global-set-key (kbd "C-s-<down>") 'windmove-down)
  (global-set-key (kbd "C-s-<right>") 'windmove-right)
  (global-set-key (kbd "C-s-<left>") 'windmove-left)
#+end_src

**** Buffer management

Burying a buffer (removing it from the current window and sending it to the
bottom of the stack) is very common for dismissing buffers. Add a mapping for
it:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c y") 'bury-buffer)
#+end_src

Add a key combination to revert the current buffer (re-read the contents from
disk):

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+end_src

Use =ido-switch-buffer= instead of the feature-lacking =list-buffers= (and
include a common typo I make):

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
  (global-set-key (kbd "C-x C-n") 'ido-switch-buffer)
#+end_src

*** Launcher keymap

This trick I got from [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][a blog post on launcher keymaps]]. I define my launcher
combo as =C-x C-l=, which is normally =downcase-region= - a command I use so
infrequently I didn't even know there was a key binding for it.

#+begin_src emacs-lisp
  (define-prefix-command 'smf/launcher-map)
  (define-key ctl-x-map (kbd "C-l") 'smf/launcher-map)
#+end_src

rather than remembering that it's =smf/launcher-map=, just make a function:

#+begin_src emacs-lisp
  (defun smf/add-launcher (key function)
    "Maps FUNCTION to KEY under the `smf/launcher-map' prefix"
    (define-key smf/launcher-map key function))
#+end_src

** Interface

*** Remove chrome

To ensure that all scrollbars, toolbars etc. are turned off, we run this as
early as possible.

#+NAME: turn-off-chrome
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))
#+END_SRC

*** Startup buffers

Turn off the startup screen, and always show =*scratch*=.

#+NAME: turn-off-startup
#+BEGIN_SRC emacs-lisp
  ;; inhibit startup screen
  (setq inhibit-startup-screen t
        ;; Show *scratch* on start
        initial-buffer-choice t)
#+END_SRC

*** Font

I use [[https://github.com/Lokaltog/powerline-fonts/tree/master/SourceCodePro][Source (Sauce) Code Pro]] as my default coding font:

#+begin_src emacs-lisp
  ;; set the font
  (when (window-system)
    (condition-case err
      (set-default-font "Source Code Pro for Powerline Light")
      (error
        (set-default-font "Sauce Code Powerline Light"))))
#+end_src

*** Syntax highlighting

Syntax highlighting in Emacs is called [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Font-Lock.html][font locking]]. It's enabled by
=font-lock-mode=. This turned on by default in modern Emacs systems, but it's
worth keeping around:

#+begin_src emacs-lisp
  (global-font-lock-mode t)
#+end_src

Emacs also supports multiple levels of complexity for highlighting. Setting this
value to =t= forces it to pick the maximum available (also the default):

#+begin_src emacs-lisp
  (setq font-lock-maximum-decoration t)
#+end_src

*** Line and column numbers

Emacs doesn't display line numbers by the code by default. For that you want
[[http://www.emacswiki.org/emacs/LineNumbers#toc1][Linum mode]].

I want to display the current line number in the
[[http://www.emacswiki.org/emacs/ModeLine][mode line]], and also the current
column number:

#+begin_src emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+end_src

*** Tooltips

Emacs convention is to show help and other inline documentation in the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/message.html][message
area]]. Show help there instead of using an OS tooltip:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (tooltip-mode -1))
#+end_src

*** Dialogue boxes and windows

Just don't show them. Use native Emacs controls:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq use-dialog-box nil))
#+end_src

Make the window title display the full path of the file I'm currently editing:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b")))))
#+end_src

Aside: Emacs calls OS windows [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][frames]] and divisions within frames [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][windows]]. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Titles.html][More
information on frame titles]].

*** Cursor

I prefer a box, non-blinking cursor. So, turn off that blinking:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq-default cursor-type 'box)
    (blink-cursor-mode (- (*) (*) (*))))
#+end_src

Depending on the mode, let's [[http://www.emacswiki.org/emacs/ChangingCursorDynamically][change the cursor]].

#+begin_src emacs-lisp
  (setq smf/read-only-color       "gray")
  (setq smf/read-only-cursor-type 'hbar)
  (setq smf/overwrite-color       "red")
  (setq smf/overwrite-cursor-type 'box)
  (setq smf/normal-color          "gray")
  (setq smf/normal-cursor-type    'box)

  (defun smf/set-cursor-according-to-mode ()
    "change cursor color and type according to some minor modes."

    (cond
     (buffer-read-only
      (set-cursor-color smf/read-only-color)
      (setq cursor-type smf/read-only-cursor-type))
     (overwrite-mode
      (set-cursor-color smf/overwrite-color)
      (setq cursor-type smf/overwrite-cursor-type))
     (t
      (set-cursor-color smf/normal-color)
      (setq cursor-type smf/normal-cursor-type))))

  (add-hook 'post-command-hook 'smf/set-cursor-according-to-mode)
#+end_src

*** Typing

Show the modifier combinations I just typed almost immediately:

#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+end_src

Don't make me type =yes= or =no= to boolean interface questions:

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Code commenting

A drop-in replacement for comment-dwim. If no region is selected and current
line is not blank and we are not at the end of the line, then comment current
line.

#+begin_src emacs-lisp
  (defun comment-dwim-line (&optional arg)
    (interactive "*P")
    (comment-normalize-vars)
    (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
        (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (comment-dwim arg)))
  (global-set-key (kbd "M-;") 'comment-dwim-line)
#+end_src

Comment or uncomment the region or current line if no active region.

#+begin_src emacs-lisp
  (defun comment-or-uncomment-region-or-line ()
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))
  (global-set-key (kbd "s-;") 'comment-or-uncomment-region-or-line)
#+end_src

*** Bells

Don't make a sound when [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Beeping.html][ringing a bell]] - flash a visual bell instead:

#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

Override the =ring-bell-function= to conditionally ring the bell only when it's
not a valid quit case like hitting =esc= or =C-g=. Generally this means the bell
will only ring when there's actually an error raised somehow:

#+begin_src emacs-lisp
  (setq ring-bell-function
        (lambda ()
          "Only rings the bell if it's not a valid quit case, e.g
  keyboard-quit"
          (unless (memq this-command
                        '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
            (ding))))
#+end_src

*** Buffer naming

By default Emacs resolves conflicting buffer names by appending a number to
them. For instance, if I open =~/src/thing/init.el= and
=~/src/other-thing/init.el= they'll be named =init.el= and =init.el<2>=
respectively.

We can use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][Uniquify]] library to name them =thing/init.el= and
=other-thing/init.el=, which is much easier to make sense of.

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+end_src

*** Themes

On a GUI Emacs, I want to use the [[zenburn-theme]]. On a terminal I want to use the
[[base16-theme]].


#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda ()
                               (if (window-system)
                                   ;; (load-theme 'solarized-dark t)
                                   (load-theme 'zenburn t)
                                 (load-theme 'base16-default t))))
#+end_src

** OS X specific configuration

Besides the keyboard configuration above, there are some other specific things I
do on OS X. On OS X =system-type= is the symbol =darwin=.

*** Host name mangling

Typically OS X hosts are called things like =hostname.localconfig= or
=hostname.local=. Make Emacs report that without the extra suffix:

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq system-name (car (split-string system-name "\\."))))
#+end_src

*** Spelling correction

[[https://www.gnu.org/software/ispell/][ispell]] isn't generally available on OS X. [[http://aspell.net][aspell]] is available via [[https://github.com/Homebrew/homebrew/blob/master/Library/Formula/aspell.rb][Homebrew]], so
let's use that if we can find it:

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (executable-find "aspell"))
      (setq ispell-program-name (executable-find "aspell")))
#+end_src

On the mac, the default mouse bindings are problematic since a two-finger click
is =mouse-3= and not =mouse-2=:

#+begin_src emacs-lisp
    (after-load 'flyspell
      (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
      (define-key flyspell-mouse-map [mouse-3] #'undefined))
#+end_src

*** dired fixes

OS X's bundled version of =ls= isn't the GNU one, so it doesn't support the
=--dired= flag. Emacs caters for that use case:

#+begin_src emacs-lisp
  (setq dired-use-ls-dired nil)
#+end_src

*** sRGB display fixes

As of Emacs 24.4, [[http://lists.gnu.org/archive/html/emacs-devel/2013-12/msg00741.html][Emacs natively supports proper sRGB]] values on OS X:

#+begin_src emacs-lisp
  (setq ns-use-srgb-colorspace t)
#+end_src

If you're not using Emacs 24.4 this variable setting will have no effect. See
[[https://github.com/Homebrew/homebrew/blob/7446162e59fe548a0fde735d25b9913f8fa2ad4a/Library/Formula/emacs.rb#L10][Homebrew's Emacs recipe]] for details of how to get this behaviour in earlier
Emacs versions.

*** Terminal integration

Using this configuration, Emacs runs best in [[http://iterm2.com][iTerm2]].

On the desktop, Emacs integrates with the OS X clipboard, so =kill= etc. copy to
the clipboard, and =yank= copies from the clipboard.

Obviously this doesn't work in the terminal, so we need to use the
=interprogram-(cut|paste)-function= variables to copy/paste. Most of this code
gotten from [[http://mindlev.wordpress.com/2011/06/13/emacs-in-a-terminal-on-osx/#comment-20][this blog comment]].

#+begin_src emacs-lisp
  (when (and (not (display-graphic-p)) (eq system-type 'darwin))
    (defun smf/copy-from-osx ()
      "Copies the current clipboard content using the `pbcopy` command"
      (shell-command-to-string "pbpaste"))

    (defun smf/paste-to-osx (text &optional push)
      "Copies the top of the kill ring stack to the OSX clipboard"
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))

    (setq interprogram-cut-function 'smf/paste-to-osx)
    (setq interprogram-paste-function 'smf/copy-from-osx))
#+end_src

Also, allow pasting selection outside of Emacs:

#+begin_src emacs-lisp
  (setq x-select-enable-clipboard t)
#+end_src

*** Fullscreen support

On Emacs 24.4 and above, Lion-style fullscreen display is supported but I
dislike it. Define a method to toggle fullscreen pre-Lion.

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (fboundp 'toggle-frame-fullscreen))
    (defun toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      (set-frame-parameter nil 'fullscreen
                           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

      (global-set-key (kbd "C-s-f") 'toggle-fullscreen))
#+end_src

On the Yosemite beta, =ns-use-native-fullscreen= is =nil=.

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq ns-use-native-fullscreen nil))
#+end_src

*** OS X keybindings

There are a lot of native OS X-isms that I would like to keep. Things such =⌘-a=
to select the whole buffer, or =⌘-c= to copy.

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-a") 'mark-whole-buffer)
    (global-set-key (kbd "s-v") 'yank)
    (global-set-key (kbd "s-c") 'kill-ring-save)
    (global-set-key (kbd "s-x") 'kill-region)
    (global-set-key (kbd "s-s") 'save-buffer)
    (global-set-key (kbd "s-l") 'goto-line)
    (global-set-key (kbd "s-w")
                    (lambda () (interactive) (delete-window)))
    (global-set-key (kbd "s-z") 'undo)
    (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
    (global-set-key (kbd "s-k") 'kill-this-buffer)
    (global-set-key (kbd "s-r") 'recompile)
    (global-set-key (kbd "s-}") 'forward-paragraph)
    (global-set-key (kbd "s-{") 'backward-paragraph)
    (global-set-key (kbd "s-f") 'isearch-forward)
    (global-set-key (kbd "s-g") 'isearch-repeat-forward))
#+end_src

The =⌘-backspace= deletes text from the current position to the beginning of the
line.

#+begin_src emacs-lisp
  (global-set-key [s-backspace] [?\C- ?\C-a backspace])
#+end_src

** Utility functions

*** Rename modeline

Renames the major-mode lighter in the modeline. Lifted from [[http://whattheemacsd.com/appearance.el-01.html][What the emacs.d]].

#+begin_src emacs-lisp
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))
#+end_src

*** Get keychain password

If I'm on OS X, I can fetch passwords etc. from my Keychain. This is much more
secure than storing them in configuration on disk:

#+begin_src emacs-lisp
  (defun smf/chomp (str)
    "Chomp leading and tailing whitespace from `str'."
    (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'" str)
      (setq str (replace-match "" t t str))) str)

  (defun smf/get-keychain-password (account-name)
    "Get `account-name' keychain password from OS X Keychain"
    (interactive "sAccount name: ")
    (smf/chomp
     (shell-command-to-string
      (concat
       "security find-generic-password -wa "
       account-name))))
#+end_src

*** Conditionally kill Emacs

When I'm in an emacsclient, I probably just want the client to die rather than
the entire server. And, when I kill my server, I want Emacs to confirm this with
me:

#+begin_src emacs-lisp
  (defun smf/kill-emacs ()
    "If this buffer is a client, just kill it, otherwise confirm
  the quit."
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (if (= (length (frame-list)) 1)
        (save-buffers-kill-terminal))))
#+end_src

Enable this, and override the default command Emacs assigns to kill itself:

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap save-buffers-kill-terminal] 'smf/kill-emacs)
#+end_src

Also, when using an emacsclient that is waiting, I don't want a prompt that asks
if I really want to exit. So, we define our own function and bind it to =⌘-k=.

#+begin_src emacs-lisp
  (add-hook 'server-switch-hook
            (lambda ()
              (local-set-key (kbd "s-k") '(lambda ()
                                            (interactive)
                                            (if server-buffer-clients
                                                (server-edit)
                                              (kill-this-buffer))))))
#+end_src

** Other modes

Emacs comes with hundreds of major and minor modes to do many many things. These
are the ones I commonly use and have configured.

*** org

[[http://orgmode.org][org-mode]] is a plain text system for organising information and notes.

Don't auto-fold my documents:

#+begin_src emacs-lisp
  (setq org-startup-folded nil)
#+end_src

When editing [[http://orgmode.org/manual/Working-With-Source-Code.html#Working-With-Source-Code][nested source code]], always accept Emacs Lisp:

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)))
#+end_src

and automatically apply syntax highlighting:

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+end_src

When using [[http://www.emacswiki.org/emacs/ImenuMode][imenu]], make sure I can follow the outline to the full available
depth:

#+begin_src emacs-lisp
  (setq org-imenu-depth 6)
#+end_src

*** ido

[[http://www.emacswiki.org/emacs/InteractivelyDoThings][ido]] is a mode for narrowing candidates as you type. It has excellent
integration with buffer switching and finding files. [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mastering Emacs has a good
guide to Ido]].

First we enable =ido-mode= globally and enable =ido-everywhere=, which enables
Ido for buffer and file reading:

#+begin_src emacs-lisp
  (after-load 'ido
    (ido-mode t)
    (ido-everywhere t))
#+end_src

Force Ido to [[http://stackoverflow.com/a/11341239/61435][ignore Dropbox cruft]]:

#+begin_src emacs-lisp
  (after-load 'ido
    (add-to-list 'ido-ignore-files "Icon\n"))
#+end_src

Also ignore certain extensions that I don't care about

#+begin_src emacs-lisp
  (setq completion-ignored-extensions
        '(".o" ".elc" "~" ".bin" ".bak" ".obj" ".map" ".a" ".ln" ".mod" ".gz"
          ".aux" ".tdo" ".fmt" ".swp" ".pdfsync" ".pdf" ".vrb" ".idx" ".ind"
          ".bbl" ".toc" ".blg" ".snm" ".ilg" ".log" ".out" ".pyc" ".DS_Store"
          "-blx.bib" ".run.xml" ".hi" ".fls" ".fdb_latexmk" ".bcf" ".rel"))
#+end_src

Configure Ido (see comments for more information):

#+begin_src emacs-lisp
  (after-load 'ido
    (setq
     ;; Speed up ido by using less candidates
     ido-max-prospects 10
     ;; Match arbitrary points in strings
     ido-enable-prefix nil
     ;; Match across entire string
     ido-enable-flex-matching t
     ;; Create a new buffer if there's no match candidate
     ido-create-new-buffer 'always
     ;; Don't try and guess if the string under point is a file
     ido-use-filename-at-point nil
     ;; case-insensitive matching
     ido-case-fold t
     ;; don't store old files as virtual buffers
     ido-use-virtual-buffers nil))
#+end_src

Store =ido= temporary directory cache elsewhere:

#+begin_src emacs-lisp
  (setq ido-save-directory-list-file (expand-file-name ".ido.last" smf/tmp-local-dir))
#+end_src

Finally load Ido:

#+begin_src emacs-lisp
  (require 'ido)
#+end_src

*** bookmarks

Emacs has robust [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Bookmarks.html][bookmarking functionality]]. It uses a file to persit the list of
bookmarks, so make sure that file is in my custom temporary directory:

#+begin_src emacs-lisp
  (after-load 'bookmark
    (setq bookmark-default-file (expand-file-name ".emacs.bmk" smf/tmp-local-dir)))
#+end_src

*** eldoc-mode

[[http://www.emacswiki.org/emacs/ElDoc][eldoc-mode]] is a minor mode that displays context-sensitive help when editing
Emacs lisp (eg information about arity of functions). Enable that for
=emacs-lisp-mode=:

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
#+end_src

*** python-mode

As of 24.2, Emacs ships with a [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs#toc1][robust Python mode]]. However, when navigating
=SnakeCase= words (eg class names), =forward-word= etc don't work correctly.

We can work around that using [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html#Subword-Movement][subword-mode]]:

#+begin_src emacs-lisp
  (add-hook 'python-mode-hook (lambda () (subword-mode 1)))
#+end_src

*** ruby-mode

As of 24.4, Emacs comes with a much better [[http://www.masteringemacs.org/articles/2013/12/29/whats-new-in-emacs-24-4/][Ruby mode]]. However it doesn't come
with =subword-mode= enabled by default:

#+begin_src emacs-lisp
  (after-load 'ruby-mode
    (add-hook 'ruby-mode-hook (lambda () (subword-mode 1))))
#+end_src

Add =Puppetfile= files to [[ruby-mode]]:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("[pP]uppetfile\\'" . ruby-mode))
#+end_src

*** hippie

[[http://www.emacswiki.org/emacs/HippieExpand][Hippie expand]] is a more feature complete completion engine than the default
[[http://www.emacswiki.org/emacs/DynamicAbbreviations][dabbrev]] engine. The main feature I use over =dabbrev= is that it supports a wide
range of backends for finding completions - =dabbrev= only looks at currently
open buffers.

First we customise the types of things it looks for:

#+begin_src emacs-lisp
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))
#+end_src

Then we override =dabbrev-expand='s keybinding to use =hippie-expand= instead
(normally this is =M-/=):

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap dabbrev-expand] 'hippie-expand)
#+end_src

*** tramp mode

=tramp-mode= is a package that provides [[https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top][remote file editing]], eg =find-file
/user@host:file=. This allows one to edit files on other servers using your
local Emacs (rather than the Vim user's equivalent of editing the file on the
server).

All of the below are wrapped in an =after-load= construct because =tramp-mode=
isn't loaded by default on older versions of Emacs.

First we set the default mode to be =ssh= (it's normally =scp=). There are two
reasons for this choice:

- =ssh= takes a port number as an argument, whereas =scp= doesn't
- It's [[http://www.gnu.org/software/tramp/#Default-Method][apparently faster]] for smaller files

#+begin_src emacs-lisp
  (after-load 'tramp
    (setq tramp-default-method "ssh"))
#+end_src

We also want to alter the list of allowed proxies (tramp uses a whitelist for
patterns that it can remotely access) so I can edit remote files as sudo, eg
=find-file /sudo:example.com/etc/something-owned-by-root=.

I got this code from the [[http://www.gnu.org/software/tramp/#Multi_002dhops][Multi-hops section of the tramp manual]].

#+begin_src emacs-lisp
  (after-load 'tramp
    (add-to-list 'tramp-default-proxies-alist
                 '(nil "\\`root\\'" "/ssh:%h:")))
#+end_src

Also make sure we can edit local files as sudo - this is normally disallowed for
security reasons:

#+begin_src emacs-lisp
  (after-load 'tramp
    (add-to-list 'tramp-default-proxies-alist
                 '((regexp-quote (system-name)) nil nil)))
#+end_src

More on the last two incantations at [[http://emacs-fu.blogspot.co.uk/2009/10/editing-files-owned-by-root.html][emacs-fu's guide to editing files owned by root]].

*** eshell

[[http://www.gnu.org/software/emacs/manual/html_node/eshell/][eshell]] is a shell-like command interpreter built with Emacs lisp. It integrates
well with Emacs, and can be a convenient way to get a shell without invoking
bash or similar (provided you don't want any interactive commands).

There's a great guide to [[http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/][mastering eshell]] on [[http://www.masteringemacs.org][Mastering Emacs]].

eshell has a directory where it stores bookmarks and other temporary cruft -
move that out of the way:

#+begin_src emacs-lisp
  (setq eshell-directory-name (smf/join-dirs smf/tmp-local-dir "eshell"))
#+end_src

When using the =ssh= command (or =vagrant ssh=, which is really the same thing),
we'll want to jump into something that's an actual terminal emulator like
=ansi-term= (eshell won't be able to deal with the login on the remote machine):

#+begin_src emacs-lisp
  (after-load 'esh-opt
    (require 'em-term)
    (add-to-list 'eshell-visual-commands "ssh")
    (when (fboundp 'eshell-visual-subcommands)
      (add-to-list 'eshell-visual-subcommands '("vagrant" "ssh"))))
#+end_src

Define a keybinding to get an =eshell= buffer anywhere:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-t e") 'eshell)
#+end_src

*** ansi-term

[[http://www.emacswiki.org/emacs/AnsiTerm][ansi-term]] is a terminal emulator written in Emacs Lisp. It's more like a
traditional terminal emulator than [[eshell]].

Force ansi-term to be UTF-8 after it launches:

#+begin_src emacs-lisp
  (defadvice ansi-term (after smf/advise-ansi-term-coding-system activate)
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
#+end_src

When exiting a terminal buffer (either with =exit= or =EOF=), automatically kill
the buffer:

#+begin_src emacs-lisp
  (defadvice term-sentinel (around smf/advice-term-sentinel (proc msg) activate)
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
#+end_src

*** recentf

[[http://www.emacswiki.org/emacs/RecentFiles][recentf]] stores a list of recently opened files.

Never clean up the list:

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-auto-cleanup 'never))
#+end_src

The list of files contains any files Emacs has read, not just files I've
explicitly opened. Clean that list to exclude Emacs metafiles, package cruft
etc.

TODO: refactor to use =recentf-keep=: [[http://www.emacswiki.org/emacs/RecentFiles#toc18]]

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-exclude '("[/\\]\\.elpa/" "[/\\]\\.ido\\.last\\'" "[/\\]\\.git/" ".*\\.gz\\'" ".*-autoloads\\.el\\'" "[/\\]archive-contents\\'" "[/\\]\\.loaddefs\\.el\\'" "url/cookies" ".*\\emacs.bmk\\'")))
#+end_src

Save the most recent 100 items (this is manily to keep the list low for [[ido]]):

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-max-saved-items 100))
#+end_src

Customise the place =recentf= persists its list of items:

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-save-file (expand-file-name ".recentf" smf/tmp-local-dir)))
#+end_src

Strip =$HOME= from the front of =recentf= candidate files:

#+begin_src emacs-lisp
  (after-load 'recentf
    (add-to-list 'recentf-filename-handlers 'abbreviate-file-name))
#+end_src

I want easy access to my recent files, so define a function that lets me use [[ido]]
to search over them. Bind this to =C-x C-r= (=C-c C-r= is used in modes like
=org=mode):

#+begin_src emacs-lisp
  (after-load 'recentf
    (after-load 'ido
      (defun smf/recentf-ido-find-file ()
        "Find a recent file using ido."
        (interactive)
        (let ((file (ido-completing-read "Recently: " recentf-list nil t)))
          (when file
            (find-file file))))

      (global-set-key (kbd "C-x C-r") 'smf/recentf-ido-find-file)))
#+end_src

Now enable =recentf=:

#+begin_src emacs-lisp
  (after-load 'recentf
    (recentf-mode 1))
  (require 'recentf)
#+end_src

*** ediff

[[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][ediff]] is a full-featured visual diff and merge tool, built into Emacs.

Make sure that the window split is always side-by-side:

#+begin_src emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

Ignore whitespace changes:

#+begin_src emacs-lisp
  (setq ediff-diff-options "-w")
#+end_src

Only ever use one set of windows in one frame:

#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

Don't keep ediff file instances around:

#+begin_src emacs-lisp
  (setq ediff-keep-variants nil)
#+end_src

Finally, we add customizations for using ediff with mercurial:

#+begin_src emacs-lisp
  (defvar ediff-after-quit-hooks nil
    "* Hooks to run after ediff or emerge is quit.")

  (defadvice ediff-quit (after edit-after-quit-hooks activate)
    (run-hooks 'ediff-after-quit-hooks))

  (setq hg-mergetool-emacsclient-ediff-active nil)

  (defun local-ediff-before-setup-hook ()
    (setq local-ediff-saved-frame-configuration (current-frame-configuration))
    (setq local-ediff-saved-window-configuration (current-window-configuration))
    ;; (local-ediff-frame-maximize)
    (if hg-mergetool-emacsclient-ediff-active
        (raise-frame)))

  (defun local-ediff-quit-hook ()
    (set-frame-configuration local-ediff-saved-frame-configuration)
    (set-window-configuration local-ediff-saved-window-configuration))

  (defun local-ediff-suspend-hook ()
    (set-frame-configuration local-ediff-saved-frame-configuration)
    (set-window-configuration local-ediff-saved-window-configuration))

  (add-hook 'ediff-before-setup-hook 'local-ediff-before-setup-hook)
  (add-hook 'ediff-quit-hook 'local-ediff-quit-hook 'append)
  (add-hook 'ediff-suspend-hook 'local-ediff-suspend-hook 'append)

  ;; Useful for ediff merge from emacsclient.
  (defun hg-mergetool-emacsclient-ediff (local remote base merged)
    (setq hg-mergetool-emacsclient-ediff-active t)
    (if (file-readable-p base)
        (ediff-merge-files-with-ancestor local remote base nil merged)
      (ediff-merge-files local remote nil merged))
    (recursive-edit))

  (defun hg-mergetool-emacsclient-ediff-after-quit-hook ()
    (exit-recursive-edit))

  (add-hook 'ediff-after-quit-hooks 'hg-mergetool-emacsclient-ediff-after-quit-hook 'append)
#+end_src

** Third-party packages

Emacs has a built-in [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging][package manager]].

Rather than using Git submodules or similar my Emacs configuration is set up to
automatically download and install any required packages at load time. This
makes my configuration fully portable.

First set up convenience function (borrowed from [[https://github.com/purcell/emacs.d/blob/aa789c9745b13612c4fea6e638d81d8ebbfecdf8/init-elpa.el#L63-L73][Steve Purcell's emacs config]])
that installs a package if it's not already installed:

#+begin_src emacs-lisp
  (defun require-package (package &optional min-version no-refresh)
    "Install given PACKAGE, optionally requiring MIN-VERSION.
  If NO-REFRESH is non-nil, the available package lists will not be
  re-downloaded in order to locate PACKAGE."
    (if (package-installed-p package min-version)
        t
      (if (or (assoc package package-archive-contents) no-refresh)
          (package-install package)
        (progn
          (package-refresh-contents)
          (require-package package min-version t)))))
#+end_src

*** Configure package manager

**** Custom package install location

The default value for =package-user-dir= is =~/.emacs.d/elpa= - since these are
third-party packages that are dynamically installed I'd prefer them to be in a
[[http://en.wikipedia.org/wiki/Dot-file][hidden directory]].

Packages are also [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][byte compiled]] upon installation, so namespace the install
directory to the version of Emacs I'm using.

Final result should be something like =~/.emacs.d/.elpa/24.3.93.1/=.

#+begin_src emacs-lisp
  (after-load 'package
    (setq package-user-dir
          (smf/join-dirs (smf/join-dirs smf/dotfiles-dir ".elpa") emacs-version)))
#+end_src

**** Customise package repositories to install from

By default Emacs only installs files from [[http://www.gnu.org/software/emacs/manual/html_node/efaq/Packages-that-do-not-come-with-Emacs.html#Packages-that-do-not-come-with-Emacs][ELPA]]. Some of these packages are old
or out of date, and they don't track GitHub repositories.

I want to also add:

- [[https://github.com/milkypostman/melpa#melpa][MELPA]] (tracks GitHub repositories, is much more comprehensive)
- [[https://github.com/milkypostman/melpa#stable-packages][MELPA stable]] (like MELPA, but pinned to specific versions)
- [[https://github.com/jorgenschaefer/elpy#quick-installation][Elpy]] (allows me to install the Elpy Python development environment)

#+begin_src emacs-lisp
  (after-load 'package
    (setq package-archives
          '(("gnu"          . "http://elpa.gnu.org/packages/")
            ("melpa"        . "http://melpa.org/packages/")
            ("melpa-stable" . "http://stable.melpa.org/packages/")
            ("elpy"         . "http://jorgenschaefer.github.io/packages/"))))
#+end_src

**** Initialise package manager

Finally we initialise the package manager:

#+begin_src emacs-lisp
  (package-initialize)
#+end_src

*** diminish

[[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] removes or abbreviates the minor mode indicators that can clutter up
one's modeline.

#+begin_src emacs-lisp
  (require-package 'diminish)
#+end_src

Diminish =subword-mode=, =eldoc-mode=, and =auto-revert-mode=:

#+begin_src emacs-lisp
  (after-load 'diminish
    (after-load 'subword
      (diminish 'subword-mode))
    (after-load 'eldoc
      (diminish 'eldoc-mode))
    (after-load 'autorevert
      (diminish 'auto-revert-mode)))
#+end_src

*** paradox

[[https://github.com/Bruce-Connor/paradox][paradox]] is an advanced package.el frontend with GitHub integration.

#+begin_src emacs-lisp
  (require-package 'paradox)
#+end_src

Force =paradox= into a [[fullframe]]:

#+begin_src emacs-lisp
  (after-load 'fullframe
    (fullframe paradox-list-packages paradox-quit-and-close nil))
#+end_src

Automatically 'star' packages on GitHub after I install them (so I can easily
follow changes to them):

#+begin_src emacs-lisp
  (setq paradox-automatically-star t)
  (setq paradox-github-token (smf/get-keychain-password "paradox-github-token"))
#+end_src

Add launch command:

#+begin_src emacs-lisp
  (smf/add-launcher "p" 'paradox-list-packages)
#+end_src

*** exec-path-from-shell

OS X doesn't use the environment variables available in a shell in a GUI
environment ([[https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/EnvironmentVars.html][more here]]).

Since Emacs runs shell commands regularly it's important that the same =PATH= is
available to my editor as [[http://brew.sh][Homebrew]] etc. set and use.

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] is a package that copies across =PATH= and other variables
to the Emacs environment.

I only want this to be installed and enabled on OS X.

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (require-package 'exec-path-from-shell)
    (setq exec-path-from-shell-variables '("PATH"  "MANPATH" "SHELL"))
    (exec-path-from-shell-initialize))
#+end_src

*** smex

[[https://github.com/nonsequitur/smex][smex]] is an advanced completion mode for =execute-extended-command= (usually
known as =M-x=).

#+begin_src emacs-lisp
  (require-package 'smex)
#+end_src

Replace =execute-extended-command='s keyboard shortcuts:

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap execute-extended-command] 'smex)
#+end_src

Make sure we stop the annoying "click this menubar" advice in the buffer:

#+begin_src emacs-lisp
  (setq-default smex-key-advice-ignore-menu-bar t)
#+end_src

Move =smex='s cache file out of the home directory:

#+begin_src emacs-lisp
  (setq smex-save-file (expand-file-name ".smex-items" smf/tmp-local-dir))
#+end_src

*** fullframe

[[https://github.com/tomterl/fullframe][fullframe]] is a minor mode which allows certain buffers to take over the full
frame using advice.

#+begin_src emacs-lisp
  (require-package 'fullframe)
#+end_src

*** ido-ubiquitous

[[https://github.com/DarwinAwardWinner/ido-ubiquitous][ido-ubiquitous]] mode enables ido in many more places than the default ido setup:

#+begin_src emacs-lisp
  (require-package 'ido-ubiquitous)
  (ido-ubiquitous-mode 1)
#+end_src

*** ido-vertical

[[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertical]] mode renders the ido prompt vertically instead of horizontally. I
find this easier to read.

#+begin_src emacs-lisp
  (require-package 'ido-vertical-mode)
  (ido-vertical-mode) ;; autoloaded
#+end_src

Because it's displayed vertically and I want to save screen real estate, I want
to reduce the maximum number of candidates ido displays:

#+begin_src emacs-lisp
  (setq ido-max-prospects 5)
#+end_src

*** flx-ido

[[https://github.com/lewang/flx][flx-ido]] is an advanced flex-matching algorithm that's significantly faster and
more accurate than the built-in method.

#+begin_src emacs-lisp
  (require-package 'flx-ido)
#+end_src

The =flx-ido= documentation suggests upping the threshold at which GC occurs
within Emacs so that =flx= can cache its candidate lists for longer:

#+begin_src emacs-lisp
  (setq gc-cons-threshold 20000000)
#+end_src

Finally we cause =flx-ido-mode= to take over ido:

#+begin_src emacs-lisp
  (flx-ido-mode 1)
#+end_src

*** ace-jump-mode

[[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] allows one to jump around the buffer to named characters (it's
easier to watch the video on that link than explain).

#+begin_src emacs-lisp
  (require-package 'ace-jump-mode)
#+end_src

Bind it:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c SPC") 'ace-jump-char-mode)
  (global-set-key (kbd "C-<return>") 'ace-jump-line-mode)
  (smf/add-launcher "j" 'ace-jump-char-mode)
  (smf/add-launcher "J" 'ace-jump-line-mode)
#+end_src

*** popwin

[[https://github.com/m2ym/popwin-el][popwin]] is a popup window manager that helps make the behaviour of compilation
buffers, search buffers etc. a bit more sane.

#+begin_src emacs-lisp
  (require-package 'popwin)
#+end_src

As well as the defaults, I want [[ag]], [[flycheck]] and [[http://www.emacswiki.org/emacs/OccurMode][occur]] to 'pop'. I don't want to
auto-select the =Compile-Log= process buffer as it's for information only.

#+begin_src emacs-lisp
  (after-load 'popwin
    (add-to-list 'popwin:special-display-config `"*ag search*")
    (add-to-list 'popwin:special-display-config `"*Flycheck errors*")
    (add-to-list 'popwin:special-display-config `"*Occur*")
    (add-to-list 'popwin:special-display-config `("*Compile-Log*" :noselect t)))
#+end_src

Load [[popwin]] and configure keyboard shortcuts:

#+begin_src emacs-lisp
  (require 'popwin)
  (popwin-mode 1)
  (global-set-key (kbd "C-c P") 'popwin:popup-last-buffer)
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-P") 'popwin:popup-last-buffer))
#+end_src

*** ag

[[https://github.com/Wilfred/ag.el][ag]] is an Emacs frontend to [[https://github.com/ggreer/the_silver_searcher][the ag command]], a grep-like code-searching tool. It's
installed via Homebrew on my Mac.

#+begin_src emacs-lisp
  (require-package 'ag)
#+end_src

Set up some key bindings:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c f") 'ag-project)
  (global-set-key (kbd "C-c a") 'ag)
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-F") 'ag-project)
    (global-set-key (kbd "s-A") 'ag))
  (smf/add-launcher "a" 'ag-project)
  (smf/add-launcher "A" 'ag)
#+end_src

Make sure that we re-use the =ag= buffers - without this my buffer list is full
of buffers named after the project root.

#+begin_src emacs-lisp
  (setq ag-reuse-buffers t)
#+end_src

Highlight search results using =isearch= highlight faces (otherwise it just
copies them from the shell):

#+begin_src emacs-lisp
  (setq ag-highlight-search t)
  (add-hook 'ag-mode-hook
            (lambda ()
              (copy-face 'lazy-highlight 'ag-match-face)))
#+end_src

*** projectile

[[https://github.com/bbatsov/projectile][projectile]] is a minor mode for performing commands over a single 'project' or
grouping of files.

#+begin_src emacs-lisp
  (require-package 'projectile)
  (projectile-global-mode)
#+end_src

I want my keyboard shortcuts to be the same in Projectile as in non-Projectile
buffers, so do some remapping:

#+begin_src emacs-lisp
  (after-load 'projectile
    (define-key projectile-mode-map [remap ag-project] 'projectile-ag))
#+end_src

Since I use =ag=, always use that instead of =grep=:

#+begin_src emacs-lisp
  (after-load 'projectile
    (define-key projectile-mode-map [remap projectile-grep] 'projectile-ag))
#+end_src

Also define a convenience keyboard shortcut to switch between buffers from the same project:

#+begin_src emacs-lisp
  (after-load 'projectile
    (global-set-key (kbd "s-b") 'projectile-switch-to-buffer)
    (global-set-key (kbd "C-x 4 s-b") 'projectile-switch-to-buffer-other-window)
    (smf/add-launcher "s" 'projectile-switch-project))
#+end_src

*** solarized-theme

I used to use the [[http://ethanschoonover.com/solarized][solarized]] dark theme in my editor. Specifically, I use the
[[https://github.com/bbatsov/solarized-emacs]] variant as it has the best support
for the major modes I use, and is the most up to date. Previously I used
[[https://github.com/sellout/emacs-color-theme-solarized][sellout's variant]] as it has much better terminal support, but it hasn't been
updated seriously in years and it fell behind for modern modes.

#+begin_src emacs-lisp
  (require-package 'solarized-theme)
#+end_src

Since it doesn't work well with my terminal theme (also Solarized Dark), I only
want to enable it on graphical displays (see [[Themes]]). I also want to make sure I set the
modeline to be high contrast (reversed out):

#+begin_src emacs-lisp
  (setq solarized-high-contrast-mode-line t)
#+end_src

*** zenburn-theme

I use the [[https://github.com/bbatsov/zenburn-emacs][zenburn-theme]] as my Emacs theme as it has excellent coloring
(see [[Themes]]):

#+begin_src emacs-lisp
  (require-package 'zenburn-theme)
#+end_src

*** base16-theme

The [[https://github.com/neil477/base16-emacs][base16]] themes are very compatible with terminals. I use the [[http://chriskempson.github.io/base16/#default][default]]
theme.

#+begin_src emacs-lisp
  (require-package 'base16-theme)
#+end_src

*** undo-tree

Also diminish [[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree-mode]], a mode which allows one to visualise their
undo/redo history:

#+begin_src emacs-lisp
  (require-package 'undo-tree)
  (after-load 'undo-tree
    (diminish 'undo-tree-mode))
#+end_src

*** smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] is a [[paredit]] like minor-mode for many more things than just Lisp.

=show-smartparens-mode= is a replacement mode for =show-paren-mode=.

#+begin_src emacs-lisp
  (require-package 'smartparens)
  (require 'smartparens-config)
  (show-smartparens-global-mode 1)
#+end_src

*** company

[[https://github.com/company-mode/company-mode][company-mode]] is a modern and modular completion framework (the other one Emacs
people use is [[http://www.emacswiki.org/emacs/AutoComplete][autocomplete]]. I chose =company= because it's well-maintained and
has better code for integrating with).

**** configuration

I don't want =company= to auto-start - it should only pop when I ask for it:

#+begin_src emacs-lisp
  (after-load 'company
    (setq company-idle-delay nil))
#+end_src

I want it to attempt a completion immediately after a =.= character - without
this I need a few characters before it'll show candidates:

#+begin_src emacs-lisp
  (after-load 'company
    (setq company-minimum-prefix-length 0))
#+end_src

Show candidates immediately rather than waiting:

#+begin_src emacs-lisp
  (after-load 'company
    (setq company-echo-delay 0))
#+end_src

Make the lighter shorter:

#+begin_src emacs-lisp
  (after-load 'company
    (after-load 'diminish
      (diminish 'company-mode "com")))
#+end_src

**** enable company mode in programming buffers only

Define a function to enable company-mode and overwrite [[hippie]]'s key binding for
the local buffer only (this means I can use the same key binding for completion
no matter which minor mode I'm using):

#+begin_src emacs-lisp
  (defun smf/enable-company-mode ()
    "Enables company-mode and overloads hippie-expand's binding"
    (company-mode 1)
    (define-key (current-local-map) [remap dabbrev-expand] 'company-complete))
#+end_src

Add this function to any modes derived from =prog-mode=:

#+begin_src emacs-lisp
  (after-load 'company
    (add-hook 'prog-mode-hook 'smf/enable-company-mode))
#+end_src

**** Install and load company

#+begin_src emacs-lisp
  (require-package 'company)
  (require 'company)
#+end_src

*** flycheck

[[https://github.com/flycheck/flycheck][flycheck]] is a modern, more easily customisable version of [[http://www.emacswiki.org/emacs/FlyMake][flymake]]. It's used to
perform on-the-fly syntax checking and linting.

#+begin_src emacs-lisp
  (require-package 'flycheck)
  (after-load 'flycheck
    (setq
     ;; don't show anything in the left fringe
     flycheck-indication-mode nil))
  (require 'flycheck)
#+end_src

*** puppet-mode

[[https://github.com/lunaryorn/puppet-mode][puppet-mode]] is a major mode for editing =.pp= files.

#+begin_src emacs-lisp
  (require-package 'puppet-mode)
#+end_src

*** markdown-mode

[[http://melpa.milkbox.net/#/markdown-mode][markdown-mode]] is a major mode for editing Markdown files.

#+begin_src emacs-lisp
  (require-package 'markdown-mode)
#+end_src

There's no official Markdown file extension, so support all the unofficial ones:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.ft$" . markdown-mode)) ;; FoldingText
#+end_src

*** paredit

[[http://melpa.milkbox.net/#/paredit][paredit]] is a minor mode for editing S-expressions in a balanced way. It's a very
good way to edit Lisp, Clojure etc. files. [[http://www.emacswiki.org/emacs/ParEdit][More on EmacsWiki]].

#+begin_src emacs-lisp
  (require-package 'paredit)
#+end_src

Enable it for Emacs Lisp files:

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
#+end_src

Conditionally enable it in the minibuffer when entering an expression:

#+begin_src emacs-lisp
  (defun smf/conditionally-enable-paredit-mode ()
    (if (eq this-command 'eval-expression)
        (enable-paredit-mode)))
  (add-hook 'minibuffer-setup-hook 'smf/conditionally-enable-paredit-mode)
#+end_src

*** web-mode

[[https://github.com/fxbois/web-mode][web-mode]] is a major mode for editing templates and HTML. It supports a very
broad range of template languages and is highly configurable.

#+begin_src emacs-lisp
  (require-package 'web-mode)
#+end_src

[[http://jinja.pocoo.org/docs/][Jinja]] templates are mostly like [[https://docs.djangoproject.com/en/dev/topics/templates/][Django templates]], so just force them to behave
like that:

#+begin_src emacs-lisp
  (after-load 'web-mode
    (setq web-mode-engines-alist
          '(("\\.jinja\\'" . "django"))))
#+end_src

Enable [[web-mode]] by default for several common file extensions:

#+begin_src emacs-lisp
  (dolist (alist '(("\\.html$'" . web-mode)
                   ("\\.html\\.erb$" . web-mode)
                   ("\\.mustache$" . web-mode)
                   ("\\.jinja$" . web-mode)
                   ("\\.php$" . web-mode)))
    (add-to-list 'auto-mode-alist alist))
#+end_src

*** idomenu

[[http://melpa.milkbox.net/#/idomenu][idomenu]] offers [[ido]] completion over [[http://www.emacswiki.org/emacs/ImenuMode][imenu]] candidates. It allows me to navigate
through classes etc. using completion for methods.

#+begin_src emacs-lisp
  (require-package 'idomenu)
#+end_src

Add it to my launcher:

#+begin_src emacs-lisp
  (smf/add-launcher "i" 'idomenu)
#+end_src

Automatically rescan the current file so =imenu= is up to date:

#+begin_src emacs-lisp
  (setq imenu-auto-rescan t)
#+end_src

*** yaml-mode

Regrettably I need to occasionally edit [[http://www.yaml.org][YAML]].

#+begin_src emacs-lisp
  (require-package 'yaml-mode)
#+end_src

*** Whole line or region

It's very convenient to select the whole line when no region is active.

#+begin_src emacs-lisp
  (require-package 'whole-line-or-region)
  (whole-line-or-region-mode)
#+end_src

*** cycle buffer

I find cycling buffers with =ctrl-tab= very fast and convenient. For that, I use
[[https://github.com/martinp26/cycbuf][cycbuf]], so let's install and load that.

#+begin_src emacs-lisp
  (require-package 'cycbuf)
  (require 'cycbuf)
  (add-hook 'after-init-hook 'cycbuf-init)
#+end_src

I prefer to just cycle without seeing a list, so set the delay to zero (i.e.
never show it).

#+begin_src emacs-lisp
  (setq cycbuf-clear-delay 0)
#+end_src

Modern OSes sort applications by last recently used, so we also copy that behavior.

#+begin_src emacs-lisp
  (setq cycbuf-buffer-sort-function 'cycbuf-sort-by-recency)
#+end_src

Also, I don't want to cycle through Emacs internal buffers, so I filter out
buffers that start and end with an asterisk.

#+begin_src emacs-lisp
  (setq cycbuf-dont-show-regexp
        '("^ "
          "^\\*cycbuf\\*$"
          "^\\*.*\\*"))
#+end_src

Remap the default keybinding to =ctrl-tab= for next buffer and =ctrl-shift-tab=
for previous buffer.

#+begin_src emacs-lisp
  (global-set-key [(control tab)] 'cycbuf-switch-to-next-buffer)
  (global-set-key [(control shift tab)] 'cycbuf-switch-to-previous-buffer)
#+end_src

Finally, unset =org-mode='s =ctrl-tab= binding.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map [(control tab)] nil)))
#+end_src

** Local and custom configuration

*** Local overrides

So I can configure my Emacs per computer/user, I attempted to automatically load
some configuration.

First set up a directory to hold the files:

#+begin_src emacs-lisp
  (setq smf/local-dotfiles-dir (smf/join-dirs smf/dotfiles-dir "local"))
#+end_src

Now try to load a file named after the current user:

#+begin_src emacs-lisp
  (load (concat smf/local-dotfiles-dir user-login-name ".el") t)
#+end_src

and try to load a file named after the local system:

#+begin_src emacs-lisp
  (load (concat smf/local-dotfiles-dir system-name ".el") t)
#+end_src

Finally, try loading a default file:

#+begin_src emacs-lisp
  (load (concat smf/local-dotfiles-dir "local-overrides.el") t)
#+end_src

*** =Customize=-d configuration

Make sure anything saved using =customize= goes into a consistent (and ignored)
place:

#+begin_src emacs-lisp
  (load (setq custom-file (concat smf/dotfiles-dir "custom.el")) t)
#+end_src

(note that this works because =setq= returns the value it's set to)
