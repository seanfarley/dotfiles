#+TITLE: Emacs Configuration for Sean Farley
#+OPTIONS: ^:nil
#+PROPERTY: results silent
#+PROPERTY: eval no-export
#+PROPERTY: header-args :comments link

* Sean Farley's Emacs Configuration

** Preamble

As my editor of choice I run Emacs. One of the benefits of Emacs is
that it'll install basically anywhere.

This configuration is designed to run in shells as well as on
desktops. There are some platform specific optimisations as well.

This excellent configuration was forked from [[https://github.com/bradleywright/emacs.d][Bradley Wright]].

*** What is this?

It's built using [[http://orgmode.org][Org mode]]'s [[http://orgmode.org/manual/Extracting-source-code.html#Extracting-source-code][tangling functionality]].

My entire Emacs configuration is thus written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style,
and is contained entirely in this file.

*** Installing

Just check it out straight to the right directory, and use Make to
install it:

: cd ~/Projects/emacs.d && ./bootstrap

*** Included libraries

The following libraries are included in non-attributable ways, i.e not
via package install or via a Git submodule:

- [[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]] was a very big early influence, and continues to
  be helpful.

*** License and copyright

Copyright 2010 Bradley Wright.
Copyright 2014 Sean Farley.

Files are licensed under the same license as Emacs (GPL) unless
otherwise specified. See the =COPYING= file for more information.

Any external/third party works included in this work are licensed under
their own licenses - refer to the submodules or packages for more
information.

** Conventions

Functions and variables defined exclusively for my use are prefixed with my
initials and a slash =smf/= to namespace them.

** Setup

Emacs looks in [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Loading-Files.html][load-path]] for Emacs lisp files. =require= and other loading
constructs use this when looking for implicit names.

Before anything, let's bump the gc size to something bigger and more modern,

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 200000000)
#+END_SRC

First we define a convenience function =smf/add-to-load-path= that adds the
passed in directory to =load-path=:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-to-load-path (dir)
    "Adds `dir' to load-path"
    (add-to-list 'load-path dir))
#+END_SRC

and a convenience function for making a proper path out of two strings:

#+BEGIN_SRC emacs-lisp
  (defun smf/join-dirs (prefix suffix)
    "Joins `prefix' and `suffix' into a directory"
    (file-name-as-directory (concat prefix suffix)))
#+END_SRC

*** Base load path

Define a base directory =smf/dotfiles-dir= that's relative to the currently
loading file (this file). This means if I deliberately start Emacs with a file
loaded:

#+BEGIN_SRC
$ emacs -q -l ~/src/emacs/init.el
#+END_SRC

then =smf/dotfiles-dir= will be =~/src/emacs=.

#+BEGIN_SRC emacs-lisp
  (defconst smf/dotfiles-dir
    (file-name-directory
     (or (buffer-file-name) load-file-name))
    "Base path for customised Emacs configuration")
#+END_SRC

This variable is important because all other directories I load things from are
relative to it, which means my Emacs config doesn't need to live in
=user-emacs-directory=.

*** Temporary directory

Emacs has many packages which need to store state in files. Generally these are
in =~= or =user-emacs-directory= - since my entire =~/.emacs.d= is versioned,
I'd rather all temporary files were stored in a known place, =smf/tmp-local-dir=.
This directory is created if it doesn't exist.

#+BEGIN_SRC emacs-lisp
  (defvar smf/tmp-local-dir)
  (make-directory
   (setq smf/tmp-local-dir
         (smf/join-dirs smf/dotfiles-dir ".tmp")) t)
#+END_SRC

*** Backups

Emacs automatically [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Backup.html][backs up files]] while you're editing them. The default
configuration isn't great though.

First, set up some directories to keep backups:

#+BEGIN_SRC emacs-lisp
  (defvar smf/tmp-backups-dir)
  (defvar smf/tmp-autosaves-dir)
  (make-directory
   (setq smf/tmp-backups-dir
         (smf/join-dirs smf/tmp-local-dir "backups")) t)
  (make-directory
   (setq smf/tmp-autosaves-dir
         (smf/join-dirs smf/tmp-local-dir "autosaves")) t)
#+END_SRC

Now use those directories for backups and autosave files:

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `((".*" . ,smf/tmp-backups-dir))
        auto-save-file-name-transforms `((".*" ,smf/tmp-autosaves-dir)))
#+END_SRC

Always copy files when backing up to avoid breaking symlinks:

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t)
#+END_SRC

Delete old versions automatically, and keep a limited number around:

#+BEGIN_SRC emacs-lisp
  (setq delete-old-versions t
        kept-new-versions 2
        kept-old-versions 2)
#+END_SRC

Finally, use version numbers in the filenames:

#+BEGIN_SRC emacs-lisp
  (setq version-control t)
#+END_SRC

*** Launcher keymap

This trick I got from [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][a blog post on launcher keymaps]]. I define my launcher
combo as =C-x C-l=, which is normally =downcase-region= - a command I use so
infrequently I didn't even know there was a key binding for it.

#+BEGIN_SRC emacs-lisp
  (defvar smf/launcher-map)
  (define-prefix-command 'smf/launcher-map)
  (define-key ctl-x-map (kbd "C-l") 'smf/launcher-map)
#+END_SRC

rather than remembering that it's =smf/launcher-map=, just make a function:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-launcher (key function)
    "Maps FUNCTION to KEY under the `smf/launcher-map' prefix"
    (define-key smf/launcher-map key function))
#+END_SRC

** package manager

Emacs has a built-in [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging][package manager]].

Rather than using Git submodules or similar my Emacs configuration is set up to
automatically download and install any required packages at load time. This
makes my configuration fully portable.

*** Configure package manager

**** Custom package install location

The default value for =package-user-dir= is =~/.emacs.d/elpa= - since these are
third-party packages that are dynamically installed I'd prefer them to be in a
[[http://en.wikipedia.org/wiki/Dot-file][hidden directory]].

Packages are also [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][byte compiled]] upon installation, so namespace the install
directory to the version of Emacs I'm using.

Final result should be something like =~/.emacs.d/.elpa/24.3.93.1/=.

**** Ensure package list is refereshed

#+BEGIN_SRC emacs-lisp
  ;; Set the initial state to non-refreshed. This can also be set back
  ;; to nil if we want to run a refresh on the next install.
  (defvar smf/refreshed-package-list nil)

  (defun smf/ensure-refreshed ()
    "Ensure the package list has been refreshed this startup."
    (unless smf/refreshed-package-list
      (package-refresh-contents)
      (setq smf/refreshed-package-list t)))

  (advice-add 'package-install
              :before
              (lambda (&rest args)
                (smf/ensure-refreshed)))
#+END_SRC

**** Customise package repositories to install from

By default Emacs only installs files from [[http://www.gnu.org/software/emacs/manual/html_node/efaq/Packages-that-do-not-come-with-Emacs.html#Packages-that-do-not-come-with-Emacs][ELPA]]. Some of these packages are old
or out of date, and they don't track GitHub repositories.

I want to also add:

- [[https://github.com/milkypostman/melpa#melpa][MELPA]] (tracks GitHub repositories, is much more comprehensive)
- [[https://orgmode.org][Org]] (tracks recent releases of org-mode)

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq package-user-dir (concat "~/.emacs.d/.elpa/" emacs-version))

    (setq package-archives
          '(("gnu"          . "http://elpa.gnu.org/packages/")
            ("melpa"        . "http://melpa.org/packages/")
            ("org"          . "http://orgmode.org/elpa/")))

    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)))
  (unless (featurep 'use-package)
    (require 'diminish)
    (require 'bind-key)
    (use-package use-package
      :commands (use-package-autoload-keymap)
      :defer 5))
  (eval-when-compile (require 'use-package))
#+END_SRC

I like seeing the package loading and installing in the message bar, so let's
enable that

#+BEGIN_SRC emacs-lisp
  (setq use-package-verbose t)
#+END_SRC

*** benchmarking

A bit useless while packages are installing but we'll use this for profiling a
regular start-up (i.e. one where we didn't change this config file and nothing
has to install)

#+BEGIN_SRC emacs-lisp
  (use-package benchmark-init
    :ensure t
    :config
    (benchmark-init/activate))
#+END_SRC

*** async mode

Very much needed. smtp and paradox (among others) will take advantage of this
package.

#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t)
#+END_SRC

*** diminish

[[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] removes or abbreviates the minor mode indicators that can clutter up
one's modeline. Since =use-package= utilizes this, we put this right after
installing =use-package=.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :demand t
    :diminish subword-mode
    :diminish eldoc-mode
    :diminish auto-revert-mode
    :diminish hs-minor-mode
    :diminish abbrev-mode
    :diminish overwrite-mode
    :diminish global-whitespace-mode
    :diminish auto-fill-function)
#+END_SRC

** Client/server

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server][client/server]] model for editing. The client is invoked via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Invoking-emacsclient.html][the
=emacsclient= command]]. More information on configuration is available on the
[[http://www.emacswiki.org/emacs/EmacsClient][EmacsWiki EmacsClient page]].

We make sure the server is running, additionally guarded to check if the version
of Emacs we're using supports the server package:

#+BEGIN_SRC emacs-lisp
  (use-package server
    :config
    (setq server-use-tcp t)
    (setq server-window 'pop-to-buffer)   ; open in another window instead of the
                                          ; current one
    (unless (server-running-p)
      (server-start)))
#+END_SRC

** Editing defaults

Emacs comes with a collection of strange defaults. See [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's
=sane-defaults.el= file]] for some commentary.

*** Line widths and wrapping

The default wrap width (known as [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Filling.html][filling]]) for Emacs is 70 characters. Modern
conventions state that 80 characters is the standard:

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 79)
#+END_SRC

I don't type double-space sentences, so make sure that Emacs doesn't look for
double-spaces after periods to fill paragraphs correctly:

#+BEGIN_SRC emacs-lisp
  (setq-default sentence-end-double-space nil)
#+END_SRC

*** Trailing whitespace

Most UNIX tools work best when there's a trailing newline on all files. Enable
that option:

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

Emacs has lots of other options for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Useless-Whitespace.html][managing superfluous whitespace]].

*** Indentation

I don't use tabstops in files, and my default tab width is 4 characters.

It's worth noting that Emacs can override either of those on a per-file/mode
basis, so Makefiles, Ruby etc. will still get the correct indentation rules.

#+BEGIN_SRC emacs-lisp
  (setq-default
   indent-tabs-mode nil
   tab-width 2
   tab-stop-list (number-sequence 2 120 2)
   sh-basic-offset 2
   sh-indentation 2
   c-basic-offset 2
   web-mode-code-indent-offset 2
   web-mode-markup-indent-offset 2
   web-mode-css-indent-offset 2
   web-mode-sql-indent-offset 2)
#+END_SRC

**** Auto-indentation

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Indent-Convenience.html][Electric indent mode]] was added in Emacs 24.1, and it enables automatic indentation when typing a newline. [[http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation][More about electric indent mode on Emacs Redux]].

First we define convenience toggling functions we can use in a hook (or interactively):

#+BEGIN_SRC emacs-lisp
  (defun smf/turn-on-electric-indent-mode ()
    "Turns on electric-indent-mode"
    (interactive)
    (electric-indent-mode 1))

  (defun smf/turn-off-electric-indent-mode ()
    "Turns off electric-indent-mode"
    (interactive)
    (electric-indent-mode -1))
#+END_SRC

then we enable it for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Program-Modes.html][the generic abstract programming mode =prog-mode=,
introduced in Emacs 24.1]] ([[http://emacsredux.com/blog/2013/04/05/prog-mode-the-parent-of-all-programming-modes/][more about =prog-mode= on Emacs Redux]]):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'smf/turn-on-electric-indent-mode)
#+END_SRC

*** Encoding

I want to have [[http://en.wikipedia.org/wiki/UTF-8][UTF-8]] by default. [[http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/][Emacs unfortunately has a few settings that
govern encoding]], so we should set them all at once:

#+BEGIN_SRC emacs-lisp
  ;; Utf-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
  (setenv "LANG" "en_US.ut8") ; ensure subprocesses get the right env variable
#+END_SRC

*** Fix minibuffer behaviour

When changing focus to the minibuffer, stop allowing point to move over the
prompt. Code taken from [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][ergoemacs]].

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'minibuffer-avoid-prompt))
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'point-entered))
#+END_SRC

While we're at it, let's allow recursive minibuffers.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
  (minibuffer-depth-indicate-mode t)
#+END_SRC

Also, let's save the minibuffer history between sessions. It's 2014. We have the
technology.

#+BEGIN_SRC emacs-lisp
  (savehist-mode t)
  (setq history-length 1000)
#+END_SRC

*** Deleting files

Move files to the trash when deleting:

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

*** Compressed files

Transparently open compressed files:

#+BEGIN_SRC emacs-lisp
  (auto-compression-mode t)
#+END_SRC

*** Active region

Got these from [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's =sane-defaults.el=]]. Show the active region,

#+BEGIN_SRC emacs-lisp
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+END_SRC

Remove text in active region if inserting text,

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Pop mark

When popping the mark, continue popping until the cursor actually moves. Also,
if the last command was a copy - skip past all the expand-region cruft.

#+BEGIN_SRC emacs-lisp
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+END_SRC

*** Window mark

If this is true, then =erc='s scrolling is broken.

#+BEGIN_SRC emacs-lisp
  (setq switch-to-buffer-preserve-window-point nil)
#+END_SRC

*** defadvice warnings

As I have been tweaking my Emacs configuration, I noticed that I was getting
warnings like the following in =*Messages*= during Emacs startup:

: ad-handle-definition: `tramp-read-passwd' got redefined

Most of the time, I don't care about these messages, so let's suppress them

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

** Keyboard

*** Modifier keys

- =C-= means =Control= in combination with another key, eg =C-x= means =Ctrl + x=
- =M-= means =Meta= in combination with another key. This is usually =Alt=, or
  =⌘= on OS X (by default). =Esc= also serves as =Meta= if it's not separately
  bound. On OS X I want to use left =⌥= for =Meta=, and leave right =⌥= alone:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq-default ns-alternate-modifier 'meta)
    (setq-default mac-option-modifier 'meta)
    (setq-default ns-right-alternate-modifier nil))
#+END_SRC

- =s-= means [[http://en.wikipedia.org/wiki/Super_key_(keyboard_button)][super key]]. On OS X I want this to be =⌘=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq-default ns-command-modifier 'super)
    (setq-default mac-command-modifier 'super))
#+END_SRC

- =H-= means [[http://en.wikipedia.org/wiki/Hyper_key][hyper key]]. On OS X I want this to be =fn=:

#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq-default ns-function-modifier 'hyper)
    (setq-default mac-function-modifier 'hyper))
#+END_SRC

*** Basic remappings

The below are some remappings I got from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's Effective Emacs]] article.
They're designed to map some slightly difficult but very common mappings to
things that are easier to type.

**** Prefer =backward-kill-word= over Backspace

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item3][Yegge's Item 3]]. This emulates readline =C-w= command to
=backward-kill-word=. The command that used to live there (=kill-region=) is not
needed since the backspace key works just fine in that case.

#+BEGIN_SRC emacs-lisp
  ;; deletes backward until a space is hit
  (defun smf/backward-kill-word ()
    (interactive)
    (if (and transient-mark-mode mark-active)
        (kill-region (point) (mark))
      (progn
        (delete-region (point) (save-excursion (skip-syntax-backward " ") (point)))
        (delete-region (point) (save-excursion (skip-syntax-backward "^ ") (point))))))

  (global-set-key (kbd "C-w") 'smf/backward-kill-word)
#+END_SRC

**** Quick window switching

Usually one must type =C-x o= to switch between windows - make that quicker by
also mapping =M-o=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
  ;; Moving between windows
  (global-set-key (kbd "C-s-<up>") 'windmove-up)
  (global-set-key (kbd "C-s-<down>") 'windmove-down)
  (global-set-key (kbd "C-s-<right>") 'windmove-right)
  (global-set-key (kbd "C-s-<left>") 'windmove-left)
#+END_SRC

**** Buffer management

Add a key combination to revert the current buffer (re-read the contents from
disk):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC

Most of the time I want the buffer to be reverted automatically:

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

**** Increase / decrease font size

I never remember the keybindings for this:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-=") 'text-scale-increase)
  (global-set-key (kbd "s--") 'text-scale-decrease)
  (global-set-key (kbd "s-0") '(lambda () (interactive) (text-scale-adjust 0)))
#+END_SRC

** Interface

*** Remove chrome

To ensure that all scrollbars, toolbars etc. are turned off, we run this as
early as possible.

#+NAME: turn-off-chrome
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))
#+END_SRC

*** Startup buffers

Turn off the startup screen, and always show =*scratch*=.

#+NAME: turn-off-startup
#+BEGIN_SRC emacs-lisp
  ;; inhibit startup screen
  (setq inhibit-startup-screen t
        ;; Show *scratch* on start
        initial-buffer-choice t)
#+END_SRC

*** Font

I use [[https://github.com/tonsky/FiraCode][Fira Code]] as my default coding font:

#+BEGIN_SRC emacs-lisp
  ;; set the font
  (when (window-system)
    (set-frame-font "Fira Code"))
  (if (fboundp 'mac-auto-operator-composition-mode)
      (mac-auto-operator-composition-mode))
#+END_SRC

*** ImageMagick

If available, let's use imagemagick.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))
#+END_SRC

*** Syntax highlighting

Syntax highlighting in Emacs is called [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Font-Lock.html][font locking]]. It's enabled by
=font-lock-mode=. This turned on by default in modern Emacs systems, but it's
worth keeping around:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

Emacs also supports multiple levels of complexity for highlighting. Setting this
value to =t= forces it to pick the maximum available (also the default):

#+BEGIN_SRC emacs-lisp
  (setq font-lock-maximum-decoration t)
#+END_SRC

*** Line and column numbers

Emacs doesn't display line numbers by the code by default. For that you want
[[http://www.emacswiki.org/emacs/LineNumbers#toc1][Linum mode]].

I want to display the current line number in the [[http://www.emacswiki.org/emacs/ModeLine][mode line]], and also the
current column number:

#+BEGIN_SRC emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+END_SRC

*** Tooltips

Emacs convention is to show help and other inline documentation in the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/message.html][message
area]]. Show help there instead of using an OS tooltip:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (tooltip-mode -1))
#+END_SRC

*** Dialogue boxes and windows

Just don't show them. Use native Emacs controls:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq use-dialog-box nil))
#+END_SRC

Make the window title display the full path of the file I'm currently editing:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b")))))
#+END_SRC

Aside: Emacs calls OS windows [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][frames]] and divisions within frames [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][windows]]. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Titles.html][More
information on frame titles]].

*** Cursor

I prefer a box, non-blinking cursor. So, turn off that blinking:

#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (setq-default cursor-type 'box)
    (blink-cursor-mode (- (*) (*) (*))))
#+END_SRC

Depending on the mode, let's [[http://www.emacswiki.org/emacs/ChangingCursorDynamically][change the cursor]].

#+BEGIN_SRC emacs-lisp
  (defvar smf/read-only-color       "gray")
  (defvar smf/read-only-cursor-type 'hbar)
  (defvar smf/overwrite-color       "red")
  (defvar smf/overwrite-cursor-type 'box)
  (defvar smf/normal-color          "gray")
  (defvar smf/normal-cursor-type    'box)

  (defun smf/set-cursor-according-to-mode ()
    "change cursor color and type according to some minor modes."

    (cond
     (buffer-read-only
      (set-cursor-color smf/read-only-color)
      (setq cursor-type smf/read-only-cursor-type))
     (overwrite-mode
      (set-cursor-color smf/overwrite-color)
      (setq cursor-type smf/overwrite-cursor-type))
     (t
      (set-cursor-color smf/normal-color)
      (setq cursor-type smf/normal-cursor-type))))

  (add-hook 'post-command-hook 'smf/set-cursor-according-to-mode)
#+END_SRC

*** Typing

Show the modifier combinations I just typed almost immediately:

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

Don't make me type =yes= or =no= to boolean interface questions:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Code commenting

A drop-in replacement for comment-dwim. If no region is selected and current
line is not blank and we are not at the end of the line, then comment current
line.

#+BEGIN_SRC emacs-lisp
  (defun smf/comment-dwim-line (&optional arg)
    (interactive "*P")
    (comment-normalize-vars)
    (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
        (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (comment-dwim arg)))
  (global-set-key (kbd "M-;") #'smf/comment-dwim-line)
#+END_SRC

Comment or uncomment the region or current line if no active region.

#+BEGIN_SRC emacs-lisp
  (defun smf/comment-or-uncomment-region-or-line ()
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))
  (global-set-key (kbd "s-;") #'smf/comment-or-uncomment-region-or-line)
#+END_SRC

*** Bells

Don't make a sound when [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Beeping.html][ringing a bell]] - flash a visual bell instead:

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Override the =ring-bell-function= to conditionally ring the bell only when it's
not a valid quit case like hitting =esc= or =C-g=. Generally this means the bell
will only ring when there's actually an error raised somehow:

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function
        (lambda ()
          "Only rings the bell if it's not a valid quit case, e.g
  keyboard-quit"
          (unless (memq this-command
                        '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
            (ding))))
#+END_SRC

*** Buffer naming

By default Emacs resolves conflicting buffer names by appending a number to
them. For instance, if I open =~/src/thing/init.el= and
=~/src/other-thing/init.el= they'll be named =init.el= and =init.el<2>=
respectively.

We can use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][Uniquify]] library to name them =thing/init.el= and
=other-thing/init.el=, which is much easier to make sense of.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** OS X specific configuration

Besides the keyboard configuration above, there are some other specific things I
do on OS X. On OS X =system-type= is the symbol =darwin=.

*** Spelling correction

On the mac, the default mouse bindings are problematic since a two-finger click
is =mouse-3= and not =mouse-2=:

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :diminish flyspell-mode
    :commands (flyspell-mode flyspell-prog-mode flyspell-correct-word)
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode)
    :config
    ;; ispell isn't generally available on macos so let's use aspell
    (when (executable-find "aspell")
      (setq ispell-program-name (executable-find "aspell")))

    ;; Sets flyspell correction to use two-finger mouse click
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word))
#+END_SRC

*** dired fixes

OS X's bundled version of =ls= isn't the GNU one, so it doesn't support the
=--dired= flag. Emacs caters for that use case:

#+BEGIN_SRC emacs-lisp
  (setq dired-use-ls-dired nil)
#+END_SRC

*** sRGB display fixes

As of Emacs 24.4, [[http://lists.gnu.org/archive/html/emacs-devel/2013-12/msg00741.html][Emacs natively supports proper sRGB]] values on OS X:

#+BEGIN_SRC emacs-lisp
  (setq-default ns-use-srgb-colorspace t)
#+END_SRC

*** Terminal integration

Using this configuration, Emacs runs best in [[http://iterm2.com][iTerm2]].

On the desktop, Emacs integrates with the OS X clipboard, so =kill= etc. copy to
the clipboard, and =yank= copies from the clipboard.

Obviously this doesn't work in the terminal, so we need to use the
=interprogram-(cut|paste)-function= variables to copy/paste. Most of this code
gotten from [[http://mindlev.wordpress.com/2011/06/13/emacs-in-a-terminal-on-osx/#comment-20][this blog comment]].

#+BEGIN_SRC emacs-lisp
  (when (and (not (display-graphic-p)) (eq system-type 'darwin))
    (defun smf/copy-from-osx ()
      "Copies the current clipboard content using the `pbcopy` command"
      (shell-command-to-string "pbpaste"))

    (defun smf/paste-to-osx (text &optional push)
      "Copies the top of the kill ring stack to the OSX clipboard"
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))

    (setq interprogram-cut-function 'smf/paste-to-osx)
    (setq interprogram-paste-function 'smf/copy-from-osx)
    (setq save-interprogram-paste-before-kill t))
#+END_SRC

Also, allow pasting selection outside of Emacs:

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t)
#+END_SRC

*** Fullscreen support

On Emacs 24.4 and above, Lion-style fullscreen display is supported but I
dislike it. Define a method to toggle fullscreen pre-Lion.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'toggle-frame-fullscreen)
    (defun smf/toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      (set-frame-parameter nil 'fullscreen
                           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

      (global-set-key (kbd "C-s-f") #'smf/toggle-fullscreen))
#+END_SRC

On the macos, use the built-in =ns-use-native-fullscreen= and set to =nil=.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (setq-default ns-use-native-fullscreen nil))
#+END_SRC

Start emacs in fullscreen,

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'toggle-frame-fullscreen)
    (smf/toggle-fullscreen))
#+END_SRC

*** OS X keybindings

There are a lot of native OS X-isms that I would like to keep. Things such =⌘-a=
to select the whole buffer, or =⌘-c= to copy.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-a") 'mark-whole-buffer)
    (global-set-key (kbd "s-v") 'yank)
    (global-set-key (kbd "s-c") 'kill-ring-save)
    (global-set-key (kbd "s-x") 'kill-region)
    (global-set-key (kbd "s-s") 'save-buffer)
    (global-set-key (kbd "s-l") 'goto-line)
    (global-set-key (kbd "s-w") 'delete-window)
    (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
    (global-set-key (kbd "s-k") 'kill-this-buffer)
    (global-set-key (kbd "s-r") 'recompile)
    (global-set-key (kbd "s-}") 'forward-paragraph)
    (global-set-key (kbd "s-{") 'backward-paragraph)
    (global-set-key (kbd "s-g") 'isearch-repeat-forward)
    (global-set-key [(H left)]  'beginning-of-buffer)
    (global-set-key [(H right)] 'end-of-buffer)
    (global-set-key [(H down)]  [?\C-v])
    (global-set-key [(H up)]    [?\M-v]))
#+END_SRC

The =⌘-backspace= deletes text from the current position to the beginning of the
line.

#+BEGIN_SRC emacs-lisp
  (global-set-key [s-backspace] [?\C- ?\C-a backspace])
#+END_SRC

** Loading Themes

Yay, themes!

*** spaceline

Pretty impressed by spacelines + all-the-icons integration.

#+BEGIN_SRC emacs-lisp
  (setq custom-safe-themes t)             ; don't ask about installing themes

  (use-package all-the-icons
    :ensure t
    :if window-system)

  (use-package powerline
    :after all-the-icons
    :ensure t
    :if window-system
    :config (setq-default powerline-default-separator 'nil))

  (use-package spaceline
    :after powerline
    :demand
    :ensure t
    :config (setq-default mode-line-format
                          '("%e" (:eval (spaceline-ml-ati)))))

  (use-package spaceline-custom
    :after spaceline-colors
    :demand
    :load-path "init"
    :init (add-hook 'after-init-hook 'spaceline-update-faces)
    :config (advice-add 'load-theme :after 'spaceline-update-faces))

  (use-package spaceline-colors
    :after spaceline
    :load-path "init"
    :demand)
#+END_SRC

*** themes

Some basic themes that work with =spaceline= and =all-the-icons=.

#+BEGIN_SRC emacs-lisp
  (use-package moe-theme :ensure t)

  ;; deferred for now
  (use-package creamsody-theme :ensure t :defer t)
  (use-package gruvbox-theme :ensure t :defer t)
  (use-package suscolors-theme :ensure t :defer t)
  (use-package atom-one-dark-theme :ensure t :defer t)
  (use-package forest-blue-theme :ensure t :defer t)
  (use-package liso-theme :ensure t :defer t)
  (use-package peacock-theme :ensure t :defer t)
  (use-package solarized-theme :ensure t :defer t)

  (defun smf/remove-mode-line-box (&rest args)
    (set-face-attribute 'mode-line nil :box nil :underline nil)
    (set-face-attribute 'mode-line-inactive nil :box nil :underline nil))

  (when window-system
    (smf/remove-mode-line-box)
    (load-theme 'moe-dark))
#+END_SRC

** Utility functions

*** Get keychain password

Use =auth-source= for all the things!

#+BEGIN_SRC emacs-lisp
  (use-package auth-source
    :defer t
    :config
    ;; define a helper method to search auth-source and get a password; mostly
    ;; needed due to lack of integration of znc and hipchat with auth-source
    (defun smf/auth-source-pass (user server)
      (let* ((found (nth 0 (auth-source-search :user user
                                               :host server
                                               :max 1))))
        (if found
            (let ((secret (plist-get found :secret)))
              (if (functionp secret)
                  (funcall secret)
                secret))))))
#+END_SRC

*** Conditionally kill Emacs

When I'm in an emacsclient, I probably just want the client to die rather than
the entire server. And, when I kill my server, I want Emacs to confirm this with
me:

#+BEGIN_SRC emacs-lisp
  (defun smf/kill-emacs ()
    "If this buffer is a client, just kill it, otherwise confirm
  the quit."
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (if (= (length (frame-list)) 1)
        (save-buffers-kill-terminal))))
#+END_SRC

Enable this, and override the default command Emacs assigns to kill itself:

#+BEGIN_SRC emacs-lisp
  (define-key (current-global-map) [remap save-buffers-kill-terminal] 'smf/kill-emacs)
#+END_SRC

Also, when using an emacsclient that is waiting, I don't want a prompt that asks
if I really want to exit. So, we define our own function and bind it to =⌘-k=.

#+BEGIN_SRC emacs-lisp
  (defun smf/kill-buffer ()
    "Murderface a buffer, don't listen to nobody, son!"
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (kill-this-buffer)))

  (add-hook 'server-switch-hook
            (lambda ()
              (local-set-key (kbd "s-k") 'smf/kill-buffer)))
#+END_SRC

*** narrow-or-widen-dwim

Taken from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][here]], this function defines a handy way to narrow the buffer. We'll
add a launcher for it bound to 'n'.

#+BEGIN_SRC emacs-lisp
  (defun smf/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (global-set-key (kbd "H-n") 'smf/narrow-or-widen-dwim)
#+END_SRC

*** Delete to end of buffer

In emails (and sometimes other places, too) I frequently want to delete the rest
of the buffer. We'll bind this to =C-M-d=

#+BEGIN_SRC emacs-lisp
  (defun smf/delete-to-end-of-buffer (add-to-kill-ring-p)
    "Deletes from point to end of buffer. If prefix argument is
     given, kill the region, adding it to the kill ring."
    (interactive "P")
    (if add-to-kill-ring-p
        (kill-region (point) (point-max))
      (delete-region (point) (point-max))))

  (global-set-key (kbd "C-M-d") 'smf/delete-to-end-of-buffer)
#+END_SRC

** ediff

[[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][ediff]] is a full-featured visual diff and merge tool, built into Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :commands smf/hg-mergetool-emacsclient-ediff
    :config
    ;; finally, we add customizations for using ediff with mercurial
    (defvar smf/hg-mergetool-emacsclient-ediff-active nil)
    (defvar smf/local-ediff-saved-frame-configuration)
    (defvar smf/local-ediff-saved-window-configuration)

    ;; Make sure that the window split is always side-by-side:
    (setq ediff-split-window-function 'split-window-horizontally

          ;; ignore whitespace changes
          ediff-diff-options "-w"

          ;; only ever use one set of windows in one frame
          ediff-window-setup-function 'ediff-setup-windows-plain

          ;; don't keep ediff file instances around
          ediff-keep-variants nil)

    (defvar ediff-after-quit-hooks nil
      "* Hooks to run after ediff or emerge is quit.")

    (defadvice ediff-quit (after edit-after-quit-hooks activate)
      (run-hooks 'ediff-after-quit-hooks))

    (defun smf/local-ediff-before-setup-hook ()
      (setq smf/local-ediff-saved-frame-configuration (current-frame-configuration))
      (setq smf/local-ediff-saved-window-configuration (current-window-configuration))
      (global-auto-revert-mode 0)
      ;; (local-ediff-frame-maximize)
      (if smf/hg-mergetool-emacsclient-ediff-active
          (raise-frame)))

    (defun smf/local-ediff-quit-hook ()
      (set-frame-configuration smf/local-ediff-saved-frame-configuration)
      (set-window-configuration smf/local-ediff-saved-window-configuration))

    (defun smf/local-ediff-suspend-hook ()
      (set-frame-configuration smf/local-ediff-saved-frame-configuration)
      (set-window-configuration smf/local-ediff-saved-window-configuration))

    ;; Useful for ediff merge from emacsclient.
    (defun smf/hg-mergetool-emacsclient-ediff (local remote base merged)
      (setq smf/hg-mergetool-emacsclient-ediff-active t)
      (if (file-readable-p base)
          (ediff-merge-files-with-ancestor local remote base nil merged)
        (ediff-merge-files local remote nil merged))
      (recursive-edit))

    (defun smf/hg-mergetool-emacsclient-ediff-after-quit-hook ()
      (global-auto-revert-mode t)
      (exit-recursive-edit))

    (add-hook 'ediff-after-quit-hooks
    'smf/hg-mergetool-emacsclient-ediff-after-quit-hook 'append))
    (add-hook 'ediff-before-setup-hook 'smf/local-ediff-before-setup-hook)
    (add-hook 'ediff-quit-hook 'smf/local-ediff-quit-hook 'append)
    (add-hook 'ediff-suspend-hook 'smf/local-ediff-suspend-hook 'append)
#+END_SRC

** ERC

*** Setup

[[http://en.wikipedia.org/wiki/Internet_Relay_Chat][IRC]] will [[https://xkcd.com/1782/][always be popular]], so we'll use Emacs IRC.

#+BEGIN_SRC emacs-lisp
  (use-package tls :defer t)
  (use-package erc-join :after erc)
  (use-package erc-menu :after erc)
  (use-package shr
    :commands shr-render-region
    :config
    ;; this changed in emacs 25 ... I still prefer monospaced fonts
    (setq shr-use-fonts nil))

  (use-package erc
    :after (company tls)
    :commands (erc erc-tls)
    :bind (:map erc-mode-map
                ("<escape>" . smf/bury-buffer)
                ("C-'" . smf/mark-read))
    :config
    (setq-default
     erc-prompt ">"
     erc-email-userid "sean.michael.farley@gmail.com"
     erc-autojoin-channels-alist '((".*smf.io.*" "&bitlbee" "#bitbucket"))
     erc-prompt-for-password nil
     erc-prompt-for-nickserv-password nil
     erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                               "324" "329" "332" "333" "353" "477")
     erc-hide-list '("JOIN" "PART" "QUIT")
     erc-quit-reason 'erc-quit-reason-normal
     erc-track-exclude-server-buffer t

     ;; when having a flaky connection erc attempts to reconnect ad infinitum,
     ;; so let's turn that off

     erc-server-auto-reconnect nil

     ;; when people send me a message (called 'query' in IRC speak), I want the
     ;; buffer to pop up and notify me,
     erc-auto-query 'buffer
     erc-query-display 'buffer)

    ;; let's enable some convenient modules
    (add-to-list 'erc-modules 'dcc)

    ;; enable shit
    (erc-spelling-mode 1)

    ;; As a default, only private messages trigger automatic creation of query
    ;; buffers. I want the same behavior when I receive all notices
    (add-hook 'erc-after-connect
              (lambda (server nick)
                (add-hook 'erc-server-NOTICE-hook 'erc-auto-query)))

    (add-hook 'erc-mode-hook 'company-mode)

    (defun smf/mark-read ()
      "Mark buffer as read up to current line by coloring the text gray."
      (interactive)
      (let ((inhibit-read-only t))
        (put-text-property
         (point-min) (line-beginning-position)
         'face       'font-lock-comment-face)))

    (defun smf/bury-buffer ()
      "Bury buffer and maybe close its window."
      (interactive)
      (smf/mark-read)
      (bury-buffer)))
#+END_SRC

*** erc patches from jwiegly

#+BEGIN_SRC emacs-lisp
  (use-package erc-alert
    :after erc
    :load-path "lisp"
    :config
    (my-erc-define-alerts))
#+END_SRC

*** ZNC

I use [[http://wiki.znc.in/ZNC][ZNC]] to always stay connected to IRC channels, so when I close a buffer I
don't want to quit the channel, just detach from my server. Also, we use the
keychain method defined above to get our password.

The =auth-source= could below is borrowed from [[http://doc.rix.si/cce/cce-irc.html][rrix]].

#+BEGIN_SRC emacs-lisp
  (use-package znc
    :after erc
    :ensure t
    :commands znc-all
    :config
    (defun smf/znc-add-server (server port user networks)
      "Add a server to the list of ZNC servers.

  We use SSL unconditionally. Moreover, we don't store the password
  but put nil instead. Also, we tweak the username to contain the
  network name later, this will be separated again."
      (add-to-list 'znc-servers
                   (list server port t
                         (mapcar
                          (function
                           (lambda (slug)
                             (list slug (format "%s/%s" user slug) nil)))
                          networks))))

    (defun smf/znc-erc-ssl-connector (&rest R)
      "Connect to ERC using SSL and retrieve password with `auth-source-search'.

  Moreover, handle multiple networks by sending the password with
  the appropriate network slug that we extract from the nick."
      (let* ((user (nth 0 (split-string (plist-get R :nick) "/")))
             (slug (nth 1 (split-string (plist-get R :nick) "/")))
             (pass (smf/auth-source-pass user (plist-get R :server))))
        (when pass
          (plist-put R :password (format "%s/%s:%s" user slug pass))
          (plist-put R :nick user)
          (apply 'erc-tls R))))

    (setq
     ;; use our new connector instead of the default one
     znc-erc-ssl-connector #'smf/znc-erc-ssl-connector

     znc-detatch-on-kill t
     znc-servers nil)

    (smf/znc-add-server "smf.io" 6697 "smf" '(freenode bitlbee twitch)))
#+END_SRC

*** erc-tweet

Put the actual tweet into the buffer.

#+BEGIN_SRC emacs-lisp
  (use-package erc-tweet
    :after erc
    :ensure t
    :defer t
    :config
    (add-to-list 'erc-modules 'tweet))
#+END_SRC

*** highlight nicknames

#+BEGIN_SRC emacs-lisp
  (use-package erc-hl-nicks
    :after erc
    :ensure t
    :defer t
    :config
    ;; this makes colors look nice with darker themes
    (setq erc-hl-nicks-color-contrast-strategy '(invert contrast)))
#+END_SRC

*** cloud-to-butt

This will never get old.

#+BEGIN_SRC emacs-lisp
  (use-package cloud-to-butt-erc
    :after erc
    :ensure t
    :defer t)
#+END_SRC

*** hipchat

A package I wrote to help connect to hipchat and display things like (awyeah).

#+BEGIN_SRC emacs-lisp
  (use-package erc-hipchatify
    :after erc
    :ensure t
    :defer t
    :config
    (setq erc-hipchatify-token `,(smf/auth-source-pass "smf/token" "hipchat.com")
          erc-hipchatify-email "sfarley@atlassian.com"

          ;; set the channel names (buffer names) for which to replace 'nick'
          ;; with '@nick'
          erc-hipchatify-mention-channels '("smf"
                                            "#bitbucket-social"
                                            "#bitbucket-cloud"
                                            "#bitbucket-support"
                                            "#bitbucket-bugfix"
                                            "#bitbucket-sf"
                                            "#bitbucket-ops"
                                            "#sourcetree"))

    (add-to-list 'erc-modules 'hipchatify)
    (erc-update-modules))
#+END_SRC

*** Switch to buffer or connect to znc

If I haven't connected to my ZNC server, then we connect to it; otherwise, just
switch to the buffer.

#+BEGIN_SRC emacs-lisp
  (defun smf/erc-start-or-switch (channel)
    "Connect to ERC, or switch to given channel"
    (interactive)
    ;; switch to the scratch buffer so cwd isn't in a project
    (with-current-buffer (get-buffer "*scratch*")
      (if (get-buffer "*irc-freenode*") ;; ERC already active?
          (progn
            (set-buffer "*irc-freenode*")
            (if (erc-server-process-alive)
                (switch-to-buffer channel) ;; yes: switch to #channel
              (znc-all)))                  ;; no: start ERC
        (znc-all))))                       ;; no: start ERC

  (defun smf/bitbucket ()
    (interactive)
    (smf/erc-start-or-switch "#bitbucket"))

  (defun smf/mercurial ()
    (interactive)
    (smf/erc-start-or-switch "#mercurial"))
#+END_SRC

*** Query any user

Below adds the ability to launch a new chat with any nick. It amalgamates all
nicks in all channels because that is simple and hasn't been a problem for me
yet. My [[http://www.bitlbee.org][BitlBee]] server appends "|fb" or "|gtalk" for the corresponding chat
method so that takes care of most potential name conflicts.

#+BEGIN_SRC emacs-lisp
  (defun smf/user-keys (erc-channel-users)
    "Convert the ERC-CHANNEL-USERS hash into an equivalent list-based form."
    (let ((alist '()))
      (maphash (lambda (key value)
                 (push (erc-server-user-nickname (car value)) alist))
               erc-channel-users)
      alist))

  (defun smf/buffer-users (buffer)
    "Return users for a given ERC buffer"
    (when (get-buffer buffer)
      (set-buffer buffer)
      (smf/user-keys erc-channel-users)))

  (defvar smf/channels '("&bitlbee" "#mercurial" "#bitbucket" "#rw_grim"))

  (defun smf/erc-chat (nick)
    "Start a query with nick"
    (interactive
     (let ((users))
       (list (completing-read "Nick: "
                              (dolist (c smf/channels users)
                                (setq users
                                      (delete-dups
                                       (append users
                                               (smf/buffer-users c)))))))))

    (let ((i 0)
          (done))
      (while (and (not done)
                  (<= i (length smf/channels)))
        (let ((c (elt smf/channels i)))
          (when (member nick (smf/buffer-users c))
            (setq done t)
            (set-buffer c)
            (erc-cmd-QUERY nick)))
        (setq i (1+ i)))))

  (smf/add-launcher "c" 'smf/erc-chat)
#+END_SRC

** LaTeX

I love [[http://en.wikipedia.org/wiki/LaTeX][LaTex]]. It's the best way to typeset a document.

*** AucTeX

Let's start by installing some LaTeX specific plugins (mostly AucTex-related)
and initialize them. [[http://mactex-wiki.tug.org/wiki/index.php/SyncTeX][SyncTeX]] enables synchronization between source TeX files
and the resulting pdf file.

#+BEGIN_SRC emacs-lisp
  ;; define map to silence byte compiler
  (defvar latex-mode-map)

  (use-package tex
    :ensure auctex
    :mode ("\\.tex\\'" . latex-mode)
    :commands (latex-mode LaTeX-mode plain-tex-mode smf/latexmk-compile)
    :diminish iimage-mode
    :diminish outline-minor-mode
    :diminish reftex-mode
    :diminish abbrev-mode
    :bind (:map latex-mode-map
                ("C-c C-a" . smf/latexmk-compile))
    :config
    (setq-default TeX-auto-save t
                  TeX-parse-self t
                  LaTeX-item-indent 0
                  TeX-clean-confirm nil ; don't ask me to clean
                  TeX-PDF-mode t        ; who uses dvi?
                  outline-minor-mode-prefix (kbd "C-c o")
                  TeX-source-correlate-method 'synctex
                  TeX-source-correlate-start-server t
                  TeX-view-program-selection '((output-pdf "PDF Tools"))
                  TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view)))

    ;; taken from http://www.emacswiki.org/AUCTeX for automatic detection of the
    ;; master file

    (defun smf/guess-TeX-master (filename)
      "Guess the master file for FILENAME from currently open .tex files."
      (let ((candidate nil)
            (filename (file-name-nondirectory filename)))
        (save-excursion
          (dolist (buffer (buffer-list))
            (with-current-buffer buffer
              (let ((name (buffer-name))
                    (file buffer-file-name))
                (if (and file (string-match "\\.tex$" file))
                    (progn
                      (goto-char (point-min))
                      (if (re-search-forward (concat "\\\\input{" filename "}") nil t)
                          (setq candidate file))
                      (if (re-search-forward (concat "\\\\include{" (file-name-sans-extension filename) "}") nil t)
                          (setq candidate file))))))))
        (if candidate
            (message "TeX master document: %s" (file-name-nondirectory candidate)))
        candidate))

    ;; latexmk is a handy way to compile the TeX source the correct number of
    ;; times, so we'll create a convenient binding for that
    (defun smf/latexmk-compile ()
      (interactive)
      (save-buffer)
      (TeX-command "LatexMk" 'TeX-master-file -1))

    (defun smf/latex-mode-hook ()
      (turn-on-auto-fill)
      (abbrev-mode)
      (LaTeX-math-mode)
      (outline-minor-mode)
      (magic-latex-buffer)
      (setq TeX-master (smf/guess-TeX-master (buffer-file-name))))

    ;; add synctex hook
    (add-hook 'LaTeX-mode-hook #'TeX-source-correlate-mode)
    (add-hook 'LaTeX-mode-hook #'smf/latex-mode-hook)
    (add-hook 'LaTeX-mode-hook #'reftex-mode)
    (add-hook 'LaTeX-mode-hook #'turn-on-reftex))

  (use-package auctex-latexmk
    :after auctex
    :ensure t
    :config
    (auctex-latexmk-setup))
#+END_SRC

*** =magic-latex-buffer=

Magical syntax highlighting for LaTeX-mode buffers.

#+BEGIN_SRC emacs-lisp
  (use-package magic-latex-buffer
    :ensure t
    :defer t
    :diminish magic-latex-buffer)
#+END_SRC

*** RefTeX

You know what eles is awesome? [[http://www.gnu.org/software/auctex/reftex.html][RefTeX]].

#+BEGIN_SRC emacs-lisp
  (use-package reftex
    :commands turn-on-reftex
    :init
    (setq reftex-plug-into-AUCTeX t)
    :config
    (setq-default reftex-enable-partial-scans t
                  reftex-save-parse-info t
                  reftex-use-multiple-selection-buffers t
                  reftex-plug-into-AUCTeX t

                  reftex-cite-prompt-optional-args nil
                  reftex-cite-cleanup-optional-args t

                  reftex-section-levels '(("part" . 0)
                                          ("chapter" . 1)
                                          ("section" . 2)
                                          ("subsection" . 3)
                                          ("frametitle" . 4)
                                          ("subsubsection" . 4)
                                          ("paragraph" . 5)
                                          ("subparagraph" . 6)
                                          ("addchap" . -1)
                                          ("addsec" . -2))

                  reftex-plug-into-AUCTeX t
                  reftex-extra-bindings t
                  reftex-bibfile-ignore-list nil
                  reftex-guess-label-type t
                  reftex-revisit-to-follow t
                  reftex-use-fonts t              ; make colorful toc
                  reftex-toc-follow-mode nil      ; don't follow other toc(s)
                  reftex-toc-split-windows-horizontally t
                  reftex-auto-recenter-toc t
                  reftex-enable-partial-scans t
                  reftex-save-parse-info t
                  reftex-use-multiple-selection-buffers t

                  TeX-fold-env-spec-list '(("[comment]" ("comment"))
                                           ("[figure]" ("figure"))
                                           ("[table]" ("table"))
                                           ("[itemize]" ("itemize"))
                                           ("[enumerate]" ("enumerate"))
                                           ("[description]" ("description"))
                                           ("[overpic]" ("overpic"))
                                           ("[tabularx]" ("tabularx"))
                                           ("[code]" ("code"))
                                           ("[shell]" ("shell")))))
#+END_SRC

*** company-math

#+BEGIN_SRC emacs-lisp
  (use-package company-auctex
    :ensure t
    :after auctex
    :config
    (company-auctex-init))
  (use-package company-math
    :ensure t
    :after auctex
    :config
    (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

*** pdf-tools

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :mode (("\\.pdf\\'" . pdf-view-mode))
    :config
    (pdf-tools-install)
    (setq-default pdf-view-display-size 'fit-page)
    (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer))
#+END_SRC

** mail

*** setup

Here are some generic settings for having email in emacs.

#+BEGIN_SRC emacs-lisp
  (setq user-mail-address "sean@farley.io"
        user-full-name  "Sean Farley"

        ;; don't keep message buffers around
        message-kill-buffer-on-exit t

        mm-text-html-renderer 'shr)
#+END_SRC

Some helpful minor modes for composing a message.

#+BEGIN_SRC emacs-lisp
  ;; compose minor modes
  (add-hook 'message-mode-hook #'footnote-mode)
  (add-hook 'message-mode-hook #'turn-on-flyspell)
  (add-hook 'message-mode-hook #'yas-minor-mode)
#+END_SRC

Sign our email upon being sent.

#+BEGIN_SRC emacs-lisp
  ;; sign messages by default
  (add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)
#+END_SRC

*** sendmail async

#+BEGIN_SRC emacs-lisp
  (use-package smtpmail-async
    :after async
    :config
    (setq send-mail-function           'smtpmail-send-it
          message-send-mail-function   'smtpmail-send-it
          smtpmail-smtp-user           "sean@farley.io"
          smtpmail-default-smtp-server "mail.farley.io"
          smtpmail-smtp-server         "mail.farley.io"
          smtpmail-stream-type         'starttls
          smtpmail-smtp-service        587))
#+END_SRC

*** mu4e

After a year hiatus of using =notmuch=, I've come back to =mu4e=. At the end of
the day, notmuch was just not a good fit. I couldn't give up using a mobile
email client and was tired of fighting notmuch's insistence of not moving
messages to maildirs.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :commands smf/mu4e-start-or-switch
    :bind (:map mu4e-main-mode-map
                ("q" . bury-buffer))
    :init
    (smf/add-launcher "e" 'smf/mu4e-start-or-switch)
    :config
    (setq mu4e-user-mail-address-list '("sean.michael.farley@gmail.com"
                                        "sean@seanfarley.org"
                                        "sean@mcs.anl.gov"
                                        "sean@macports.org"
                                        "sean@lsmsa.net"
                                        "sean@farley.io"
                                        "sfarley@atlassian.com"
                                        "me@smf.io"
                                        "sfarley@iit.edu")

          ;; basic maildir locations
          mu4e-maildir "~/.mail"
          mu4e-attachment-dir  "~/Downloads"
          mu4e-refile-folder "/archive"
          mu4e-drafts-folder "/drafts"
          mu4e-trash-folder "/trash"
          mu4e-sent-folder "/sent"

          mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum

          mu4e-maildir-shortcuts '(("/inbox"     . ?i)
                                   ("/archive"   . ?a)
                                   ("/drafts"    . ?d)
                                   ("/phd"       . ?p)
                                   ("/posterity" . ?t)
                                   ("/barryisms" . ?b)
                                   ("/spam"      . ?s))

          mu4e-bookmarks
          '(("flag:unread AND NOT flag:trashed AND NOT maildir:/spam" "All unread" ?u)
            ("flag:unread AND NOT flag:trashed AND NOT maildir:/spam AND NOT mercurial AND NOT macports" "Unread" ?U)
            ("to:sean.michael.farley+self and not maildir:/phd and not maildir:/posterity" "Notes" ?n)
            ("flag:unread macports" "Macports" ?p)
            ("flag:unread mercurial" "Mercurial" ?m))

          ;; an absolute must to sort the inbox with the date ascending.
          mu4e-headers-sort-direction 'ascending

          mu4e-get-mail-command "mbsync -a"

          ;; mbsync needs messages to be renamed
          mu4e-change-filenames-when-moving t

          mu4e-completing-read-function 'ivy-completing-read

          ;; didn't have luck with these
          ;; mu4e-index-cleanup nil  ;; don't do a full cleanup check
          ;; mu4e-index-lazy-check t ;; don't consider up-to-date dirs

          ;; threading and duplicates
          mu4e-headers-show-threads t
          mu4e-headers-skip-duplicates t
          mu4e-headers-include-related t

          ;; always show full email address
          mu4e-view-show-addresses t

          ;; show images inline by default
          mu4e-view-show-images t

          ;; just apply the actions without asking
          mu4e-headers-leave-behavior 'apply)

    (add-to-list 'mu4e-view-actions '("View in browser" . mu4e-action-view-in-browser) t)

    ;; helper function to jump to message composing when pressing tab in the
    ;; subject line
    (defun smf/mu4e-tab-subject ()
      (interactive)
      ;; check if line starts with "Subject: "
      (if (not (string-prefix-p "Subject: " (thing-at-point 'line t)))
          ;; if it does not then call the default tab completion
          (message-tab)
        ;; otherwise move the point forward to the message body
        (forward-line 2)))
    (add-hook 'mu4e-compose-mode-hook
              (lambda () (local-set-key (kbd "TAB") #'smf/mu4e-tab-subject)))

    ;; helper method for custom from address
    (defun smf/mu4e-set-from-address ()
      "Set the From address based on the To address of the original."
      (let ((msg mu4e-compose-parent-message))
        (setq user-mail-address
              (cond
               ((null msg) "sean@farley.io")
               ((mu4e-message-contact-field-matches msg :to "sean@macports.org")
                "sean@macports.org")
               ((mu4e-message-contact-field-matches msg :to "sean@lsmsa.net")
                "sean@lsmsa.net")
               ((mu4e-message-contact-field-matches msg :to "sean@farley.io")
                "sean@farley.io")
               ((mu4e-message-contact-field-matches msg :to "me@smf.io")
                "me@smf.io")
               ((or
                 (mu4e-message-contact-field-matches msg :from "macports")
                 (mu4e-message-contact-field-matches msg :to "macports"))
                "sean@macports.org")
               ((or
                 (mu4e-message-contact-field-matches msg :from "atlassian")
                 (mu4e-message-contact-field-matches msg :to "atlassian"))
                "sfarley@atlassian.com")
               (t "sean@farley.io")))))
    (add-hook 'mu4e-compose-pre-hook 'smf/mu4e-set-from-address)

    ;; function for launching mu4e
    (defun smf/mu4e-start-or-switch ()
      "Start or switch to the mu4e buffer"
      (interactive)
      ;; switch to the scratch buffer so cwd isn't in a project
      (with-current-buffer (get-buffer "*scratch*")
        (mu4e)))

    (setq mu4e-marks (assq-delete-all 'trash mu4e-marks))
    (add-to-list 'mu4e-marks
                 '(trash
                   :char       "d"
                   :prompt     "dtrash"
                   :show-target (lambda (target) "/trash")
                   :action      (lambda (docid msg target)
                                  (mu4e~proc-move docid mu4e-trash-folder "+S-u-N"))))

    (add-to-list 'mu4e-marks
                 '(archive
                   :char       "A"
                   :prompt     "Archive"
                   :show-target (lambda (target) "/archive")
                   :action      (lambda (docid msg target)
                                  (mu4e~proc-move docid mu4e-refile-folder "+S-u-N"))))

    (add-to-list 'mu4e-marks
                 '(spam
                   :char       "S"
                   :prompt     "Spam"
                   :show-target (lambda (target) "/spam")
                   :action      (lambda (docid msg target)
                                  (mu4e~proc-move docid "/spam" "+S-u-N"))))

    (add-to-list 'mu4e-marks
                 '(patch
                   :char       "p"
                   :prompt     "Patch"
                   :ask-target (lambda ()
                                 (ivy-read "Target directory: "
                                           'read-file-name-internal
                                           :matcher #'smf/find-dir-matcher
                                           :history 'smf/recent-patch-dirs))
                   ;; :show-target (lambda (target) "/spam")
                   :action      (lambda (docid msg target)
                                  (shell-command
                                   (format
                                    "hg --cwd %s import --obsolete --partial %s"
                                    target
                                    (mu4e-message-field msg :path))))))

    ;; import a patch from the message view
    (defun smf/mu4e-action-hg-import-patch (msg)
      "Import the hg [patch] message."
      (interactive)
      (ivy-read "Target directory: "
                'read-file-name-internal
                :matcher #'smf/find-dir-matcher
                :history 'smf/recent-patch-dirs
                :action (lambda (d)
                          (shell-command
                           (format
                            "hg --cwd %s import --obsolete --partial %s"
                            d
                            (mu4e-message-field msg :path))))))
    (add-to-list 'mu4e-view-actions '("patch" . smf/mu4e-action-hg-import-patch) t)
    (add-to-list 'mu4e-headers-actions '("patch" . smf/mu4e-action-hg-import-patch) t))
#+END_SRC

*** mu4e-alert

Use terminal-notifier to display unread email.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :after mu4e
    :config
    ;; just display a number to save precious modeline space
    (setq mu4e-alert-modeline-formatter
          (lambda (count) (when (> count 0) (format "%d" count))))

    (mu4e-alert-set-default-style 'notifier)
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
    (mu4e-alert-enable-notifications)
    (mu4e-alert-enable-mode-line-display))
#+END_SRC

** org

**** init

[[http://orgmode.org][org-mode]] is a plain text system for organising information and notes. We'll set
some basic settings and personal tweaks,

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :mode ("\\.org"  . org-mode)
    :bind (;; I'll change the prefix for these function (instead of using
           ;; smf/launcher) since they are so common
           ("C-c l" . org-store-link)
           ("C-c a" . org-agenda)

           :map org-mode-map
           ;; I use meta-arrow keys for navigation so let's stop org from
           ;; using them to indent
           ("<M-S-left>" . nil)
           ("<M-left>" . nil)
           ("<M-right>" . nil)
           ;; since I commonly mistype =C-c C-'= instead of =C-c '=, let's
           ;; add that keybinding,
           ("C-c C-'" . org-edit-special)

           ;; same as python
           ("C-c <" . org-shiftmetaleft)
           ("C-c >" . org-shiftmetaright)

           :map org-src-mode-map
           ("C-c C-'" . org-edit-src-exit)
           ;; I find it infuriating that my muscle memory =⌘+s= in
           ;; =org-src-mode= will save the buffer as a new file. Instead,
           ;; let's make it do the same thing as =C-c '=
           ("s-s" . org-edit-src-exit))
    :config
    (define-key global-map "\C-cc"
      (lambda () (interactive) (org-capture nil "t")))
    (define-key global-map "\C-cj"
      (lambda () (interactive) (org-capture nil "j")))

    ;; set the file for capturing todos
    (defvar smf/org-input "~/Nextcloud/org/inbox.org")

    ;; don't auto-fold my documents:
    (setq-default org-startup-folded nil

                  ;; automatically apply syntax highlighting:
                  org-src-fontify-natively t
                  org-src-tab-acts-natively t
                  org-ellipsis " ⤵"

                  ;; and don't prompt
                  org-confirm-babel-evaluate nil

                  ;; when using imenu, make sure I can follow the outline to the full available
                  ;; depth
                  org-imenu-depth 6

                  ;; also, I like using shift+arrow keys to highlight, so let's set that
                  org-support-shift-select 'always

                  ;; set up root org directory
                  org-directory "~/Nextcloud/org"

                  org-default-notes-file smf/org-input

                  ;; now, set the agenda files,
                  org-agenda-files '("~/Nextcloud/org/bitbucket.org"
                                     "~/Nextcloud/org/phd.org"
                                     "~/Nextcloud/org/hg.org"
                                     "~/Nextcloud/org/personal.org"
                                     "~/Nextcloud/org/macports.org")

                  ;; also search archive files
                  org-agenda-text-search-extra-files '(agenda-archives)

                  ;; please don't close and mess up my windows,
                  org-agenda-window-setup 'current-window
                  org-agenda-restore-windows-after-quit 't

                  ;; more agenda settings
                  org-agenda-persistent-filter t
                  org-agenda-sticky t

                  org-agenda-category-icon-alist
                  `(("bitbucket" ,(list (all-the-icons-faicon "bitbucket")) nil nil :ascent center)
                    ("hg" ,(list (propertize (all-the-icons-faicon "mercury")
                                             'face `(:family ,(all-the-icons-faicon-family) :height 1.3)
                                             )) nil nil :height (16) :width (16) :ascent center)
                    ("macports" ,(list (all-the-icons-faicon "apple")) nil nil :ascent center)
                    ("personal" ,(list (all-the-icons-faicon "user")) nil nil :ascent center)
                    ("phd" ,(list (all-the-icons-faicon "superscript")) nil nil :ascent center))

                  org-agenda-custom-commands
                  '(("c" "Simple agenda view"
                     ((agenda "")
                      (alltodo "" ((org-agenda-skip-function
                                    '(or (org-agenda-skip-subtree-if
                                          'todo '("SOMEDAY" "DONE" "CANCELED"))
                                         (org-agenda-skip-subtree-if
                                          'scheduled 'deadline)))
                                   (org-agenda-overriding-header "ALL normal priority tasks:")))))

                    ("r" "done or canceled items for reporting"
                     ((agenda ""
                              ((org-agenda-files '("~/Nextcloud/org/bitbucket.org"
                                                   "~/Nextcloud/org/bitbucket.org_archive"
                                                   "~/Nextcloud/org/hg.org"
                                                   "~/Nextcloud/org/hg.org_archive"
                                                   "~/Nextcloud/org/macports.org"
                                                   "~/Nextcloud/org/macports.org_archive"
                                                   "~/Nextcloud/org/personal.org"
                                                   "~/Nextcloud/org/personal.org_archive"
                                                   ))
                               (org-agenda-skip-function
                                '(org-agenda-skip-subtree-if 'todo
                                                             '("TODO" "SOMEDAY")))))))

                    ("w" "just work items"
                     ((agenda ""
                              ((org-agenda-files '("~/Nextcloud/org/bitbucket.org"
                                                   "~/Nextcloud/org/hg.org"
                                                   ))
                               ))))

                    ("p" "just personal items"
                     ((agenda ""
                              ((org-agenda-files '("~/Nextcloud/org/hg.org"
                                                   "~/Nextcloud/org/personal.org"
                                                   "~/Nextcloud/org/macports.org"
                                                   ))
                               )))))

                  org-refile-targets
                  '((nil :maxlevel . 2)   ; top level headlines in current buffer
                    (("~/Nextcloud/org/entertainment.org") :maxlevel . 4)
                    (org-agenda-files :maxlevel . 4))

                  ;; add a nice, little template to use along with some shortcuts
                  org-capture-templates
                  '(("t" "Tasks" entry
                     (file+headline smf/org-input "Inbox")
                     "* TODO %?\n  Captured %<%Y-%m-%d %H:%M>\n  %a\n\n  %i" "Basic task data")
                    ("j" "Journal" entry
                     (file+datetree (concat org-directory "/journal.org"))
                     "* %?\n** Situation\n*** What led to the unpleasant emotion?\n** Automatic Thoughts\n*** What thoughts went through your mind?\n** Emotion(s)\n*** What emotion(s) did you feel at the time?\n** Adaptive Response\n*** Modify your automatic thoughts with more realistic responses."))


                  org-todo-keywords '((sequence "TODO(t)" "SOMEDAY(s)" "|" "DONE(d)" "CANCELED(c)"))

                  ;; use a bit better looking colors for todo faces
                  org-todo-keyword-faces '(("TODO" . (:foreground "OrangeRed" :weight bold))
                                           ("SOMEDAY" . (:foreground "GoldenRod" :weight bold))
                                           ("DONE" . (:foreground "LimeGreen" :weight bold))
                                           ("CANCELED" . (:foreground "gray" :weight bold)))

                  ;; misc todo settings
                  org-enforce-todo-dependencies t
                  org-use-fast-todo-selection t
                  org-fast-tag-selection-single-key nil

                  ;; force me to write a note about the task when marking it done
                  org-log-done 'note
                  org-log-into-drawer t
                  org-log-state-notes-insert-after-drawers nil

                  ;; also log when items are rescheduled and refiled
                  org-log-reschedule 'time
                  org-log-refile     'time


                  ;; try to minimize blank lines
                  org-cycle-separator-lines 0
                  org-blank-before-new-entry '((heading)
                                               (plain-list-item . auto))

                  org-return-follows-link t
                  org-confirm-babel-evaluate nil)

    ;; auto save all org files after doing a common action
    (advice-add 'org-agenda-quit      :before #'org-save-all-org-buffers)
    ;; (advice-add 'org-agenda-schedule  :after #'org-save-all-org-buffers)
    (advice-add 'org-agenda-todo      :after #'org-save-all-org-buffers)
    (advice-add 'org-agenda-refile    :after #'org-save-all-org-buffers)
    (advice-add 'org-agenda-clock-in  :after #'org-save-all-org-buffers)
    ;; (advice-add 'org-agenda-clock-out :after #'org-save-all-org-buffers)

    ;; (advice-add 'org-deadline         :after #'org-save-all-org-buffers)
    ;; (advice-add 'org-schedule         :after #'org-save-all-org-buffers)
    ;; (advice-remove 'org-schedule  #'org-save-all-org-buffers)

    (advice-add 'org-todo             :after #'org-save-all-org-buffers)
    (advice-add 'org-refile           :after #'org-save-all-org-buffers)
    ;; (advice-add 'org-clock-in         :after #'org-save-all-org-buffers)
    ;; (advice-add 'org-clock-out        :after #'org-save-all-org-buffers)
    (advice-add 'org-store-log-note   :after #'org-save-all-org-buffers)

    ;; shortcut to launch file for refiling
    (smf/add-launcher "o" (lambda ()
                            (interactive)
                            (find-file smf/org-input)))

    ;; also, let's turn on auto-fill-mode
    (add-hook 'org-mode-hook 'auto-fill-mode))

  ;; needed for colorizing src blocks
  (use-package htmlize
    :after org
    :ensure t)

  (use-package org-bullets
    :after org
    :ensure t
    :defer t
    :config
    (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

**** tangling

Straight-up stolen from [[https://git.alanpearce.uk/alan/dotfiles/src/master/tag-emacs/emacs.d/init.org][alan/dotfiles]].

We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code
blocks from the current file into a source-specific file (in this case a
=.el=-file).

To avoid doing this each time a change is made we can add a function to the
=after-save-hook= ensuring to always tangle and byte-compile the =org=-document
after changes.

#+BEGIN_SRC emacs-lisp
  (defun smf/tangle-if-init ()
    "If the current buffer is 'README.org' the code-blocks are
      tangled, and the tangled file is compiled."

    (when (string-suffix-p "README.org" (buffer-file-name))
      (smf/tangle-init)))

  (defun smf/tangle-init-sync ()
    (interactive)
    (message "Tangling init")
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil)
          (src  (expand-file-name "README.org" user-emacs-directory))
          (dest (expand-file-name "init.el"  user-emacs-directory)))
      (require 'ob-tangle)
      (org-babel-tangle-file src dest)
      (if (byte-compile-file dest)
          (byte-compile-dest-file dest)
        (with-current-buffer byte-compile-log-buffer
          (buffer-string)))))

  (defun smf/tangle-init ()
    "Tangle README.org asynchronously."
    (interactive)
    (message "Tangling init")
    (async-start
     (symbol-function #'smf/tangle-init-sync)
     (lambda (result)
       (message "Init tangling completed: %s" result))))

  (add-hook 'after-save-hook #'smf/tangle-if-init)
#+END_SRC

**** org-protocol

The org-protocol plugin is sweet awesomeness. It allows native apps to send
capture notes to Emacs,

#+BEGIN_SRC emacs-lisp
  (use-package org-protocol
    :commands (org-protocol-capture org-protocol-create)
    :config
    (setq org-protocol-default-template-key "t"))
#+END_SRC

**** misc org

Let's use pomodoro!

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
    :after org
    :commands org-pomodoro
    :bind (:map org-agenda-mode-map
                ("I" . org-pomodoro))
    :config
    (setq-default org-pomodoro-play-sounds nil
                  org-pomodoro-format "%s"
                  org-pomodoro-short-break-format "%s"
                  org-pomodoro-long-break-format "%s"
                  org-pomodoro-keep-killed-pomodoro-time t))
#+END_SRC

While we're at it, let's add mu4e and org-mode integration (included in the
mu4e installation),

#+BEGIN_SRC emacs-lisp
  (use-package org-mu4e
    :after mu4e
    :defer t)
#+END_SRC

To promote using a process journal for logging notes and, more importantly, a
closing note, I needed to write a view for the org-agenda mode that displayed
notes (just like 'l' for log mode).

#+BEGIN_SRC emacs-lisp
  (use-package org-logbook
    :after org
    :demand
    :load-path "init")
#+END_SRC

** prodigy

Manage external services from within Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package prodigy
    :ensure t
    :init
    (smf/add-launcher "d" 'prodigy)
    :commands (prodigy prodigy-start-service prodigy-find-service)
    :config
    ;; start by defining a simple service to run the Mercurial website
    (prodigy-define-service
      :name "Mercurial Website"
      :command "python"
      :args '("hgwebsite.py")
      :cwd "~/projects/hgwebsite"
      :tags '(hg python)
      :port 5000
      :kill-signal 'sigkill
      :kill-process-buffer-on-stop t)

    ;; imapnotify is a node app that fires a program (in our case an elisp
    ;; function) when new mail is received
    (prodigy-define-service
      :name "imapnotify"
      :command "imapnotify"
      :args '("-c" "~/.config/imapnotify.js")
      :tags '(mail node)
      :kill-signal 'sigkill
      :kill-process-buffer-on-stop t)

    ;; bitbucket awwwwww yeah
    (prodigy-define-tag
      :name 'bitbucket
      :cwd "~/projects/bitbucket"
      :path `(,(expand-file-name "~/.virtualenvs/bitbucket/bin")
              ,(expand-file-name "~/projects/go/bin"))
      :kill-signal 'sigkill
      :env `(("BB_EMAIL_PASSWORD"
              ,(smf/auth-source-pass "bbtest@farley.io" "mail.farley.io"))
             ("HGRCPATH" ,(expand-file-name "~/projects/bitbucket-etc/hgrc"))
             ("GIT_CONFIG_NOSYSTEM" "1")
             ("PYTHONUNBUFFERED" "1")
             ("DEBUG" "1")
             ("CELERY_RDB_PORT" "6900")
             ("DJANGO_SETTINGS_MODULE" "bitbucket.settings.dev")
             ("LANG" "en_US.UTF-8")
             ("PATH" ,(concat (expand-file-name "~/projects/go/bin") ":"
                              (expand-file-name "~/.virtualenvs/bitbucket/bin") ":"
                              (getenv "PATH")))
             ("VIRTUAL_ENV" ,(expand-file-name "~/.virtualenvs/bitbucket/"))))

    (prodigy-define-service
      :name "Bitbucket Celery"
      :command "python"
      :args '("manage.py" "celeryd" "-l" "DEBUG")
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Django"
      :command "python"
      :url "http://dev.bitbucket.org:8000"
      :args '("manage.py" "runserver")
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Hgweb"
      :command "gunicorn"
      :args '("--config" "conf/gunicorn-bridgehgweb.conf.py"
              "--bind" "localhost:8001"
              "-w" "1"
              "bridgehgweb:application")
      :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_hgweb"))
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Gitweb"
      :command "gunicorn"
      :args '("--config" "conf/gunicorn-gitweb.conf.py"
              "--bind" "localhost:8002"
              "-w" "1"
              "gitweb:application")
      :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_gitweb"))
      :tags '(bitbucket python))

    (prodigy-define-service
      :name "Bitbucket Conqserver"
      :command "gunicorn"
      :args '("--config" "conf/gunicorn-conqserver.conf.py"
              "--bind" "localhost:9006"
              "-w" "1"
              "conqserver:application")
      :env `(("DJANGO_SETTINGS_MODULE" "bitbucket.settings.django_conqserver"))
      :tags '(bitbucket))

    (prodigy-define-service
      :name "Bitbucket Conker"
      :command "conker"
      :cwd "~/projects/go/src/bitbucket.org/bitbucket/conker"
      :tags '(bitbucket)))
#+END_SRC

** Other modes

Emacs comes with hundreds of major and minor modes to do many, many things.
These are the ones I commonly use and have configured.

*** aHg

#+BEGIN_SRC emacs-lisp
  (use-package ahg
    :commands ahg-status
    ;; :ensure t)
    :load-path "~/projects/ahg")
#+END_SRC

*** alert

A Growl-like alerts notifier for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package alert
    :ensure t
    :config
    (setq alert-default-style (if (file-executable-p alert-notifier-command)
                                  'notifier
                                'osx-notifier)))
#+END_SRC

*** anaconda

=anaconda= is an Emacs package to bring powerful Python editing to Emacs. After
trying other major packages (elpy and jedi) I’ve settled on anaconda-mode and
virtualenvwrapper. It provides a nice mix of tweakability and convenience.

anaconda-mode provides code navigation and docs. Additionally, if company-mode
is enabled, company-anaconda will also be enabled.

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :diminish anaconda-mode
    :commands (anaconda-mode anaconda-eldoc-mode)
    :bind (:map anaconda-mode-map
                ("M-," . nil)  ; By default, anaconda binds =M-,= to finding
                               ; assignments instead of popping the navigation
                               ; stack (which changed in Emacs 25)
                ("M-." . smf/goto-def-or-dumbjump))
    :init
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
    :config
    ;; need to load this for the xref call in our function below
    (use-package xref)

    ;; After a few levels of indirection, =anaconda= has no hope of finding a symbol's
    ;; definition, so it gives up. In this case, invoking
    ;; `anaconda-mode-find-defintions' will do nothing and show a little error message
    ;; in the echo area. When this happens, of course we still want to find what I'm
    ;; looking for so we define this function:
    (defun smf/goto-def-or-dumbjump ()
      "Go to definition of thing at point or do a dumb-jump-go in
      project if that fails"
      (interactive)
      (xref-push-marker-stack)
      (anaconda-mode-call "goto_definitions"
                          'smf/anaconda-mode-find-definitions-callback))

    (defun smf/anaconda-mode-find-definitions-callback (result)
      "Process find definitions RESULT."
      (let ((old-buffer (current-buffer))
            (old-point (point)))
        (if result
            (progn
              (anaconda-mode-definitions-view result)
              (when (and (eq old-point (point))
                         (equal old-buffer (current-buffer)))
                ;; if we didn't actually jump, then fallback to dumb-jump
                (message nil)             ; clear any failed messages since we're
                                          ; about to try a different jump
                (dumb-jump-go)))
          (dumb-jump-go)))))

  (use-package company-anaconda
    :after (anaconda-mode company-mode)
    :ensure t
    :config (add-to-list 'company-backends 'company-anaconda))
#+END_SRC

Showing the indentation by a vertical highlight line is quite handy for quickly
determining the level of indentation,

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indentation
    :after anaconda
    :ensure t
    :diminish highlight-identation-mode
    :config
    (add-hook 'python-mode-hook 'highlight-indentation-mode))
#+END_SRC

*** anzu

[[https://github.com/syohex/emacs-anzu][anzu]] provides enhancements to =isearch= and related tasks, particularly
providing counts and better replacement visualisation.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :diminish anzu-mode
    :bind (([remap query-replace] . anzu-query-replace)
           ([remap query-replace-regexp] . anzu-query-replace-regexp))
    :config
    (when (fboundp 'spaceline-install)
      (setq anzu-cons-mode-line-p nil))
    (global-anzu-mode))
#+END_SRC

*** artbollocks-mode

Prevent usage of passive voice, weasel words and other common grammatical mistakes.

Pro tip: [[http://www.jethrokuan.com/init.html][Jethro Kuan]] has an awesome emacs config.

#+BEGIN_SRC emacs-lisp
  (use-package artbollocks-mode
    :ensure t
    :commands artbollocks-mode
    :init
    (smf/add-launcher "a" 'artbollocks-mode))
#+END_SRC

*** auth-password-store

#+BEGIN_SRC emacs-lisp
  (use-package auth-password-store
    :ensure t
    :config
    (auth-pass-enable))
#+END_SRC

*** avy

I'm choosing =avy= over =ace-jump-mode= for tighter integration with
=ivy-mode=.

[[https://github.com/abo-abo/avy][avy]] allows one to jump around the buffer to named characters (it's easier to
watch the video on that link than explain).

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("H-<return>" . avy-goto-line)
           ("H-'" . avy-goto-word-1)))
#+END_SRC

*** avy-flycheck

Jump to and fix syntax errors using flycheck with avy interface.

#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :after (avy flycheck)
    :ensure t
    :bind ("H-;" . avy-flycheck-goto-error))
#+END_SRC

*** beacon-mode

This package highlights the cursor every time it jumps abruptedly from a place
to another (e.g. when changing windows and so on).

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :defer 2
    :diminish beacon-mode
    :config
    (beacon-mode))
#+END_SRC

*** browse-kill-ring

[[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]] allows one to browse the kill ring history when yanking.

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :ensure t
    :bind (([remap yank-pop] . browse-kill-ring))
    :config
    ;; make browse-kill-ring act like yank-pop by overwriting the previous yank
    (setq browse-kill-ring-replace-yank t))
#+END_SRC


*** c, c++, and objc

Unfortunately, I don't do as much C programming as I would like but [[https://github.com/Sarcasm/irony-mode][irony-mode]]
seems like it would have been really helpful in the past.

#+BEGIN_SRC emacs-lisp
  (use-package irony
    :ensure t
    :defer t
    :config
    (setq-default c-default-style "linux")

    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'objc-mode-hook 'irony-mode)
    (add-hook 'c++-mode-hook 'rtags-start-process-unless-running)
    (add-hook 'c-mode-hook 'rtags-start-process-unless-running)
    (add-hook 'objc-mode-hook 'rtags-start-process-unless-running)

    ;; replace the `completion-at-point' and `complete-symbol' bindings in
    ;; irony-mode's buffers by irony-mode's function
    (defun smf/irony-mode-hook ()
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async))

    (add-hook 'irony-mode-hook 'smf/irony-mode-hook)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

  (use-package company-irony
    :after (company irony)
    :ensure t
    :defer t
    :config
    (add-to-list 'company-backends '(company-irony-c-headers company-irony)))

  (use-package company-irony-c-headers
    :after company-irony
    :ensure t
    :defer t)

  (use-package irony-eldoc
    :after irony
    :ensure t
    :defer t)

  (use-package flycheck-irony
    :after (flycheck irony)
    :ensure t
    :defer t
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup))

  (use-package rtags
    :after irony
    :ensure t
    :defer t)
#+END_SRC

*** color identifier mode

Color Identifiers is a minor mode for Emacs that highlights each source code
identifier uniquely based on its name.

#+BEGIN_SRC emacs-lisp
  (use-package color-identifiers-mode
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-color-identifiers-mode))
#+END_SRC

*** colorize compile buffer

Some compiler output has ansi color, so let's escape that,

#+BEGIN_SRC emacs-lisp
  (use-package ansi-color
    :init
    (setq compilation-scroll-output 't)   ; yes plz

    (defun smf/colorize-compilation ()
      "Colorize from `compilation-filter-start' to `point'."
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region
         compilation-filter-start (point))))

    (add-hook 'compilation-filter-hook 'smf/colorize-compilation))
#+END_SRC

*** counsel-projectile

[[https://github.com/bbatsov/projectile][Projectile]] has native support for using [[https://github.com/abo-abo/swiper][ivy]] as its completion system.
[[https://github.com/ericdanan/counsel-projectile][Counsel-projectile]] provides further ivy integration into projectile by taking
advantage of ivy's mechanism to select from a list of actions and/or apply an
action without leaving the completion session.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-mode))
#+END_SRC

*** counsel-etags

Fast and complete Ctags solution using ivy-completion.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-etags
    :ensure t
    :after counsel)
#+END_SRC

*** company

[[https://github.com/company-mode/company-mode][company-mode]] is a modern and modular completion framework (the other one Emacs
people use is [[http://www.emacswiki.org/emacs/AutoComplete][autocomplete]]. I chose =company= because it's well-maintained and
has better code for integrating with).

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :defer 10
    :diminish company-mode
    :config
    (setq company-tooltip-limit 20
          company-idle-delay .5
          company-echo-delay 0
          company-minimum-prefix-length 1
          company-selection-wrap-around t
          company-show-numbers t
          company-tooltip-align-annotations t)

    ;; remove xcode since that seems to be defunct
    (setq company-backends (delete 'company-xcode company-backends))

    ;; remove eclim
    (setq company-backends (delete 'company-eclim company-backends))

    ;; insert unicode math symbols based on the LaTeX command
    (add-to-list 'company-backends 'company-math-symbols-unicode)

    (global-company-mode))
#+END_SRC

**** Emoji

#+BEGIN_SRC emacs-lisp
  (use-package company-emoji
    :disabled
    :after company
    :ensure t
    :config
    (add-to-list 'company-backends 'company-emoji))

  (use-package emojify
    :ensure t
    :config
    (add-hook 'after-init-hook #'global-emojify-mode))
#+END_SRC

**** Quickhelp

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :after company
    :ensure t
    :config
    (company-quickhelp-mode t))
#+END_SRC

*** crosshairs

Highlights both the line and the column.

#+BEGIN_SRC emacs-lisp
  (use-package crosshairs
    :ensure t
    :bind (("C-|" . column-highlight-mode))
    :init
    (global-hl-line-mode)
    (global-hl-line-highlight))
#+END_SRC

*** crux

A Collection of Ridiculously Useful eXtensions for Emacs. Replaces a lot of
custom functionality I had lying around.

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :ensure t
    :commands crux-reopen-as-root-mode
    :init (crux-reopen-as-root-mode)
    :bind (("C-c o" . crux-open-with)
           ("M-o" . crux-smart-open-line)
           ("C-c n" . crux-cleanup-buffer-or-region)
           ("C-c f" . crux-recentf-ido-find-file)
           ("C-M-z" . crux-indent-defun)
           ("C-c u" . crux-view-url)
           ("C-c e" . crux-eval-and-replace)
           ("C-c w" . crux-swap-windows)
           ("C-c D" . crux-delete-file-and-buffer)
           ("C-c r" . crux-rename-buffer-and-file)
           ("C-c k" . crux-kill-other-buffers)
           ("C-c TAB" . crux-indent-rigidly-and-copy-to-clipboard)
           ("C-c I" . crux-find-user-init-file)
           ("C-c S" . crux-find-shell-init-file)
           ("s-j" . crux-top-join-line)
           ("C-^" . crux-top-join-line)
           ("C-<backspace>" . crux-kill-line-backwards)
           ("s-o" . crux-smart-open-line-above)
           ([remap move-beginning-of-line] . crux-move-beginning-of-line)
           ([(shift return)] . crux-smart-open-line)
           ([(control shift return)] . crux-smart-open-line-above)
           ([remap kill-whole-line] . crux-kill-whole-line)
           ("C-c s" . crux-ispell-word-then-abbrev)))
#+END_SRC

*** discover-my-major

A nicer way to browse keybindings for major modes.

#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :ensure t
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-m" . discover-my-mode)))
#+END_SRC

*** docker

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :ensure t
    :defer t)

  (use-package dockerfile-mode
    :after docker
    :ensure t
    :mode "Dockerfile\\'")
#+END_SRC

*** drag-stuff

Drag stuff around in Emacs with convenient keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package drag-stuff
    :ensure t
    :bind (("M-N" . drag-stuff-down)
           ("M-P" . drag-stuff-up))
    :diminish drag-stuff-mode
    :config
    (drag-stuff-global-mode))
#+END_SRC

*** dtrt-indent

[[https://github.com/jscheid/dtrt-indent][dtrt-indent]] is an Emacs minor mode that guesses the indentation offset
originally used for creating source code files and transparently adjusts the
corresponding settings in Emacs, making it more convenient to edit foreign
files.

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :ensure t
    :defer t
    :diminish dtrt-indent-mode
    :config
    (dtrt-indent-mode))
#+END_SRC

*** dumb jump

Dumb Jump is an Emacs "jump to definition" package with support for multiple
programming languages that favors "just working". This means minimal -- and
ideally zero -- configuration with absolutely no stored indexes (TAGS) or
persistent background processes. Dumb Jump requires at least GNU Emacs 24.4.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :commands dumb-jump-mode
    :init
    (add-hook 'prog-mode-hook #'dumb-jump-mode)
    :config
    (setq-default dumb-jump-selector 'ivy
                  dumb-jump-searcher "rg"))
#+END_SRC

*** editorconfig

[[https://github.com/editorconfig/editorconfig-core-c][EditorConfig]] makes it easy to maintain the correct coding style when switching
between different text editors and between different projects.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :ensure t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode))
#+END_SRC

*** eldoc-mode

[[http://www.emacswiki.org/emacs/ElDoc][eldoc-mode]] is a minor mode that displays context-sensitive help when editing
Emacs lisp (eg information about arity of functions). Enable that for
=emacs-lisp-mode=:

#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :bind (:map emacs-lisp-mode-map
                ("C-c C-b" . eval-buffer))
    :config
    (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook #'eldoc-mode)
    (add-hook 'prog-mode-hook #'eldoc-mode))
#+END_SRC

*** elm

Elm mode for Emacs.

#+BEGIN_SRC emacs-lisp
    (use-package elm-mode
      :ensure t
      :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-elm
    :ensure t
    :after (elm-mode flycheck)
    :config
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook #'flycheck-elm-setup)))

#+END_SRC

*** emacs-git-messenger

#+BEGIN_SRC emacs-lisp
  (use-package git-messenger
    :ensure t
    :commands git-messenger:popup-message
    :init
    (smf/add-launcher "v" 'git-messenger:popup-message)
    :config
    (setq git-messenger:show-detail 't))
#+END_SRC

*** embrace

This package is heavily inspired by the vim plugin surround.vim which I use to
rely on quite heavily.

#+BEGIN_SRC emacs-lisp
  (use-package embrace
    :ensure t
    :bind ("C-," . embrace-commander))
#+END_SRC

*** emmet-mode

Not going to lie. Totally ripped this from [[https://github.com/belak/dotfiles][Kaleb]].

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :after web-mode
    :ensure t
    :config
    (add-hook 'web-mode-hook 'emmet-mode))
#+END_SRC

*** exec-path-from-shell

OS X doesn't use the environment variables available in a shell in a GUI
environment ([[https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/EnvironmentVars.html][more here]]).

Since Emacs runs shell commands regularly it's important that the same =PATH= is
available to my editor as [[https://www.macports.org][MacPorts]] etc. set and use.

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] is a package that copies across =PATH= and other variables
to the Emacs environment.

I only want this to be installed and enabled on OS X.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (eq system-type 'darwin)
    :ensure t
    :config
    (setq exec-path-from-shell-variables '("PATH"  "MANPATH" "SHELL"))
    (exec-path-from-shell-initialize))
#+END_SRC

*** expand-region

Expanding the region by semantic units is quite nice. As always, there’s a mode
for that.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region)
    :config (setq expand-region-fast-keys-enabled nil))
#+END_SRC

*** flycheck

[[https://github.com/flycheck/flycheck][flycheck]] is a modern, more easily customisable version of [[http://www.emacswiki.org/emacs/FlyMake][flymake]]. It's used to
perform on-the-fly syntax checking and linting.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :commands flycheck-mode
    :diminish flycheck-mode
    :bind (("C-c C-n" . flycheck-next-error)
           ("C-c C-p" . flycheck-previous-error))
    :init
    (add-hook 'prog-mode-hook #'flycheck-mode)
    :config
    (defalias 'flycheck-show-error-at-point-soon 'flycheck-show-error-at-point))
#+END_SRC

*** focus

Dim the font color of text in surrounding paragraphs.

#+BEGIN_SRC emacs-lisp
  (use-package focus
    :ensure t
    :commands focus-mode
    :init
    (smf/add-launcher "f" #'focus-mode))
#+END_SRC

*** function-args

GNU Emacs package for showing an inline arguments hint for the C/C++ function
at point.

#+BEGIN_SRC emacs-lisp
  (use-package function-args
    :ensure t
    :defer t
    :config
    (fa-config-default))
#+END_SRC

*** git-gutter

Emacs port of GitGutter which is Sublime Text Plugin.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :diminish git-gutter-mode
    :defer 5
    :config
    (setq git-gutter:handled-backends '(git hg))
    (global-git-gutter-mode))
#+END_SRC

*** gitconfig-mode

A major mode for editing .gitconfig files.

#+BEGIN_SRC emacs-lisp
  (use-package gitconfig-mode
    :ensure t
    :defer t)
#+END_SRC

*** gitignore-mode

A major mode for editing .gitignore files.

#+BEGIN_SRC emacs-lisp
  (use-package gitignore-mode
    :ensure t
    :defer t)
#+END_SRC

*** go-mode

Blergh.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t
    :defer t
    :mode "\\.go\\'"
    :bind (:map go-mode-map
                ("M-." . go-guru-definition)
                ("C-c o" . go-guru-map)))

  (use-package company-go
    :after (go-mode company-mode)
    :ensure t
    :defer t
    :config
    (setq company-go-show-annotation t)
    (add-hook 'go-mode-hook (lambda ()
                              (set (make-local-variable 'company-backends) '(company-go))
                              (company-mode))))

  (use-package go-eldoc
    :ensure t
    :defer
    :init
    (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

*** golden-ratio

Give the working window more screen estate.

#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure t
    :disabled
    :diminish golden-ratio-mode
    :config
    (golden-ratio-mode))
#+END_SRC

*** google-this

A set of emacs functions and bindings to google under point.

#+BEGIN_SRC emacs-lisp
  (use-package google-this
    :ensure t
    :diminish google-this-mode
    :bind-keymap ("C-x g" . google-this-mode-submap))
#+END_SRC

*** goto-chg

Go to last change in current buffer.

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :ensure t
    :bind (("H-." . goto-last-change)))
#+END_SRC

*** groovy-mode

Why.

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :defer t
    :mode "\\.groovy\\'\\|\\.gradle\\'")
#+END_SRC

*** guide-key

[[https://github.com/kai2nenobu/guide-key][guide-key]] shows a popup help window after a pressing defined keys for a short
delay. We'll also enable it for my [[Launcher keymap]] prefix.

#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :ensure t
    :diminish guide-key-mode
    :config
    (setq guide-key/guide-key-sequence '("C-x C-l" "C-c p" "C-x 4"))
    (guide-key-mode))
#+END_SRC

*** habitica

Emacs extension for Habitica, a RPG style habit tracker and todo list.

#+BEGIN_SRC emacs-lisp
  (use-package habitica
    :ensure t
    :commands habitica-tasks
    :config
    (setq habitica-turn-on-highlighting t))
#+END_SRC

*** hg-test-mode

A mode for Mercurial test files

#+BEGIN_SRC emacs-lisp
  (use-package hg-test-mode
    :load-path "lisp")
#+END_SRC

*** hideshowvis

Enables collapsable regions and diminish the mode:

#+BEGIN_SRC emacs-lisp
  (use-package hideshowvis
    :ensure t
    :diminish hs-minor-mode
    :config
    (add-hook 'prog-mode-hook #'hideshowvis-enable))
#+END_SRC

*** highlight-symbol

This package is pretty simple. It adds functionality to highlight the current
word or symbol and navigate to other instances.

#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :ensure t
    :bind (("M-n" . highlight-symbol-next)
           ("M-p" . highlight-symbol-prev))
    :config
    (highlight-symbol-nav-mode))
#+END_SRC

*** hl-mode

I originally used fic-mode, but it appears that hl-todo is a little better and
is updated more frequently. This lets us highlight TODO, FIXME, XXX, and other
similar keywords.

#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :ensure t
    :config
    (setq hl-todo-keyword-faces '(("FIXME" . hl-todo)
                                  ("TODO"  . hl-todo)
                                  ("XXX"   . hl-todo)))
    (hl-todo-set-regexp)
    (global-hl-todo-mode))
#+END_SRC

*** mahgic

An experimental fork of magit for Mercurial. Most of the things here won't work.

**** Keyboard shortcuts

=mahgic-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+BEGIN_SRC emacs-lisp
  (use-package mahgic
    :after magit
    :load-path "~/projects/mahgic/lisp"
    :mode (("hg-editor-.*\\.txt" . hg-commit-mode)
           ("hg-histedit-.*\\.txt" . hg-histedit-mode))
    :init
    (smf/add-launcher "h" 'mahgic-status)
    :config
    ;; mahgic settings
    (setq-default
     ;; open mahgic status in same window as current buffer
     mahgic-status-buffer-switch-function 'switch-to-buffer

     ;; highlight word/letter changes in hunk diffs
     mahgic-diff-refine-hunk t

     ;; pop the process buffer if we're taking a while to complete
     mahgic-process-popup-time 10

     ;; don't prompt me to confirm a canceled histedit
     hg-histedit-confirm-cancel nil

     ;; shelling out to hg is expensive, so until we use something like the command
     ;; server, set a high-timeout for diffs
     mahgic-diff-expansion-threshold 10.0

     ;; definitely need to enable debugging while writing this package
     mahgic-hg-debug t

     ;; use ivy for completing things
     mahgic-completing-read-function 'ivy-completing-read

     ;; experimentally try to use chg, though it doesn't seem to improve the
     ;; speed of shelling out
     mahgic-hg-executable "chg"))
#+END_SRC

*** hungry-delete

=hungry-delete= will delete all whitespace forward or backward.

#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :bind (("H-<backspace>" . hungry-delete-backward)
           ("H-d" . hungry-delete-forward)))
#+END_SRC

*** indium

JavaScript Awesome Development Environment (in Emacs).

#+BEGIN_SRC emacs-lisp
  (use-package indium
    :ensure t
    :commands (indium-connect-to-chrome indium-run-chrome)
    :config
    (setq indium-chrome-executable "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"))
#+END_SRC

*** ivy-rich

More friendly interface for ivy.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :after ivy
    :ensure t
    :config
    (ivy-set-display-transformer 'ivy-switch-buffer 'ivy-rich-switch-buffer-transformer)

    ;; better max lengths for my screen
    (setq ivy-rich-switch-buffer-name-max-length 40
          ivy-rich-switch-buffer-project-max-length 25
          ivy-rich-switch-buffer-mode-max-length 20)

    ;; align the virtual buffers
    (setq ivy-virtual-abbreviate 'full
          ivy-rich-switch-buffer-align-virtual-buffer t)

    ;; abbreviate paths using abbreviate-file-name (e.g. replace “/home/username”
    ;; with “~”)
    (setq ivy-rich-abbreviate-paths t))
#+END_SRC

*** ivy-pass

Ivy interface for pass.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-pass
    :ensure t
    :after ivy
    :commands ivy-pass)
#+END_SRC

*** jump-tree

[[https://github.com/yangwen0228/jump-tree][jump-tree]] is an undo-tree like jumping implementation, so that we can jump back
and forth in a tree way like undo-tree.

#+BEGIN_SRC emacs-lisp
  (use-package jump-tree
    :ensure t
    :disabled
    :config
    (global-jump-tree-mode 1))
#+END_SRC

*** js2-mode

Improved JavaScript editing mode for GNU Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :defer t
    :mode "\\.js\\'"
    :config
    (setq js2-basic-offset 2)
    (when (fboundp 'flycheck-mode)
      (set-face-attribute 'js2-error nil
                          :inherit 'flycheck-error-list-error
                          :underline '(:color foreground-color :style wave))
      (set-face-attribute 'js2-warning nil
                          :inherit 'flycheck-error-list-warning
                          :underline '(:color foreground-color :style wave))))
#+END_SRC

*** json-mode

Sure, why not.

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :defer t
    :mode "\\.json\\'"
    :config
    (setq json-reformat:indent-width 2))
#+END_SRC

*** less-css-mode

=less-css-mode= is a major mode for Emacs which displays strings representing
colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (use-package less-css-mode
    :ensure t
    :commands less-css-mode)
#+END_SRC

*** lua-mode

Dear god.

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :ensure t
    :defer t
    :mode "\\.lua\\'")

  (use-package company-lua
    :after lua
    :ensure t
    :defer t)
#+END_SRC

*** magit

[[https://github.com/magit/magit][Magit]] is an Emacs interface to Git. It's very feature-rich and I find it
intuitive.

**** Keyboard shortcuts

=magit-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :commands (magit-status magit-commit magit-log-mode)
    :mode ("COMMIT_EDITMSG" . git-commit-mode)
    :init
    (smf/add-launcher "g" 'magit-status)
    :config
    ;; magit settings
    (setq-default
     ;; open the =magit-status= buffer in the same window as the current buffer
     magit-status-buffer-switch-function 'switch-to-buffer

     ;; highlight individual word and letter changes when showing hunk diff overlays
     magit-diff-refine-hunk t

     ;; pop the process buffer if we're taking a while to complete
     magit-process-popup-time 10

     ;; ugh, stupid git
     git-commit-summary-max-length 72

     ;; ask me if I want a tracking upstream
     magit-set-upstream-on-push 'askifnotset

     ;; always show the diff in commit window
     magit-commit-arguments '("--verbose")

     ;; use ivy for completing things
     magit-completing-read-function 'ivy-completing-read))
#+END_SRC

*** magithub

Magit interfaces for GitHub.

#+BEGIN_SRC emacs-lisp
  (use-package magithub
    :after magit
    :disabled
    :ensure t
    :config (magithub-feature-autoinject t))
#+END_SRC

*** markdown-mode

[[http://melpa.milkbox.net/#/markdown-mode][markdown-mode]] is a major mode for editing Markdown files.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode ("\\.md\\'" . gfm-mode)
    :config
    (define-key markdown-mode-map (kbd "<M-left>") nil)
    (define-key markdown-mode-map (kbd "<M-right>") nil)

    (setq markdown-command "multimarkdown"))
#+END_SRC

*** move-text

#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :ensure t
    :config
    (move-text-default-bindings))
#+END_SRC

*** multiple cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind ("H-n" . mc/mark-next-like-this)
          ;; ("s-n" . mc/skip-to-next-like-this)
          ("H-p" . mc/mark-previous-like-this)
          ;; ("s-p" . mc/skip-to-previous-like-this)
          ("H-l" . mc/mark-all-symbols-like-this)
          ("C-S-<mouse-1>" . mc/add-cursor-on-click))
#+END_SRC

*** narrow-indirect

[[http://www.emacswiki.org/emacs/narrow-indirect.el][narrow-indirect]] allows one to focus a buffer onto some particular code in
another window, editing it separately from its original context ([[http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/][a better
description of this workflow]]).

#+BEGIN_SRC emacs-lisp
  (use-package narrow-indirect
    :ensure t)
#+END_SRC

*** npm-mode

An Emacs minor mode for working with NPM projects.

#+BEGIN_SRC emacs-lisp
  (use-package npm-mode
    :ensure t
    :commands npm-mode-npm-run)
#+END_SRC

*** org-preview-html-mode

Automatically uses eww to preview the current org-file when saved.

#+BEGIN_SRC emacs-lisp
  (use-package org-preview-html
    :ensure t)
#+END_SRC

*** org-sticky-header

This package displays in the header-line the Org heading for the node that’s at
the top of the window. This way, if the heading for the text at the top of the
window is beyond the top of the window, you don’t forget which heading the text
belongs to.

#+BEGIN_SRC emacs-lisp
  (use-package org-sticky-header
    :ensure t
    :commands org-sticky-header-mode
    :init
    (setq-default org-sticky-header-full-path 'full)
    (add-hook 'org-mode-hook #'org-sticky-header-mode))
#+END_SRC

*** orgit

Support for Org links to Magit buffers.

#+BEGIN_SRC emacs-lisp
  (use-package orgit
    :ensure t
    :after (org magit))
#+END_SRC

*** page breaks

By default, Emacs displays page breaks as =^L=. Lines look much nicer. On
Windows, Emacs incorrectly detects that =U+2500= (Box Drawings Light
Horizontal) can only be displayed with a different font, which is not correct.

Shamelessly stolen from [[https://git.alanpearce.uk/alan/dotfiles/src/master/tag-emacs/emacs.d/init.org][Alan Pearce]].

#+BEGIN_SRC emacs-lisp
  (use-package page-break-lines
    :ensure t
    :defer 5
    :diminish page-break-lines-mode
    :config
    (global-page-break-lines-mode)
    (unless (eq (char-displayable-p ?─) (char-displayable-p ?a))
      (set-fontset-font "fontset-default"
                        (cons page-break-lines-char page-break-lines-char)
                        (face-attribute 'default :family))))
#+END_SRC

*** paradox

[[https://github.com/Bruce-Connor/paradox][paradox]] is an advanced package.el frontend with GitHub integration. Paradox
[[https://github.com/Bruce-Connor/paradox/commit/e341a900609974802ad92d5bb43083fcf83ef432#diff-2d43bf4d9c7b9686d0895974900dfd05R18][supports an asynchronous mode]] which requires the =async= package, so we'll load
this after async.

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :ensure t
    :commands paradox-list-packages
    :init
    (smf/add-launcher "p" 'paradox-list-packages)
    :config
    (setq paradox-automatically-star t
          paradox-execute-asynchronously t))
#+END_SRC

*** password store

A major-mode to manage your [[https://www.passwordstore.org/][password-store]] (pass) keychain. The keychain
entries are displayed in a directory-like structure.

#+BEGIN_SRC emacs-lisp
  (use-package pass
    :ensure t
    :defer 5)
#+END_SRC

*** persistent =*scratch*= buffer

Emacs has a handy, but sometimes decried, feature called the "scratch" buffer.
One problem with =*scratch*= is that its tempting to put significant bits of
code (and other information) into it.

For some reason, this needs to be loaded after anzu else the =*scratch*= buffer
will have whitespace symbols.

#+BEGIN_SRC emacs-lisp
  (use-package persistent-scratch
    :ensure t
    :config
    (persistent-scratch-setup-default)
    (persistent-scratch-autosave-mode))
#+END_SRC

*** pip

This adds some basic features for requirements files, such as highlighting and
auto-completion of names from PyPI.

#+BEGIN_SRC emacs-lisp
  (use-package pip-requirements
    :ensure t
    :mode (("requirements.*\\.txt" . pip-requirements-mode)))
#+END_SRC

*** popwin

[[https://github.com/m2ym/popwin-el][popwin]] is a popup window manager that helps make the behaviour of compilation
buffers, search buffers etc. a bit more sane.

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :ensure t
    :bind (("C-c P" . popwin:popup-last-buffer))
    :config
    ;; also add ag, flycheck, and occur to pop
    (add-to-list 'popwin:special-display-config `"*ag search*")
    (add-to-list 'popwin:special-display-config `"*ripgrep-search*")
    (add-to-list 'popwin:special-display-config `"*Flycheck errors*")
    (add-to-list 'popwin:special-display-config `"*Occur*")

    ;; don't auto-select the compile process buffer as it's only for information
    (add-to-list 'popwin:special-display-config `("*Compile-Log*" :noselect t))

    ;; enable
    (popwin-mode))
#+END_SRC

*** projectile

[[https://github.com/bbatsov/projectile][projectile]] is a minor mode for performing commands over a single 'project' or
grouping of files.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :defer 4
    :init
    (smf/add-launcher "s" 'projectile-switch-project)
    :config
    (setq projectile-completion-system 'ivy
          projectile-enable-caching t)
    (projectile-mode))
#+END_SRC

*** projectile ripgrep

Set up some key bindings:

#+BEGIN_SRC emacs-lisp
  (use-package projectile-ripgrep
    :ensure t
    :bind (([remap projectile-grep] . projectile-ripgrep)))
#+END_SRC

*** puppet-mode

[[https://github.com/lunaryorn/puppet-mode][puppet-mode]] is a major mode for editing =.pp= files.

#+BEGIN_SRC emacs-lisp
  (use-package puppet-mode
    :ensure t
    :disabled)
#+END_SRC

*** python debugger

#+BEGIN_SRC emacs-lisp
  (use-package realgud
    :ensure t
    :disabled t
    :bind (:map realgud:shortkey-mode-map
                ([mouse-3] . realgud:tooltip-eval)
                :map realgud-track-mode-map
                ("C-c C-/" . realgud:ipdb-foo)))
#+END_SRC

*** python-mode

As of 24.2, Emacs ships with a [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs#toc1][robust Python mode]]. However, when navigating
=SnakeCase= words (eg class names), =forward-word= etc don't work correctly.

We can work around that using [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html#Subword-Movement][subword-mode]]:

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode)
    :config
    (defun smf/python-mode ()
      (local-unset-key (kbd "C-c C-p")))  ; unbind run-python

    (add-hook 'python-mode-hook #'subword-mode)
    (add-hook 'python-mode-hook #'smf/python-mode))
#+END_SRC

*** rainbow-blocks

=rainbow-blocks= is an Emacs mode that highlights blocks made of parentheses,
brackets, and braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-blocks
    :ensure t
    :diminish rainbow-blocks-mode
    :commands rainbow-blocks-mode
    :init
    (add-hook 'emacs-lisp-mode-hook #'rainbow-blocks-mode)
    (add-hook 'lisp-interaction-mode-hook #'rainbow-blocks-mode))
#+END_SRC

*** rainbow-delimiters

=rainbow-delimiters= is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their depth.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** rainbow-mode

=rainbow-mode= is a minor mode for Emacs which displays strings representing
colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode
    :init
    (add-hook 'web-mode-hook #'rainbow-mode)
    (add-hook 'html-mode-hook #'rainbow-mode)
    (add-hook 'css-mode-hook #'rainbow-mode)
    (add-hook 'less-mode-hook #'rainbow-mode)
    (add-hook 'scss-mode-hook #'rainbow-mode)
    (add-hook 'sass-mode-hook #'rainbow-mode))
#+END_SRC

*** recentf

[[http://www.emacswiki.org/emacs/RecentFiles][recentf]] stores a list of recently opened files. The list of files contains any
files Emacs has read, not just files I've explicitly opened. Clean that list to
exclude Emacs metafiles, package cruft etc.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    ;; never clean up the list:
    (setq recentf-auto-cleanup 'never
          recentf-max-saved-items 500
          recentf-max-menu-items 15

          ;; customize the place =recentf= persists its list of items:
          recentf-save-file (expand-file-name ".recentf"
                                              smf/tmp-local-dir))

    ;; strip =$HOME= from the front of =recentf= candidate files
    (add-to-list 'recentf-filename-handlers 'abbreviate-file-name)

    (add-to-list 'recentf-exclude "[/\\]\\.elpa/")
    (add-to-list 'recentf-exclude "[/\\]\\.ido\\.last\\'" )
    (add-to-list 'recentf-exclude "[/\\]\\.git/")
    (add-to-list 'recentf-exclude ".*\\.gz\\'")
    (add-to-list 'recentf-exclude ".*-autoloads\\.el\\'")
    (add-to-list 'recentf-exclude "[/\\]archive-contents\\'")
    (add-to-list 'recentf-exclude "[/\\]\\.loaddefs\\.el\\'")
    (add-to-list 'recentf-exclude "url/cookies")
    (add-to-list 'recentf-exclude ".*\\emacs.bmk\\'")
    (add-to-list 'recentf-exclude "README\\.el\\'")
    (add-to-list 'recentf-exclude "/custom\\.el\\'")

    (recentf-mode))
#+END_SRC

*** restclient

Restclient is really nice. It’s like a scratchpad for HTTP api calls. Feels a
bit like using =org-babel=. I wonder if there’s an integration between the two
yet.

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure t
    :mode ("\\.api\\'" . restclient-mode)
    :config
    (defun imenu-restclient-sections ()
      (setq imenu-prev-index-position-function nil)
      (add-to-list 'imenu-generic-expression '("Services" "^## ?\\(.+\\)$" 1) t)
      (add-to-list 'imenu-generic-expression '("Calls" "^# ?\\(.+\\)$" 1) t))
    (add-hook 'restclient-mode-hook #'imenu-restclient-sections))

  (use-package company-restclient
    :ensure t
    :after (company restclient)
    :config
    (add-to-list 'company-backends #'company-restclient t))
#+END_SRC

*** ripgrep

[[https://github.com/nlamirault/ripgrep.el][ripgrep]] is an Emacs frontend to [[https://github.com/BurntSushi/ripgrep][the rg command]], a grep-like code-searching tool. It's
installed via cargo on my Mac.

#+BEGIN_SRC emacs-lisp
  (use-package ripgrep
    :ensure t
    :commands ripgrep-regexp
    :if (executable-find "rg"))
#+END_SRC

*** rjsx-mode

A JSX major mode for Emacs (for writing react code).

#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :ensure t
    :mode ("\\.js\\'" "\\.jsx\\'")
    :commands rjsx-mode
    :config
    ;; turn off warnings about semi-colons since javascript "programmers" are
    ;; assholes
    (setq-default js2-strict-missing-semi-warning nil))
#+END_SRC

*** ruby-mode

As of 24.4, Emacs comes with a much better [[http://www.masteringemacs.org/articles/2013/12/29/whats-new-in-emacs-24-4/][Ruby mode]]. However it doesn't come
with =subword-mode= enabled by default:

#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :interpreter "ruby"
    :config
    (add-hook 'ruby-mode-hook #'subword-mode))
#+END_SRC

*** rust-mode

=rust-mode= makes editing Rust code with Emacs enjoyable.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :mode "\\.rs\\'")

  (use-package racer
    :after rust-mode
    :ensure t
    :config
    (setq racer-rust-src-path "/opt/local/share/rust/src/")
    (add-hook 'rust-mode-hook #'racer-mode)
    (add-hook 'racer-mode-hook #'eldoc-mode))

  (use-package flycheck-rust
    :after (rust-mode flycheck-mode)
    :ensure t
    :config
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC

*** sh-script

I have a few files in my dotfiles repo that are known to be shell files, so
let's add them:

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :mode ((".?aliases" . sh-mode)
           (".?bash_prompt" . sh-mode)
           (".?bashrc" . sh-mode)
           (".?exports" . sh-mode)
           (".?functions" . sh-mode)
           (".?osx" . sh-mode)
           (".?profile" . sh-mode)
           (".?hgrc" . conf-mode)))
#+END_SRC

*** skewer-mode

[[https://github.com/skeeto/skewer-mode][Skewer]]: live web development with Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package skewer-mode
    :ensure t
    :defer t)
#+END_SRC

*** slime-nav

Slime allows very convenient navigation to the symbol at point (using M-.), and
the ability to pop back to previous marks (using =M-,=).

This plugin provides similar navigation for Emacs Lisp, supporting navigation
to the definitions of variables, functions, libraries and faces.

#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :ensure t
    :diminish elisp-slime-nav-mode
    :init
    (add-hook 'emacs-lisp-mode-hook 'elisp-slime-nav-mode)
    (add-hook 'ielm-mode-hook 'elisp-slime-nav-mode))
#+END_SRC

*** smart-tabs-mode

This mode provides code which improves on Emacs’ auto-indenting, so that
whenever you press the <tab> key, the appropriate amount of tabs and spaces is
inserted automatically. You can still use all spaces if you prefer, of course;
the code merely ensures that if you enable tabs (maybe when maintaining legacy
code), the tab size does not matter.

#+BEGIN_SRC emacs-lisp
  (use-package smart-tabs-mode
    :ensure t
    ;; enable smart-tabs-mode automatically for C and Javascript
    :config
    (smart-tabs-insinuate 'c 'javascript))
#+END_SRC

*** smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] is a =paredit= like minor-mode for many more things than just Lisp.

=show-smartparens-mode= is a replacement mode for =show-paren-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :commands smartparens-mode
    :init
    (add-hook 'prog-mode-hook #'smartparens-mode)
    :config
    (use-package smartparens-config))
#+END_SRC

*** smex

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :commands (smex smex-update smex-initialize)
    :config
    (setq smex-auto-update nil)
    (defun smex-update-after-load (_unused)
      (if (boundp 'smex-cache)
          (smex-update)))
    (add-hook 'after-load-functions 'smex-update-after-load)
    :init
    (setq smex-history-length 32
          smex-save-file (expand-file-name ".smex-items"
                                           smf/tmp-local-dir)))
#+END_SRC

*** sphinx-doc-mode

[[https://github.com/naiquevin/sphinx-doc.el][sphinx-doc]] is an emacs minor mode for inserting docstring skeleton for Python
functions and methods.

#+BEGIN_SRC emacs-lisp
  (use-package sphinx-doc
    :after anaconda-mode
    :ensure t
    :diminish sphinx-doc-mode
    :config
    (add-hook 'python-mode-hook 'sphinx-doc-mode))
#+END_SRC

*** stickyfunc-enhance

#+BEGIN_SRC emacs-lisp
  (use-package stickyfunc-enhance
    :disabled
    :ensure t
    :config
    (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
    (semantic-mode))
#+END_SRC

*** swiper / ivy

Ivy - a generic completion frontend for Emacs, Swiper - isearch with an
overview, and more. [[http://oremacs.com/swiper][Oh, man!]]

Note: swiper <- {counsel, ivy}

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind (("C-s" . swiper)
           ("s-f" . swiper)))

  (use-package counsel
    :ensure t
    :commands (counsel-M-x counsel-find-file counsel-describe-function
               counsel-describe-variable counsel-unicode-char)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("<f1> f" . counsel-describe-function)
           ("<f1> v" . counsel-describe-variable)
           ("M-y" . counsel-yank-pop))
    :init
    (smf/add-launcher "U" 'counsel-unicode-char)
    (smf/add-launcher "i" 'counsel-imenu))

  (use-package ivy
    :ensure t
    :demand t
    :diminish ivy-mode
    :bind (("C-c C-r" . ivy-resume)         ; resumes the last Ivy-based completion
           ("C-x b" . ivy-switch-buffer)    ; use this instead of the lackluster
                                            ; `list-buffers'
           ("C-x C-b" . ivy-switch-buffer)  ; common typo
           ("C-x <left>" . ivy-switch-buffer)  ; common typo
           ("C-x C-n" . ivy-switch-buffer)) ; common typo
    :config
    (setq ivy-wrap t                        ; wraps around the buffer
          ivy-initial-inputs-alist nil      ; don't insert '^'
          ivy-use-virtual-buffers t)

    ;; helper method to filter matches in ivy
    (defun smf/find-dir-matcher (regexp candidates)
      "Return REGEXP-matching CANDIDATES that are directories."
      (cl-remove-if-not (lambda (x)
                          (file-directory-p (expand-file-name x
                                                              ivy--directory)))
                        (counsel--find-file-matcher regexp candidates)))

    (ivy-mode))
#+END_SRC

*** tern

=tern= is a js navigation package which extends js-mode.

#+BEGIN_SRC emacs-lisp
  (use-package tern
    :ensure t
    :defer t
    :diminish tern-mode
    :config
    (add-hook 'js-mode-hook (lambda () (tern-mode t))))

  (use-package company-tern
    :after (tern company-mode)
    :ensure t
    :defer t
    :config
    (add-to-list 'company-backends 'company-tern)
    (setq company-tern-property-marker ""))
#+END_SRC

*** tramp mode

=tramp-mode= is a package that provides [[https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top][remote file editing]], eg =find-file
/user@host:file=. This allows one to edit files on other servers using your
local Emacs (rather than the Vim user's equivalent of editing the file on the
server).

First we set the default mode to be =ssh= (it's normally =scp=). There are two
reasons for this choice:

- =ssh= takes a port number as an argument, whereas =scp= doesn't
- It's [[http://www.gnu.org/software/tramp/#Default-Method][apparently faster]] for smaller files

We also want to alter the list of allowed proxies (tramp uses a whitelist for
patterns that it can remotely access) so I can edit remote files as sudo, eg
=find-file /sudo:example.com/etc/something-owned-by-root=.

I got this code from the [[http://www.gnu.org/software/tramp/#Multi_002dhops][Multi-hops section of the tramp manual]].

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer 7
    :config
    (add-to-list 'tramp-default-proxies-alist
                 '(nil "\\`root\\'" "/ssh:%h:"))

    ;; also make sure we can edit local files as sudo - this is normally
    ;; disallowed for security reasons
    (add-to-list 'tramp-default-proxies-alist
                 '((regexp-quote (system-name)) nil nil))

    (setq tramp-default-method "ssh"
          tramp-ssh-controlmaster-options (concat "-o ControlPath=/tmp/tramp.%%r@%%h:%%p "
                                                  "-o ControlMaster=auto "
                                                  "-o ControlPersist=no")))
#+END_SRC

More on the last two incantations at [[http://emacs-fu.blogspot.co.uk/2009/10/editing-files-owned-by-root.html][emacs-fu's guide to editing files owned by root]].

*** twitter

=Twittering-mode=: a Twitter client for Emacs

#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :ensure t
    :defer t
    :commands twit
    :init
    (smf/add-launcher "t" 'twit)
    :config
    (setq twittering-icon-mode t)
    (setq twittering-use-icon-storage t))
#+END_SRC

*** undo-tree

[[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree-mode]], a mode which allows one to visualise their undo/redo history:

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :bind (("C-x u" . undo-tree-visualize)
           ("s-z" . undo-tree-undo)
           ("s-Z" . undo-tree-redo))
    :config
    (global-undo-tree-mode))
#+END_SRC

*** unfill

Functions providing the inverse of Emacs' fill-paragraph and fill-region.

#+BEGIN_SRC emacs-lisp
  (use-package unfill
    :ensure t
    :bind (("M-Q" . unfill-paragraph)))
#+END_SRC

*** volatile highlights

Minor mode for visual feedback on some operations in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :ensure t
    :defer 10
    :diminish volatile-highlights-mode
    :config
    (volatile-highlights-mode))
#+END_SRC

*** web-mode

[[https://github.com/fxbois/web-mode][web-mode]] is a major mode for editing templates and HTML. It supports a very
broad range of template languages and is highly configurable.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    "\\.erb\\'"
    "\\.html\\'"
    "\\.jinja\\'"
    "\\.mustache\\'"
    :config
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2))
#+END_SRC

*** whitespace-mode

I like whitespace-mode for programming and text modes (including org),

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :commands whitespace-mode
    :init
    (add-hook 'text-mode-hook #'whitespace-mode)
    (add-hook 'prog-mode-hook #'whitespace-mode)
    (add-hook 'org-mode-hook #'whitespace-mode)
    :config
    ;; most of the time we only want to see tabs and trailing spaces
    (setq whitespace-style '(trailing face tabs tab-mark lines-tail))
    (setq whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [182 10])
                                        (tab-mark 9 [9655 9] [92 9]))))
#+END_SRC

*** whole line or region

It's very convenient to select the whole line when no region is active.

#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :ensure t
    :diminish whole-line-or-region-mode
    :config
    (whole-line-or-region-global-mode))
#+END_SRC

*** writeroom

Writeroom-mode: distraction-free writing for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :ensure t
    :commands (writeroom-mode)
    :config
    (setq writeroom-restore-window-config t
          writeroom-width 100)

    ;; turn off chat when entering writeroom
    (advice-add 'writeroom--enable :before #'smf/disable-chat)
    (advice-add 'writeroom--disable :before #'smf/enable-chat)

    ;; turn off notifications when entering writeroom
    (advice-add 'writeroom--enable :before #'smf/disable-notifications)
    (advice-add 'writeroom--disable :before #'smf/enable-notificaations))
#+END_SRC

*** yaml-mode

Regrettably I need to occasionally edit [[http://www.yaml.org][YAML]].

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode "\\.yml\\'")
#+END_SRC

*** yasnippet

YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates. Bundled language templates
include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The
snippet syntax is inspired from [[http://manual.macromates.com/en/snippets][TextMate's]] syntax.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :commands (yas-global-mode yas-minor-mode)
    :diminish yas-minor-mode
    :init
    (add-hook 'prog-mode-hook #'yas-minor-mode)
    :config
    (setq yas/root-directory (smf/join-dirs smf/dotfiles-dir "snippets"))
    (yas-reload-all))
#+END_SRC

*** ztree

ztree-dir is a simple text-mode directory tree for Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :ensure t
    :commands (ztree-dir ztree-diff)
    :config
    (setq ztree-dir-move-focus t))
#+END_SRC

** Do Not Disturb

Sometimes chats and emails are too distracting. Here we define methods to
disable chat and email,

#+BEGIN_SRC emacs-lisp
  (defun smf/disable-chat ()
    "Disable znc/erc chat."
    (interactive)
    (if (get-buffer "*irc-freenode*") ;; ERC already active?
        (znc-all t))
    (define-key smf/launcher-map "b" nil)
    (define-key smf/launcher-map "m" nil)
    (message "Disabled ERC/ZNC"))

  (defun smf/enable-chat ()
    "Enable znc/erc chat."
    (interactive)
    (define-key smf/launcher-map "b" 'smf/bitbucket)
    (define-key smf/launcher-map "m" 'smf/mercurial)
    (message "Enabled ERC/ZNC"))

  (defun smf/disable-email ()
    "Disable mail fetching."
    (interactive)
    ;; (if (get-buffer " *mu4e-main*") ;; mu4e already active?
    ;;     (prodigy-stop-service (prodigy-find-service "imapnotify")))
    (define-key smf/launcher-map "e" nil)
    (message "Disabled email"))

  (defun smf/enable-email ()
    "Enable mail fetching."
    (interactive)
    (smf/add-launcher "e" 'smf/mu4e-start-or-switch)
    (message "Enabled email"))

  (defun smf/dnd-notification-center (&optional disable)
    "Toggle the Do Not Disturb button in MacOS Notification Center.

    If DISABLE is non-nil then this disables Do Not Disturb (thereby
    re-enabling notifications)"
    (interactive "P")
    (let ((gstr (if disable "true" "false"))
          (plcmd "plutil -convert xml1 -o - ~/Library/Preferences/ByHost/com.apple.notificationcenterui.*.plist")
          (oscmd "
    osascript -e 'tell application \"System Events\" to tell process \"SystemUIServer\"
      key down option
      click menu bar item 1 of menu bar 1
      key up option
    end tell'"))
      (start-process-shell-command
       "do-not-disturb"
       nil
       (concat "/bin/bash -c "
               (shell-quote-argument
                (format "if [[ $(%s | grep %s) ]]; then
    %s
    fi" plcmd gstr oscmd))))))

  (defun smf/disable-notifications ()
    "Disable desktop notifications."
    (interactive)
    (smf/dnd-notification-center))

  (defun smf/enable-notifications ()
    "Enables desktop notifications."
    (interactive)
    (smf/dnd-notification-center t))

  (defun smf/do-not-disturb ()
    "Disable chat, email, and desktop notifications."
    (interactive)
    (smf/disable-chat)
    (smf/disable-email)
    (smf/disable-notifications))

  (defun smf/socialize ()
    "Enable chat, email, and desktop notifications."
    (interactive)
    (smf/enable-notifications)
    (smf/enable-email)
    (smf/enable-chat))

  ;; by default enable chat and email
  (smf/enable-chat)
  (smf/enable-email)
#+END_SRC

** Local and custom configuration

*** Local overrides

So I can configure my Emacs per computer/user, I attempted to automatically load
some configuration.

First set up a directory to hold the files:

#+BEGIN_SRC emacs-lisp
  (defvar smf/local-dotfiles-dir (smf/join-dirs smf/dotfiles-dir "local"))
#+END_SRC

Now try to load a file named after the current user:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir user-login-name ".el") t)
#+END_SRC

and try to load a file named after the local system:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir (system-name) ".el") t)
#+END_SRC

Finally, try loading a default file:

#+BEGIN_SRC emacs-lisp
  (load (concat smf/local-dotfiles-dir "local-overrides.el") t)
#+END_SRC

*** =Customize=-d configuration

Make sure anything saved using =customize= goes into a consistent (and ignored)
place:

#+BEGIN_SRC emacs-lisp
  (load (setq custom-file (concat smf/dotfiles-dir "custom.el")) t)
#+END_SRC

(note that this works because =setq= returns the value it's set to)
