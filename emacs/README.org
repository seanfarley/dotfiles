* Sean Farley's Emacs Configuration

** Preamble

As my editor of choice I run Emacs. One of the benefits of Emacs is
that it'll install basically anywhere.

This configuration is designed to run in shells as well as on
desktops. There are some platform specific optimisations as well.

This excellent configuration was forked from [[https://github.com/bradleywright/emacs.d][Bradley Wright]].

*** What is this?

It's built using [[http://orgmode.org][Org mode]]'s [[http://orgmode.org/manual/Extracting-source-code.html#Extracting-source-code][tangling functionality]].

My entire Emacs configuration is thus written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style,
and is contained entirely in this file.

*** Installing

Just check it out straight to the right directory, and use Make to
install it:

: cd ~/Projects/emacs.d && make

*** Platform specific configuration

**** OS X desktop (Emacs.app)

- Left =option= key is remapped to =M-=
- We use the [[https://github.com/bbatsov/solarized-emacs][Solarized Dark]] theme
- Font is [[https://github.com/Lokaltog/powerline-fonts/tree/master/SourceCodePro][Source (Sauce) Code Pro]]

**** OS X CLI in iTerm2

- When the [[https://github.com/altercation/solarized/blob/master/iterm2-colors-solarized/Solarized%20Dark.itermcolors][Solarized Dark iTerm2 theme]] is installed, we use the
  =solarized-dark= color theme
- Cut/paste are made to write/read from the clipboard (via =pbcopy=
  and =pbpaste=)
- Mouse highlighting works via xTerm capabilities

***** Required iTerm 2 Configuration

     - Re-map left =option= key to =+Esc=
     - Untick =Smart cursor color=

*** Included libraries

The following libraries are included in non-attributable ways, i.e not
via package install or via a Git submodule:

- [[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]] was a very big early influence, and continues to
  be helpful.

*** License and copyright

Copyright 2010 Bradley Wright.
Copyright 2014 Sean Farley.

Files are licensed under the same license as Emacs (GPL) unless
otherwise specified. See the =COPYING= file for more information.

Any external/third party works included in this work are licensed under
their own licenses - refer to the submodules or packages for more
information.

** Conventions

Functions and variables defined exclusively for my use are prefixed with my
initials and a slash =smf/= to namespace them.

** Setup

Emacs looks in [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Loading-Files.html][load-path]] for Emacs lisp files. =require= and other loading
constructs use this when looking for implicit names.

First we define a convenience function =smf/add-to-load-path= that adds the
passed in directory to =load-path=:

#+BEGIN_SRC emacs-lisp
  (defun smf/add-to-load-path (dir)
    "Adds `dir' to load-path"
    (add-to-list 'load-path dir))
#+end_src

and a convenience function for making a proper path out of two strings:

#+begin_src emacs-lisp
  (defun smf/join-dirs (prefix suffix)
    "Joins `prefix' and `suffix' into a directory"
    (file-name-as-directory (concat prefix suffix)))
#+end_src

*** Base load path

Define a base directory =smf/dotfiles-dir= that's relative to the currently
loading file (this file). This means if I deliberately start Emacs with a file
loaded:

#+begin_src
$ emacs -q -l ~/src/emacs/init.el
#+end_src

then =smf/dotfiles-dir= will be =~/src/emacs=.

#+begin_src emacs-lisp
  (defconst smf/dotfiles-dir
    (file-name-directory
     (or (buffer-file-name) load-file-name))
    "Base path for customised Emacs configuration")
#+end_src

This variable is important because all other directories I load things from are
relative to it, which means my Emacs config doesn't need to live in
=user-emacs-directory=.

*** Temporary directory

Emacs has many packages which need to store state in files. Generally these are
in =~= or =user-emacs-directory= - since my entire =~/.emacs.d= is versioned,
I'd rather all temporary files were stored in a known place, =smf/tmp-local-dir=.
This directory is created if it doesn't exist.

#+begin_src emacs-lisp
  (make-directory
   (setq smf/tmp-local-dir
         (smf/join-dirs smf/dotfiles-dir ".tmp")) t)
#+end_src

*** Backups

Emacs automatically [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Backup.html][backs up files]] while you're editing them. The default
configuration isn't great though.

First, set up some directories to keep backups:

#+begin_src emacs-lisp
  (make-directory
   (setq smf/tmp-backups-dir
         (smf/join-dirs smf/tmp-local-dir "backups")) t)
  (make-directory
   (setq smf/tmp-autosaves-dir
         (smf/join-dirs smf/tmp-local-dir "autosaves")) t)
#+end_src

Now use those directories for backups and autosave files:

#+begin_src emacs-lisp
  (setq backup-directory-alist `((".*" . ,smf/tmp-backups-dir))
        auto-save-file-name-transforms `((".*" ,smf/tmp-autosaves-dir)))
#+end_src

Always copy files when backing up to avoid breaking symlinks:

#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

Delete old versions automatically, and keep a limited number around:

#+begin_src emacs-lisp
  (setq delete-old-versions t
        kept-new-versions 2
        kept-old-versions 2)
#+end_src

Turn off all version control,

#+begin_src emacs-lisp
  (setq vc-handled-backends nil)
#+end_src

Finally, use version numbers in the filenames:

#+begin_src emacs-lisp
  (setq version-control t)
#+end_src

** =after-load=

First let's define a convenient macro that wraps typical =eval-after-load= in
such a way that we don't need to use =progn= to contain the callback logic. This
macro was gotten from [[https://github.com/purcell/emacs.d/blob/aa789c9745b13612c4fea6e638d81d8ebbfecdf8/init-utils.el#L1-L5][Steve Purcell's emacs.d repo]]:

#+begin_src emacs-lisp
  (defmacro after-load (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body)))
#+end_src

** Client/server

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server][client/server]] model for editing. The client is invoked via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Invoking-emacsclient.html][the
=emacsclient= command]]. More information on configuration is available on the
[[http://www.emacswiki.org/emacs/EmacsClient][EmacsWiki EmacsClient page]].

We make sure the server is running, additionally guarded to check if the version
of Emacs we're using supports the server package:

#+begin_src emacs-lisp
  (setq server-use-tcp t)
  (when (require 'server nil t)
    (unless (server-running-p)
      (server-start)))
#+end_src

** Editing defaults

Emacs comes with a collection of strange defaults. See [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's
=sane-defaults.el= file]] for some commentary.

*** Line widths and wrapping

The default wrap width (known as [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Filling.html][filling]]) for Emacs is 70 characters. Modern
conventions state that 80 characters is the standard:

#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

I don't type double-space sentences, so make sure that Emacs doesn't look for
double-spaces after periods to fill paragraphs correctly:

#+begin_src emacs-lisp
  (setq-default sentence-end-double-space nil)
#+end_src

*** Trailing whitespace

Most UNIX tools work best when there's a trailing newline on all files. Enable
that option:

#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src

Emacs has lots of other options for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Useless-Whitespace.html][managing superfluous whitespace]].

*** Indentation

I don't use tabstops in files, and my default tab width is 4 characters.

It's worth noting that Emacs can override either of those on a per-file/mode
basis, so Makefiles, Ruby etc. will still get the correct indentation rules.

#+begin_src emacs-lisp
  (setq-default
   indent-tabs-mode nil
   tab-width 4
   tab-stop-list (number-sequence 4 120 4)
   sh-basic-offset 2
   sh-indentation 2
   c-basic-offset 4
   web-mode-code-indent-offset 2
   web-mode-markup-indent-offset 2
   web-mode-css-indent-offset 2
   web-mode-sql-indent-offset 2)
#+end_src

**** Auto-indentation

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Indent-Convenience.html][Electric indent mode]] was added in Emacs 24.1, and it enables automatic indentation when typing a newline. [[http://emacsredux.com/blog/2013/03/29/automatic-electric-indentation][More about electric indent mode on Emacs Redux]].

First we define convenience toggling functions we can use in a hook (or interactively):

#+begin_src emacs-lisp
  (defun smf/turn-on-electric-indent-mode ()
    "Turns on electric-indent-mode"
    (interactive)
    (electric-indent-mode 1))

  (defun smf/turn-off-electric-indent-mode ()
    "Turns off electric-indent-mode"
    (interactive)
    (electric-indent-mode -1))
#+end_src

then we enable it for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Program-Modes.html][the generic abstract programming mode =prog-mode=,
introduced in Emacs 24.1]] ([[http://emacsredux.com/blog/2013/04/05/prog-mode-the-parent-of-all-programming-modes/][more about =prog-mode= on Emacs Redux]]):

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'smf/turn-on-electric-indent-mode)
#+end_src

*** Encoding

I want to have [[http://en.wikipedia.org/wiki/UTF-8][UTF-8]] by default. [[http://www.masteringemacs.org/articles/2012/08/09/working-coding-systems-unicode-emacs/][Emacs unfortunately has a few settings that
govern encoding]], so we should set them all at once:

#+begin_src emacs-lisp
  ;; Utf-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
#+end_src

*** Smart =beginning-of-line=

=C-a= is mapped to =beginning-of-line= by default, which moves point to position
0 on the current line. [[http://irreal.org/blog/?p=1946][The irreal blog suggests a smarter alternative]] that moves
the point to the first non-whitespace character first, and then position 0, with
extra presses toggling the position:

#+begin_src emacs-lisp
  (defadvice move-beginning-of-line (around smarter-bol activate)
    ;; Move to requested line if needed.
    (let ((arg (or (ad-get-arg 0) 1)))
      (when (/= arg 1)
        (forward-line (1- arg))))
    ;; Move to indentation on first call, then to actual BOL on second.
    (let ((pos (point)))
      (back-to-indentation)
      (when (= pos (point))
        ad-do-it)))
#+end_src

This functionality uses the Emacs concept of [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html][advice]], which is a way of modifying
existing functions in-place without redefining the entire thing.

*** Fix minibuffer behaviour

When changing focus to the minibuffer, stop allowing point to move over the
prompt. Code taken from [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][ergoemacs]].

#+begin_src emacs-lisp
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'minibuffer-avoid-prompt))
  (setq minibuffer-prompt-properties (add-to-list 'minibuffer-prompt-properties 'point-entered))
#+end_src

While we're at it, let's allow recursive minibuffers.

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

Also, let's save the minibuffer history between sessions. It's 2014. We have the
technology.

#+begin_src emacs-lisp
  (savehist-mode t)
  (setq history-length 1000)
#+end_src

*** Deleting files

Move files to the trash when deleting:

#+begin_src emacs-lisp
  (setq delete-by-moving-to-trash t)
#+end_src

*** Compressed files

Transparently open compressed files:

#+begin_src emacs-lisp
  (auto-compression-mode t)
#+end_src

*** Active region

Got these from [[https://github.com/magnars/.emacs.d/blob/master/sane-defaults.el][Magnar Sveen's =sane-defaults.el=]]. Show the active region,

#+begin_src emacs-lisp
  (transient-mark-mode 1)
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+end_src

Remove text in active region if inserting text,

#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

*** Pop mark

When popping the mark, continue popping until the cursor actually moves. Also,
if the last command was a copy - skip past all the expand-region cruft.

#+begin_src emacs-lisp
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (when (eq last-command 'save-region-or-current-line)
        ad-do-it
        ad-do-it
        ad-do-it)
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+end_src

** Keyboard

*** Modifier keys

- =C-= means =Control= in combination with another key, eg =C-x= means =Ctrl + x=
- =M-= means =Meta= in combination with another key. This is usually =Alt=, or
  =⌘= on OS X (by default). =Esc= also serves as =Meta= if it's not separately
  bound. On OS X I want to use left =⌥= for =Meta=, and leave right =⌥= alone:

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-alternate-modifier 'meta)
    (setq mac-option-modifier 'meta)
    (setq ns-right-alternate-modifier nil))
#+end_src

- =s-= means [[http://en.wikipedia.org/wiki/Super_key_(keyboard_button)][super key]]. On OS X I want this to be =⌘=:

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-command-modifier 'super)
    (setq mac-command-modifier 'super)) ;; for EmacsMac.app
#+end_src

- =H-= means [[http://en.wikipedia.org/wiki/Hyper_key][hyper key]]. On OS X I want this to be =fn=:

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (setq ns-function-modifier 'hyper)
    (setq mac-function-modifier 'hyper)) ;; for EmacsMac.app
#+end_src

*** Basic remappings

The below are some remappings I got from [[https://sites.google.com/site/steveyegge2/effective-emacs][Steve Yegge's Effective Emacs]] article.
They're designed to map some slightly difficult but very common mappings to
things that are easier to type.

**** Invoke =M-x= without the Alt key

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item2][Yegge's Item 2]]. This unmaps the difficult =M-x= (usually =Alt+x=) to =C-x
m=, and then add a fat-finger combination of =C-x C-m=:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'execute-extended-command)
  (global-set-key (kbd "C-x C-m") 'execute-extended-command)
#+end_src

**** Prefer =backward-kill-word= over Backspace

As per [[https://sites.google.com/site/steveyegge2/effective-emacs#item3][Yegge's Item 3]]. This emulates readline =C-w= command to
=backward-kill-word=. The command that used to live there (=kill-region=) is not
needed since the backspace key works just fine in that case.

#+begin_src emacs-lisp
  ;; deletes backward until a space is hit
  (defun smf/backward-kill-word ()
    (interactive)
    (if (and transient-mark-mode mark-active)
        (kill-region (point) (mark))
      (progn
        (delete-region (point) (save-excursion (skip-syntax-backward " ") (point)))
        (delete-region (point) (save-excursion (skip-syntax-backward "^ ") (point))))))

  (global-set-key (kbd "C-w") 'smf/backward-kill-word)
#+end_src

**** Quick window switching

Usually one must type =C-x o= to switch between windows - make that quicker by
also mapping =M-o=:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
  ;; Moving between windows
  (global-set-key (kbd "C-s-<up>") 'windmove-up)
  (global-set-key (kbd "C-s-<down>") 'windmove-down)
  (global-set-key (kbd "C-s-<right>") 'windmove-right)
  (global-set-key (kbd "C-s-<left>") 'windmove-left)
#+end_src

**** Buffer management

Burying a buffer (removing it from the current window and sending it to the
bottom of the stack) is very common for dismissing buffers. Add a mapping for
it:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c y") 'bury-buffer)
#+end_src

Add a key combination to revert the current buffer (re-read the contents from
disk):

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'revert-buffer)
#+end_src

Most of the time I want the buffer to be reverted automatically:

#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

Use =ido-switch-buffer= instead of the feature-lacking =list-buffers= (and
include a common typo I make):

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
  (global-set-key (kbd "C-x C-n") 'ido-switch-buffer)
#+end_src

*** Launcher keymap

This trick I got from [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][a blog post on launcher keymaps]]. I define my launcher
combo as =C-x C-l=, which is normally =downcase-region= - a command I use so
infrequently I didn't even know there was a key binding for it.

#+begin_src emacs-lisp
  (define-prefix-command 'smf/launcher-map)
  (define-key ctl-x-map (kbd "C-l") 'smf/launcher-map)
#+end_src

rather than remembering that it's =smf/launcher-map=, just make a function:

#+begin_src emacs-lisp
  (defun smf/add-launcher (key function)
    "Maps FUNCTION to KEY under the `smf/launcher-map' prefix"
    (define-key smf/launcher-map key function))
#+end_src

** Interface

*** Remove chrome

To ensure that all scrollbars, toolbars etc. are turned off, we run this as
early as possible.

#+NAME: turn-off-chrome
#+begin_src emacs-lisp
  (dolist (mode '(tool-bar-mode scroll-bar-mode))
    (when (fboundp mode) (funcall mode -1)))
#+end_src

*** Startup buffers

Turn off the startup screen, and always show =*scratch*=.

#+NAME: turn-off-startup
#+begin_src emacs-lisp
  ;; inhibit startup screen
  (setq inhibit-startup-screen t
        ;; Show *scratch* on start
        initial-buffer-choice t)
#+end_src

*** Font

I use [[https://github.com/Lokaltog/powerline-fonts/tree/master/SourceCodePro][Source (Sauce) Code Pro]] as my default coding font:

#+begin_src emacs-lisp
  ;; set the font
  (when (window-system)
    (condition-case err
      (set-default-font "Source Code Pro for Powerline Light")
      (error
        (set-default-font "Sauce Code Powerline Light"))))
#+end_src

*** Syntax highlighting

Syntax highlighting in Emacs is called [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Font-Lock.html][font locking]]. It's enabled by
=font-lock-mode=. This turned on by default in modern Emacs systems, but it's
worth keeping around:

#+begin_src emacs-lisp
  (global-font-lock-mode t)
#+end_src

Emacs also supports multiple levels of complexity for highlighting. Setting this
value to =t= forces it to pick the maximum available (also the default):

#+begin_src emacs-lisp
  (setq font-lock-maximum-decoration t)
#+end_src

*** Line and column numbers

Emacs doesn't display line numbers by the code by default. For that you want
[[http://www.emacswiki.org/emacs/LineNumbers#toc1][Linum mode]].

I want to display the current line number in the
[[http://www.emacswiki.org/emacs/ModeLine][mode line]], and also the current
column number:

#+begin_src emacs-lisp
  (line-number-mode 1)
  (column-number-mode 1)
#+end_src

*** Tooltips

Emacs convention is to show help and other inline documentation in the [[https://www.gnu.org/software/emacs/manual/html_node/eintr/message.html][message
area]]. Show help there instead of using an OS tooltip:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (tooltip-mode -1))
#+end_src

*** Dialogue boxes and windows

Just don't show them. Use native Emacs controls:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq use-dialog-box nil))
#+end_src

Make the window title display the full path of the file I'm currently editing:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b")))))
#+end_src

Aside: Emacs calls OS windows [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames][frames]] and divisions within frames [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html#Windows][windows]]. [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Titles.html][More
information on frame titles]].

*** Cursor

I prefer a box, non-blinking cursor. So, turn off that blinking:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq-default cursor-type 'box)
    (blink-cursor-mode (- (*) (*) (*))))
#+end_src

Depending on the mode, let's [[http://www.emacswiki.org/emacs/ChangingCursorDynamically][change the cursor]].

#+begin_src emacs-lisp
  (setq smf/read-only-color       "gray")
  (setq smf/read-only-cursor-type 'hbar)
  (setq smf/overwrite-color       "red")
  (setq smf/overwrite-cursor-type 'box)
  (setq smf/normal-color          "gray")
  (setq smf/normal-cursor-type    'box)

  (defun smf/set-cursor-according-to-mode ()
    "change cursor color and type according to some minor modes."

    (cond
     (buffer-read-only
      (set-cursor-color smf/read-only-color)
      (setq cursor-type smf/read-only-cursor-type))
     (overwrite-mode
      (set-cursor-color smf/overwrite-color)
      (setq cursor-type smf/overwrite-cursor-type))
     (t
      (set-cursor-color smf/normal-color)
      (setq cursor-type smf/normal-cursor-type))))

  (add-hook 'post-command-hook 'smf/set-cursor-according-to-mode)
#+end_src

*** Typing

Show the modifier combinations I just typed almost immediately:

#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+end_src

Don't make me type =yes= or =no= to boolean interface questions:

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Code commenting

A drop-in replacement for comment-dwim. If no region is selected and current
line is not blank and we are not at the end of the line, then comment current
line.

#+begin_src emacs-lisp
  (defun comment-dwim-line (&optional arg)
    (interactive "*P")
    (comment-normalize-vars)
    (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
        (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (comment-dwim arg)))
  (global-set-key (kbd "M-;") 'comment-dwim-line)
#+end_src

Comment or uncomment the region or current line if no active region.

#+begin_src emacs-lisp
  (defun comment-or-uncomment-region-or-line ()
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))
  (global-set-key (kbd "s-;") 'comment-or-uncomment-region-or-line)
#+end_src

*** Bells

Don't make a sound when [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Beeping.html][ringing a bell]] - flash a visual bell instead:

#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

Override the =ring-bell-function= to conditionally ring the bell only when it's
not a valid quit case like hitting =esc= or =C-g=. Generally this means the bell
will only ring when there's actually an error raised somehow:

#+begin_src emacs-lisp
  (setq ring-bell-function
        (lambda ()
          "Only rings the bell if it's not a valid quit case, e.g
  keyboard-quit"
          (unless (memq this-command
                        '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
            (ding))))
#+end_src

*** Buffer naming

By default Emacs resolves conflicting buffer names by appending a number to
them. For instance, if I open =~/src/thing/init.el= and
=~/src/other-thing/init.el= they'll be named =init.el= and =init.el<2>=
respectively.

We can use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][Uniquify]] library to name them =thing/init.el= and
=other-thing/init.el=, which is much easier to make sense of.

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+end_src

** OS X specific configuration

Besides the keyboard configuration above, there are some other specific things I
do on OS X. On OS X =system-type= is the symbol =darwin=.

*** Host name mangling

Typically OS X hosts are called things like =hostname.localconfig= or
=hostname.local=. Make Emacs report that without the extra suffix:

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq system-name (car (split-string system-name "\\."))))
#+end_src

*** Spelling correction

[[https://www.gnu.org/software/ispell/][ispell]] isn't generally available on OS X. [[http://aspell.net][aspell]] is available via [[https://github.com/Homebrew/homebrew/blob/master/Library/Formula/aspell.rb][Homebrew]], so
let's use that if we can find it:

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (executable-find "aspell"))
      (setq ispell-program-name (executable-find "aspell")))
#+end_src

On the mac, the default mouse bindings are problematic since a two-finger click
is =mouse-3= and not =mouse-2=:

#+begin_src emacs-lisp
    (after-load 'flyspell
      (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
      (define-key flyspell-mouse-map [mouse-3] #'undefined))
#+end_src

Diminish [[flyspell]],

#+begin_src emacs-lisp
  (after-load 'flyspell
    (after-load 'diminish
      (diminish 'flyspell-mode)))
#+end_src

*** dired fixes

OS X's bundled version of =ls= isn't the GNU one, so it doesn't support the
=--dired= flag. Emacs caters for that use case:

#+begin_src emacs-lisp
  (setq dired-use-ls-dired nil)
#+end_src

*** sRGB display fixes

As of Emacs 24.4, [[http://lists.gnu.org/archive/html/emacs-devel/2013-12/msg00741.html][Emacs natively supports proper sRGB]] values on OS X:

#+begin_src emacs-lisp
  (setq ns-use-srgb-colorspace t)
#+end_src

If you're not using Emacs 24.4 this variable setting will have no effect. See
[[https://github.com/Homebrew/homebrew/blob/7446162e59fe548a0fde735d25b9913f8fa2ad4a/Library/Formula/emacs.rb#L10][Homebrew's Emacs recipe]] for details of how to get this behaviour in earlier
Emacs versions.

*** Terminal integration

Using this configuration, Emacs runs best in [[http://iterm2.com][iTerm2]].

On the desktop, Emacs integrates with the OS X clipboard, so =kill= etc. copy to
the clipboard, and =yank= copies from the clipboard.

Obviously this doesn't work in the terminal, so we need to use the
=interprogram-(cut|paste)-function= variables to copy/paste. Most of this code
gotten from [[http://mindlev.wordpress.com/2011/06/13/emacs-in-a-terminal-on-osx/#comment-20][this blog comment]].

#+begin_src emacs-lisp
  (when (and (not (display-graphic-p)) (eq system-type 'darwin))
    (defun smf/copy-from-osx ()
      "Copies the current clipboard content using the `pbcopy` command"
      (shell-command-to-string "pbpaste"))

    (defun smf/paste-to-osx (text &optional push)
      "Copies the top of the kill ring stack to the OSX clipboard"
      (let ((process-connection-type nil))
        (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
          (process-send-string proc text)
          (process-send-eof proc))))

    (setq interprogram-cut-function 'smf/paste-to-osx)
    (setq interprogram-paste-function 'smf/copy-from-osx))
#+end_src

Also, allow pasting selection outside of Emacs:

#+begin_src emacs-lisp
  (setq x-select-enable-clipboard t)
#+end_src

*** Fullscreen support

On Emacs 24.4 and above, Lion-style fullscreen display is supported but I
dislike it. Define a method to toggle fullscreen pre-Lion.

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (fboundp 'toggle-frame-fullscreen))
    (defun toggle-fullscreen ()
      "Toggle full screen"
      (interactive)
      (set-frame-parameter nil 'fullscreen
                           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

      (global-set-key (kbd "C-s-f") 'toggle-fullscreen))
#+end_src

On the Yosemite beta, =ns-use-native-fullscreen= is =nil=.

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq ns-use-native-fullscreen nil))
#+end_src

*** OS X keybindings

There are a lot of native OS X-isms that I would like to keep. Things such =⌘-a=
to select the whole buffer, or =⌘-c= to copy.

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-a") 'mark-whole-buffer)
    (global-set-key (kbd "s-v") 'yank)
    (global-set-key (kbd "s-c") 'kill-ring-save)
    (global-set-key (kbd "s-x") 'kill-region)
    (global-set-key (kbd "s-s") 'save-buffer)
    (global-set-key (kbd "s-l") 'goto-line)
    (global-set-key (kbd "s-w")
                    (lambda () (interactive) (delete-window)))
    (global-set-key (kbd "s-z") 'undo)
    (global-set-key (kbd "s-Z") 'undo-tree-redo)
    (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
    (global-set-key (kbd "s-k") 'kill-this-buffer)
    (global-set-key (kbd "s-r") 'recompile)
    (global-set-key (kbd "s-}") 'forward-paragraph)
    (global-set-key (kbd "s-{") 'backward-paragraph)
    (global-set-key (kbd "s-f") 'isearch-forward)
    (global-set-key (kbd "s-g") 'isearch-repeat-forward)
    (global-set-key [(H left)]  'beginning-of-buffer)
    (global-set-key [(H right)] 'end-of-buffer)
    (global-set-key [(H down)] [?\C-v])
    (global-set-key [(H up)] [?\M-v]))
#+end_src

The =⌘-backspace= deletes text from the current position to the beginning of the
line.

#+begin_src emacs-lisp
  (global-set-key [s-backspace] [?\C- ?\C-a backspace])
#+end_src

** Utility functions

*** Rename modeline

Renames the major-mode lighter in the modeline. Lifted from [[http://whattheemacsd.com/appearance.el-01.html][What the emacs.d]].

#+begin_src emacs-lisp
  (defmacro rename-modeline (package-name mode new-name)
    `(eval-after-load ,package-name
       '(defadvice ,mode (after rename-modeline activate)
          (setq mode-name ,new-name))))
#+end_src

*** Get keychain password

If I'm on OS X, I can fetch passwords etc. from my Keychain. This is much more
secure than storing them in configuration on disk:

#+begin_src emacs-lisp
  (defun smf/chomp (str)
    "Chomp leading and tailing whitespace from `str'."
    (while (string-match "\\`\n+\\|^\\s-+\\|\\s-+$\\|\n+\\'" str)
      (setq str (replace-match "" t t str))) str)

  (defun smf/get-keychain-password (account-name &optional server)
    "Get `account-name' keychain password from OS X Keychain"
    (interactive "sAccount name: ")
    (smf/chomp
     (shell-command-to-string
      (concat
       "security find-"
       (if server "internet" "generic")
       "-password -wa "
       account-name
       (if server (concat " -s " server))))))
#+end_src

Eventually, I'd like to use auth-source instead of custom methods for accessing
the keychain, but erc is giving me problems currently.

#+begin_src emacs-lisp
  (setq auth-sources '(macos-keychain-internet))
#+end_src

*** Conditionally kill Emacs

When I'm in an emacsclient, I probably just want the client to die rather than
the entire server. And, when I kill my server, I want Emacs to confirm this with
me:

#+begin_src emacs-lisp
  (defun smf/kill-emacs ()
    "If this buffer is a client, just kill it, otherwise confirm
  the quit."
    (interactive)
    (if server-buffer-clients
        (server-edit)
      (if (= (length (frame-list)) 1)
        (save-buffers-kill-terminal))))
#+end_src

Enable this, and override the default command Emacs assigns to kill itself:

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap save-buffers-kill-terminal] 'smf/kill-emacs)
#+end_src

Also, when using an emacsclient that is waiting, I don't want a prompt that asks
if I really want to exit. So, we define our own function and bind it to =⌘-k=.

#+begin_src emacs-lisp
  (add-hook 'server-switch-hook
            (lambda ()
              (local-set-key (kbd "s-k") '(lambda ()
                                            (interactive)
                                            (if server-buffer-clients
                                                (server-edit)
                                              (kill-this-buffer))))))
#+end_src

*** narrow-or-widen-dwim

Taken from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][here]], this function defines a handy way to narrow the buffer. We'll
add a launcher for it bound to 'n'.

#+begin_src emacs-lisp
  (defun smf/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  (global-set-key (kbd "H-n") 'smf/narrow-or-widen-dwim)
#+end_src

*** Delete to end of buffer

In emails (and sometimes other places, too) I frequently want to delete the rest
of the buffer. We'll bind this to =C-M-d=

#+begin_src emacs-lisp
  (defun smf/delete-to-end-of-buffer (add-to-kill-ring-p)
    "Deletes from point to end of buffer. If prefix argument is
     given, kill the region, adding it to the kill ring."
    (interactive "P")
    (if add-to-kill-ring-p
        (kill-region (point) (point-max))
      (delete-region (point) (point-max))))

  (global-set-key (kbd "C-M-d") 'smf/delete-to-end-of-buffer)
#+end_src

** Other modes

Emacs comes with hundreds of major and minor modes to do many many things. These
are the ones I commonly use and have configured.

*** org

[[http://orgmode.org][org-mode]] is a plain text system for organising information and notes.

Don't auto-fold my documents:

#+begin_src emacs-lisp
  (setq org-startup-folded nil)
#+end_src

When editing [[http://orgmode.org/manual/Working-With-Source-Code.html#Working-With-Source-Code][nested source code]], always accept Emacs Lisp:

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)))
#+end_src

and automatically apply syntax highlighting:

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+end_src

When using [[http://www.emacswiki.org/emacs/ImenuMode][imenu]], make sure I can follow the outline to the full available
depth:

#+begin_src emacs-lisp
  (setq org-imenu-depth 6)
#+end_src

Also, I like using shift+arrow keys to highlight, so let's set that:

#+begin_src emacs-lisp
  (setq org-support-shift-select 'always)
#+end_src

*** ido

[[http://www.emacswiki.org/emacs/InteractivelyDoThings][ido]] is a mode for narrowing candidates as you type. It has excellent
integration with buffer switching and finding files. [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mastering Emacs has a good
guide to Ido]].

First we enable =ido-mode= globally and enable =ido-everywhere=, which enables
Ido for buffer and file reading:

#+begin_src emacs-lisp
  (after-load 'ido
    (ido-mode t)
    (ido-everywhere t))
#+end_src

Force Ido to [[http://stackoverflow.com/a/11341239/61435][ignore Dropbox cruft]]:

#+begin_src emacs-lisp
  (after-load 'ido
    (add-to-list 'ido-ignore-files "Icon\n"))
#+end_src

Also ignore certain extensions that I don't care about

#+begin_src emacs-lisp
  (setq completion-ignored-extensions
        '(".o" ".elc" "~" ".bin" ".bak" ".obj" ".map" ".a" ".ln" ".mod" ".gz"
          ".aux" ".tdo" ".fmt" ".swp" ".pdfsync" ".pdf" ".vrb" ".idx" ".ind"
          ".bbl" ".toc" ".blg" ".snm" ".ilg" ".log" ".out" ".pyc" ".DS_Store"
          "-blx.bib" ".run.xml" ".hi" ".fls" ".fdb_latexmk" ".bcf" ".rel"))
#+end_src

Configure Ido (see comments for more information):

#+begin_src emacs-lisp
  (after-load 'ido
    (setq
     ;; Speed up ido by using less candidates
     ido-max-prospects 10
     ;; Match arbitrary points in strings
     ido-enable-prefix nil
     ;; Match across entire string
     ido-enable-flex-matching t
     ;; Create a new buffer if there's no match candidate
     ido-create-new-buffer 'always
     ;; Don't try and guess if the string under point is a file
     ido-use-filename-at-point nil
     ;; case-insensitive matching
     ido-case-fold t
     ;; don't store old files as virtual buffers
     ido-use-virtual-buffers nil))
#+end_src

Store =ido= temporary directory cache elsewhere:

#+begin_src emacs-lisp
  (setq ido-save-directory-list-file (expand-file-name ".ido.last" smf/tmp-local-dir))
#+end_src

Finally load Ido:

#+begin_src emacs-lisp
  (require 'ido)
#+end_src

*** bookmarks

Emacs has robust [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Bookmarks.html][bookmarking functionality]]. It uses a file to persit the list of
bookmarks, so make sure that file is in my custom temporary directory:

#+begin_src emacs-lisp
  (after-load 'bookmark
    (setq bookmark-default-file (expand-file-name ".emacs.bmk" smf/tmp-local-dir)))
#+end_src

*** eldoc-mode

[[http://www.emacswiki.org/emacs/ElDoc][eldoc-mode]] is a minor mode that displays context-sensitive help when editing
Emacs lisp (eg information about arity of functions). Enable that for
=emacs-lisp-mode=:

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
#+end_src

*** python-mode

As of 24.2, Emacs ships with a [[http://www.emacswiki.org/emacs/PythonProgrammingInEmacs#toc1][robust Python mode]]. However, when navigating
=SnakeCase= words (eg class names), =forward-word= etc don't work correctly.

We can work around that using [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html#Subword-Movement][subword-mode]]:

#+begin_src emacs-lisp
  (add-hook 'python-mode-hook (lambda () (subword-mode 1)))
#+end_src

*** ruby-mode

As of 24.4, Emacs comes with a much better [[http://www.masteringemacs.org/articles/2013/12/29/whats-new-in-emacs-24-4/][Ruby mode]]. However it doesn't come
with =subword-mode= enabled by default:

#+begin_src emacs-lisp
  (after-load 'ruby-mode
    (add-hook 'ruby-mode-hook (lambda () (subword-mode 1))))
#+end_src

Add =Puppetfile= files to [[ruby-mode]]:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("[pP]uppetfile\\'" . ruby-mode))
#+end_src

*** hippie

[[http://www.emacswiki.org/emacs/HippieExpand][Hippie expand]] is a more feature complete completion engine than the default
[[http://www.emacswiki.org/emacs/DynamicAbbreviations][dabbrev]] engine. The main feature I use over =dabbrev= is that it supports a wide
range of backends for finding completions - =dabbrev= only looks at currently
open buffers.

First we customise the types of things it looks for:

#+begin_src emacs-lisp
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))
#+end_src

Then we override =dabbrev-expand='s keybinding to use =hippie-expand= instead
(normally this is =M-/=):

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap dabbrev-expand] 'hippie-expand)
#+end_src

*** tramp mode

=tramp-mode= is a package that provides [[https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top][remote file editing]], eg =find-file
/user@host:file=. This allows one to edit files on other servers using your
local Emacs (rather than the Vim user's equivalent of editing the file on the
server).

All of the below are wrapped in an =after-load= construct because =tramp-mode=
isn't loaded by default on older versions of Emacs.

First we set the default mode to be =ssh= (it's normally =scp=). There are two
reasons for this choice:

- =ssh= takes a port number as an argument, whereas =scp= doesn't
- It's [[http://www.gnu.org/software/tramp/#Default-Method][apparently faster]] for smaller files

#+begin_src emacs-lisp
  (after-load 'tramp
    (setq tramp-default-method "ssh"))
#+end_src

We also want to alter the list of allowed proxies (tramp uses a whitelist for
patterns that it can remotely access) so I can edit remote files as sudo, eg
=find-file /sudo:example.com/etc/something-owned-by-root=.

I got this code from the [[http://www.gnu.org/software/tramp/#Multi_002dhops][Multi-hops section of the tramp manual]].

#+begin_src emacs-lisp
  (after-load 'tramp
    (add-to-list 'tramp-default-proxies-alist
                 '(nil "\\`root\\'" "/ssh:%h:")))
#+end_src

Also make sure we can edit local files as sudo - this is normally disallowed for
security reasons:

#+begin_src emacs-lisp
  (after-load 'tramp
    (add-to-list 'tramp-default-proxies-alist
                 '((regexp-quote (system-name)) nil nil)))
#+end_src

More on the last two incantations at [[http://emacs-fu.blogspot.co.uk/2009/10/editing-files-owned-by-root.html][emacs-fu's guide to editing files owned by root]].

*** eshell

[[http://www.gnu.org/software/emacs/manual/html_node/eshell/][eshell]] is a shell-like command interpreter built with Emacs lisp. It integrates
well with Emacs, and can be a convenient way to get a shell without invoking
bash or similar (provided you don't want any interactive commands).

There's a great guide to [[http://www.masteringemacs.org/articles/2010/12/13/complete-guide-mastering-eshell/][mastering eshell]] on [[http://www.masteringemacs.org][Mastering Emacs]].

eshell has a directory where it stores bookmarks and other temporary cruft -
move that out of the way:

#+begin_src emacs-lisp
  (setq eshell-directory-name (smf/join-dirs smf/tmp-local-dir "eshell"))
#+end_src

When using the =ssh= command (or =vagrant ssh=, which is really the same thing),
we'll want to jump into something that's an actual terminal emulator like
=ansi-term= (eshell won't be able to deal with the login on the remote machine):

#+begin_src emacs-lisp
  (after-load 'esh-opt
    (require 'em-term)
    (add-to-list 'eshell-visual-commands "ssh")
    (when (fboundp 'eshell-visual-subcommands)
      (add-to-list 'eshell-visual-subcommands '("vagrant" "ssh"))))
#+end_src

Define a keybinding to get an =eshell= buffer anywhere:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-t e") 'eshell)
#+end_src

*** ansi-term

[[http://www.emacswiki.org/emacs/AnsiTerm][ansi-term]] is a terminal emulator written in Emacs Lisp. It's more like a
traditional terminal emulator than [[eshell]].

Force ansi-term to be UTF-8 after it launches:

#+begin_src emacs-lisp
  (defadvice ansi-term (after smf/advise-ansi-term-coding-system activate)
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
#+end_src

When exiting a terminal buffer (either with =exit= or =EOF=), automatically kill
the buffer:

#+begin_src emacs-lisp
  (defadvice term-sentinel (around smf/advice-term-sentinel (proc msg) activate)
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
#+end_src

*** recentf

[[http://www.emacswiki.org/emacs/RecentFiles][recentf]] stores a list of recently opened files.

Never clean up the list:

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-auto-cleanup 'never))
#+end_src

The list of files contains any files Emacs has read, not just files I've
explicitly opened. Clean that list to exclude Emacs metafiles, package cruft
etc.

TODO: refactor to use =recentf-keep=: [[http://www.emacswiki.org/emacs/RecentFiles#toc18]]

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-exclude '("[/\\]\\.elpa/" "[/\\]\\.ido\\.last\\'" "[/\\]\\.git/" ".*\\.gz\\'" ".*-autoloads\\.el\\'" "[/\\]archive-contents\\'" "[/\\]\\.loaddefs\\.el\\'" "url/cookies" ".*\\emacs.bmk\\'")))
#+end_src

Save the most recent 100 items (this is manily to keep the list low for [[ido]]):

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-max-saved-items 100))
#+end_src

Customise the place =recentf= persists its list of items:

#+begin_src emacs-lisp
  (after-load 'recentf
    (setq recentf-save-file (expand-file-name ".recentf" smf/tmp-local-dir)))
#+end_src

Strip =$HOME= from the front of =recentf= candidate files:

#+begin_src emacs-lisp
  (after-load 'recentf
    (add-to-list 'recentf-filename-handlers 'abbreviate-file-name))
#+end_src

I want easy access to my recent files, so define a function that lets me use [[ido]]
to search over them. Bind this to =C-x C-r= (=C-c C-r= is used in modes like
=org=mode):

#+begin_src emacs-lisp
  (after-load 'recentf
    (after-load 'ido
      (defun smf/recentf-ido-find-file ()
        "Find a recent file using ido."
        (interactive)
        (let ((file (ido-completing-read "Recently: " recentf-list nil t)))
          (when file
            (find-file file))))

      (global-set-key (kbd "C-x C-r") 'smf/recentf-ido-find-file)))
#+end_src

Now enable =recentf=:

#+begin_src emacs-lisp
  (after-load 'recentf
    (recentf-mode 1))
  (require 'recentf)
#+end_src

*** ediff

[[https://www.gnu.org/software/emacs/manual/html_mono/ediff.html][ediff]] is a full-featured visual diff and merge tool, built into Emacs.

Make sure that the window split is always side-by-side:

#+begin_src emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

Ignore whitespace changes:

#+begin_src emacs-lisp
  (setq ediff-diff-options "-w")
#+end_src

Only ever use one set of windows in one frame:

#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

Don't keep ediff file instances around:

#+begin_src emacs-lisp
  (setq ediff-keep-variants nil)
#+end_src

Finally, we add customizations for using ediff with mercurial:

#+begin_src emacs-lisp
  (defvar ediff-after-quit-hooks nil
    "* Hooks to run after ediff or emerge is quit.")

  (defadvice ediff-quit (after edit-after-quit-hooks activate)
    (run-hooks 'ediff-after-quit-hooks))

  (setq hg-mergetool-emacsclient-ediff-active nil)

  (defun local-ediff-before-setup-hook ()
    (setq local-ediff-saved-frame-configuration (current-frame-configuration))
    (setq local-ediff-saved-window-configuration (current-window-configuration))
    (global-auto-revert-mode 0)
    ;; (local-ediff-frame-maximize)
    (if hg-mergetool-emacsclient-ediff-active
        (raise-frame)))

  (defun local-ediff-quit-hook ()
    (set-frame-configuration local-ediff-saved-frame-configuration)
    (set-window-configuration local-ediff-saved-window-configuration))

  (defun local-ediff-suspend-hook ()
    (set-frame-configuration local-ediff-saved-frame-configuration)
    (set-window-configuration local-ediff-saved-window-configuration))

  (add-hook 'ediff-before-setup-hook 'local-ediff-before-setup-hook)
  (add-hook 'ediff-quit-hook 'local-ediff-quit-hook 'append)
  (add-hook 'ediff-suspend-hook 'local-ediff-suspend-hook 'append)

  ;; Useful for ediff merge from emacsclient.
  (defun hg-mergetool-emacsclient-ediff (local remote base merged)
    (setq hg-mergetool-emacsclient-ediff-active t)
    (if (file-readable-p base)
        (ediff-merge-files-with-ancestor local remote base nil merged)
      (ediff-merge-files local remote nil merged))
    (recursive-edit))

  (defun hg-mergetool-emacsclient-ediff-after-quit-hook ()
    (global-auto-revert-mode t)
    (exit-recursive-edit))

  (add-hook 'ediff-after-quit-hooks 'hg-mergetool-emacsclient-ediff-after-quit-hook 'append)
#+end_src

*** Persistent =*scratch*= buffer

Stolen from [[https://github.com/jwiegley/dot-emacs/blob/master/lisp/persistent-scratch.el][jwiegley's persistent-scratch]]:

Emacs has a handy, but sometimes decried, feature called the "scratch" buffer.
This is a special buffer which is created upon startup and allows the user to
type in and evaluate Emacs Lisp code. Handy for editing tasks too specific (or
not useful enough) to put into an function and handy for exploratory Emacs Lisp
interactive development (although this development is just as easily
accomplished in any file in Lisp mode).

One problem with =*scratch*= is that its tempting to put significant bits of
code (and other information) into it. This isn't a problem in itself, but
=*scratch*= isn't associated with a file, and its contents are lost without
warning when Emacs is closed. Today we'll modify the default behavior of Emacs
so that it saves the scratch buffer to a file on exit and loads it back in on
startup.

#+begin_src emacs-lisp
  (defcustom smf/persistent-scratch-file-name "~/.emacs.d/persistent-scratch"
    "Location of *scratch* file contents for persistent-scratch.")

  (defun smf/save-persistent-scratch ()
    "Write the contents of *scratch* to the file name
    `persistent-scratch-file-name'."
    (with-current-buffer (get-buffer-create "*scratch*")
      (write-region (point-min) (point-max) smf/persistent-scratch-file-name)))

  (defun smf/load-persistent-scratch ()
    "Load the contents of `persistent-scratch-file-name' into the
    scratch buffer, clearing its contents first."
    (if (file-exists-p smf/persistent-scratch-file-name)
        (with-current-buffer (get-buffer "*scratch*")
          (delete-region (point-min) (point-max))
          (insert-file-contents smf/persistent-scratch-file-name))))

  (push #'smf/load-persistent-scratch after-init-hook)
  (push #'smf/save-persistent-scratch kill-emacs-hook)

  (run-with-idle-timer 300 t 'smf/save-persistent-scratch)
#+end_src

*** Known config files

I have a few files in my dotfiles repo that are known to be shell files, so
let's add them:

#+begin_src emacs-lisp
  (setq auto-mode-alist (cons '(".?aliases" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?bash_prompt" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?bashrc" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?exports" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?functions" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?osx" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?osx" . sh-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '(".?profile" . sh-mode) auto-mode-alist))
#+end_src

Same with conf-mode,

#+begin_src emacs-lisp
  (setq auto-mode-alist (cons '(".?hgrc" . conf-mode) auto-mode-alist))
#+end_src

*** whitespace-mode

I like whitespace-mode for programming and text modes (including org),

#+begin_src emacs-lisp
  (require 'whitespace)
  (global-whitespace-mode t)
  (setq whitespace-global-modes '(text-mode prog-mode org-mode))
#+end_src

But most of the time, I only want to see tabs and trailing spaces,

#+begin_src emacs-lisp
  (setq whitespace-style '(trailing face tabs tab-mark lines-tail))
  (setq whitespace-display-mappings '((space-mark 32 [183] [46])
                                      (newline-mark 10 [182 10])
                                      (tab-mark 9 [9655 9] [92 9])))
#+end_src

*** Highlight C functions

Taken from [[http://stackoverflow.com/questions/14715181/emacs-function-call-highlight][this StackOverflow]] question, we use it to highlight functions in C,

#+begin_src emacs-lisp
  (font-lock-add-keywords
   'c-mode
   '(("\\<\\(\\sw+\\) ?(" 1 'font-lock-function-name-face)))
#+end_src

** Third-party packages

Emacs has a built-in [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging][package manager]].

Rather than using Git submodules or similar my Emacs configuration is set up to
automatically download and install any required packages at load time. This
makes my configuration fully portable.

First set up convenience function (borrowed from [[https://github.com/purcell/emacs.d/blob/aa789c9745b13612c4fea6e638d81d8ebbfecdf8/init-elpa.el#L63-L73][Steve Purcell's emacs config]])
that installs a package if it's not already installed:

#+begin_src emacs-lisp
  (defun require-package (package &optional min-version no-refresh)
    "Install given PACKAGE, optionally requiring MIN-VERSION.
  If NO-REFRESH is non-nil, the available package lists will not be
  re-downloaded in order to locate PACKAGE."
    (if (package-installed-p package min-version)
        t
      (if (or (assoc package package-archive-contents) no-refresh)
          (package-install package)
        (progn
          (package-refresh-contents)
          (require-package package min-version t)))))
#+end_src

*** Configure package manager

**** Custom package install location

The default value for =package-user-dir= is =~/.emacs.d/elpa= - since these are
third-party packages that are dynamically installed I'd prefer them to be in a
[[http://en.wikipedia.org/wiki/Dot-file][hidden directory]].

Packages are also [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation][byte compiled]] upon installation, so namespace the install
directory to the version of Emacs I'm using.

Final result should be something like =~/.emacs.d/.elpa/24.3.93.1/=.

#+begin_src emacs-lisp
  (after-load 'package
    (setq package-user-dir
          (smf/join-dirs (smf/join-dirs smf/dotfiles-dir ".elpa") emacs-version)))
#+end_src

**** Customise package repositories to install from

By default Emacs only installs files from [[http://www.gnu.org/software/emacs/manual/html_node/efaq/Packages-that-do-not-come-with-Emacs.html#Packages-that-do-not-come-with-Emacs][ELPA]]. Some of these packages are old
or out of date, and they don't track GitHub repositories.

I want to also add:

- [[https://github.com/milkypostman/melpa#melpa][MELPA]] (tracks GitHub repositories, is much more comprehensive)
- [[https://github.com/milkypostman/melpa#stable-packages][MELPA stable]] (like MELPA, but pinned to specific versions)
- [[https://github.com/jorgenschaefer/elpy#quick-installation][Elpy]] (allows me to install the Elpy Python development environment)

#+begin_src emacs-lisp
  (after-load 'package
    (setq package-archives
          '(("gnu"          . "http://elpa.gnu.org/packages/")
            ("melpa"        . "http://melpa.org/packages/")
            ("melpa-stable" . "http://stable.melpa.org/packages/")
            ("elpy"         . "http://jorgenschaefer.github.io/packages/"))))
#+end_src

**** Initialise package manager

Finally we initialise the package manager:

#+begin_src emacs-lisp
  (package-initialize)
#+end_src

*** diminish

[[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] removes or abbreviates the minor mode indicators that can clutter up
one's modeline.

#+begin_src emacs-lisp
  (require-package 'diminish)
#+end_src

Diminish =subword-mode=, =eldoc-mode=, and =auto-revert-mode=:

#+begin_src emacs-lisp
  (after-load 'diminish
    (after-load 'subword
      (diminish 'subword-mode))
    (after-load 'eldoc
      (diminish 'eldoc-mode))
    (after-load 'autorevert
      (diminish 'auto-revert-mode)))
#+end_src

Also, diminish some built-in modes:

#+begin_src emacs-lisp
  (after-load 'diminish
    (diminish 'overwrite-mode)
    (diminish 'global-whitespace-mode))
#+end_src

*** paradox

[[https://github.com/Bruce-Connor/paradox][paradox]] is an advanced package.el frontend with GitHub integration.

#+begin_src emacs-lisp
  (require-package 'paradox)
#+end_src

Force =paradox= into a [[fullframe]]:

#+begin_src emacs-lisp
  (after-load 'fullframe
    (fullframe paradox-list-packages paradox-quit-and-close nil))
#+end_src

Automatically 'star' packages on GitHub after I install them (so I can easily
follow changes to them):

#+begin_src emacs-lisp
  (setq paradox-automatically-star t)
#+end_src

Add launch command:

#+begin_src emacs-lisp
  (smf/add-launcher "p" 'paradox-list-packages)
#+end_src

**** async mode

Paradox now [[https://github.com/Bruce-Connor/paradox/commit/e341a900609974802ad92d5bb43083fcf83ef432#diff-2d43bf4d9c7b9686d0895974900dfd05R18][supports an asynchronous mode]] which requires the =async= package:

#+begin_src emacs-lisp
  (require-package 'async)
  (setq paradox-execute-asynchronously t)
#+end_src

*** exec-path-from-shell

OS X doesn't use the environment variables available in a shell in a GUI
environment ([[https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/EnvironmentVars.html][more here]]).

Since Emacs runs shell commands regularly it's important that the same =PATH= is
available to my editor as [[http://brew.sh][Homebrew]] etc. set and use.

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] is a package that copies across =PATH= and other variables
to the Emacs environment.

I only want this to be installed and enabled on OS X.

#+begin_src emacs-lisp
  (when (and (eq system-type 'darwin) (display-graphic-p))
    (require-package 'exec-path-from-shell)
    (setq exec-path-from-shell-variables '("PATH"  "MANPATH" "SHELL"))
    (exec-path-from-shell-initialize))
#+end_src

*** smex

[[https://github.com/nonsequitur/smex][smex]] is an advanced completion mode for =execute-extended-command= (usually
known as =M-x=).

#+begin_src emacs-lisp
  (require-package 'smex)
#+end_src

Replace =execute-extended-command='s keyboard shortcuts:

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap execute-extended-command] 'smex)
#+end_src

Make sure we stop the annoying "click this menubar" advice in the buffer:

#+begin_src emacs-lisp
  (setq-default smex-key-advice-ignore-menu-bar t)
#+end_src

Move =smex='s cache file out of the home directory:

#+begin_src emacs-lisp
  (setq smex-save-file (expand-file-name ".smex-items" smf/tmp-local-dir))
#+end_src

*** fullframe

[[https://github.com/tomterl/fullframe][fullframe]] is a minor mode which allows certain buffers to take over the full
frame using advice.

#+begin_src emacs-lisp
  (require-package 'fullframe)
#+end_src

*** ido-ubiquitous

[[https://github.com/DarwinAwardWinner/ido-ubiquitous][ido-ubiquitous]] mode enables ido in many more places than the default ido setup:

#+begin_src emacs-lisp
  (require-package 'ido-ubiquitous)
  (ido-ubiquitous-mode 1)
#+end_src

Unicode lists are much, much larger than the default max of 30,000 so we set to
50,000.

#+begin_src emacs-lisp
  (setq ido-ubiquitous-max-items 50000)
#+end_src

Also, let's add bringing up a unicode list to our launcher.

#+begin_src emacs-lisp
  (smf/add-launcher "U" 'insert-char)
#+end_src

*** ido-vertical

[[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertical]] mode renders the ido prompt vertically instead of horizontally. I
find this easier to read.

#+begin_src emacs-lisp
  (require-package 'ido-vertical-mode)
  (ido-vertical-mode) ;; autoloaded
  (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
#+end_src

Because it's displayed vertically and I want to save screen real estate, I want
to reduce the maximum number of candidates ido displays:

#+begin_src emacs-lisp
  (setq ido-max-prospects 5)
#+end_src

*** flx-ido

[[https://github.com/lewang/flx][flx-ido]] is an advanced flex-matching algorithm that's significantly faster and
more accurate than the built-in method.

#+begin_src emacs-lisp
  (require-package 'flx-ido)
#+end_src

The =flx-ido= documentation suggests upping the threshold at which GC occurs
within Emacs so that =flx= can cache its candidate lists for longer:

#+begin_src emacs-lisp
  (setq gc-cons-threshold 20000000)
#+end_src

Finally we cause =flx-ido-mode= to take over ido:

#+begin_src emacs-lisp
  (flx-ido-mode 1)
#+end_src

*** ace-jump-mode

[[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] allows one to jump around the buffer to named characters (it's
easier to watch the video on that link than explain).

#+begin_src emacs-lisp
  (require-package 'ace-jump-mode)
#+end_src

Bind it:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c SPC") 'ace-jump-char-mode)
  (global-set-key (kbd "C-<return>") 'ace-jump-line-mode)
  (smf/add-launcher "j" 'ace-jump-char-mode)
  (smf/add-launcher "J" 'ace-jump-line-mode)
#+end_src

*** popwin

[[https://github.com/m2ym/popwin-el][popwin]] is a popup window manager that helps make the behaviour of compilation
buffers, search buffers etc. a bit more sane.

#+begin_src emacs-lisp
  (require-package 'popwin)
#+end_src

As well as the defaults, I want [[ag]], [[flycheck]] and [[http://www.emacswiki.org/emacs/OccurMode][occur]] to 'pop'. I don't want to
auto-select the =Compile-Log= process buffer as it's for information only.

#+begin_src emacs-lisp
  (after-load 'popwin
    (add-to-list 'popwin:special-display-config `"*ag search*")
    (add-to-list 'popwin:special-display-config `"*Flycheck errors*")
    (add-to-list 'popwin:special-display-config `"*Occur*")
    (add-to-list 'popwin:special-display-config `("*Compile-Log*" :noselect t)))
#+end_src

Load [[popwin]] and configure keyboard shortcuts:

#+begin_src emacs-lisp
  (require 'popwin)
  (popwin-mode 1)
  (global-set-key (kbd "C-c P") 'popwin:popup-last-buffer)
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-P") 'popwin:popup-last-buffer))
#+end_src

*** ag

[[https://github.com/Wilfred/ag.el][ag]] is an Emacs frontend to [[https://github.com/ggreer/the_silver_searcher][the ag command]], a grep-like code-searching tool. It's
installed via Homebrew on my Mac.

#+begin_src emacs-lisp
  (require-package 'ag)
#+end_src

Set up some key bindings:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c f") 'ag-project)
  (global-set-key (kbd "C-c a") 'ag)
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-F") 'ag-project)
    (global-set-key (kbd "s-A") 'ag))
  (smf/add-launcher "a" 'ag-project)
  (smf/add-launcher "A" 'ag)
#+end_src

Make sure that we re-use the =ag= buffers - without this my buffer list is full
of buffers named after the project root.

#+begin_src emacs-lisp
  (setq ag-reuse-buffers t)
#+end_src

Highlight search results using =isearch= highlight faces (otherwise it just
copies them from the shell):

#+begin_src emacs-lisp
  (setq ag-highlight-search t)
  (add-hook 'ag-mode-hook
            (lambda ()
              (copy-face 'lazy-highlight 'ag-match-face)))
#+end_src

*** projectile

[[https://github.com/bbatsov/projectile][projectile]] is a minor mode for performing commands over a single 'project' or
grouping of files.

#+begin_src emacs-lisp
  (require-package 'projectile)
  (projectile-global-mode)
#+end_src

I want my keyboard shortcuts to be the same in Projectile as in non-Projectile
buffers, so do some remapping:

#+begin_src emacs-lisp
  (after-load 'projectile
    (define-key projectile-mode-map [remap ag-project] 'projectile-ag))
#+end_src

Since I use =ag=, always use that instead of =grep=:

#+begin_src emacs-lisp
  (after-load 'projectile
    (define-key projectile-mode-map [remap projectile-grep] 'projectile-ag))
#+end_src

Also define a convenience keyboard shortcut to switch between buffers from the same project:

#+begin_src emacs-lisp
  (after-load 'projectile
    (global-set-key (kbd "s-b") 'projectile-switch-to-buffer)
    (global-set-key (kbd "C-x 4 s-b") 'projectile-switch-to-buffer-other-window)
    (smf/add-launcher "s" 'projectile-switch-project))
#+end_src

#+begin_src emacs-lisp
  (after-load 'projectile
    (diminish 'projectile-mode))
#+end_src

*** solarized-theme

I used to use the [[http://ethanschoonover.com/solarized][solarized]] dark theme in my editor. Specifically, I use the
[[https://github.com/bbatsov/solarized-emacs]] variant as it has the best support
for the major modes I use, and is the most up to date. Previously I used
[[https://github.com/sellout/emacs-color-theme-solarized][sellout's variant]] as it has much better terminal support, but it hasn't been
updated seriously in years and it fell behind for modern modes.

#+begin_src emacs-lisp
  (require-package 'solarized-theme)
#+end_src

Since it doesn't work well with my terminal theme (also Solarized Dark), I only
want to enable it on graphical displays (see [[Themes]]). I also want to make sure I set the
modeline to be high contrast (reversed out):

#+begin_src emacs-lisp
  (setq solarized-high-contrast-mode-line t)
#+end_src

*** zenburn-theme

I use the [[https://github.com/bbatsov/zenburn-emacs][zenburn-theme]] as my Emacs theme as it has excellent coloring
(see [[Themes]]):

#+begin_src emacs-lisp
  (require-package 'zenburn-theme)
#+end_src

*** moe-theme

#+begin_src emacs-lisp
  (require-package 'moe-theme)
  (require 'moe-theme)
  (setq moe-theme-highlight-buffer-id t)
#+end_src

*** ample-theme

#+begin_src emacs-lisp
  (require-package 'ample-theme)
  (load-theme 'ample t t)
  (load-theme 'ample-flat t t)
  (load-theme 'ample-light t t)
#+end_src

*** base16-theme

The [[https://github.com/neil477/base16-emacs][base16]] themes are very compatible with terminals. I use the [[http://chriskempson.github.io/base16/#default][default]]
theme.

#+begin_src emacs-lisp
  (require-package 'base16-theme)
#+end_src

*** undo-tree

[[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree-mode]], a mode which allows one to visualise their undo/redo history:

#+begin_src emacs-lisp
  (require-package 'undo-tree)
  (global-undo-tree-mode 1)
#+end_src

Also, diminish this mode:

#+begin_src emacs-lisp
  (after-load 'undo-tree
    (diminish 'undo-tree-mode))
#+end_src

*** smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] is a [[paredit]] like minor-mode for many more things than just Lisp.

=show-smartparens-mode= is a replacement mode for =show-paren-mode=.

#+begin_src emacs-lisp
  (require-package 'smartparens)
  (require 'smartparens-config)
  (show-smartparens-global-mode 1)
#+end_src

*** gtags

Experiment with gtags.

#+begin_src emacs-lisp
  (require-package 'ggtags)
#+end_src

I already have the project name from [[projectile]] so let's remove the ggtags
project name,

#+begin_src emacs-lisp
  (setq ggtags-mode-line-project-name nil)
#+end_src

And, finally, load it for c-like modes,

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                (ggtags-mode 1))))
#+end_src

*** company

[[https://github.com/company-mode/company-mode][company-mode]] is a modern and modular completion framework (the other one Emacs
people use is [[http://www.emacswiki.org/emacs/AutoComplete][autocomplete]]. I chose =company= because it's well-maintained and
has better code for integrating with).

**** configuration

I don't want =company= to auto-start - it should only pop when I ask for it:

#+begin_src emacs-lisp
  (after-load 'company
    (setq company-idle-delay nil))
#+end_src

I want it to attempt a completion immediately after a =.= character - without
this I need a few characters before it'll show candidates:

#+begin_src emacs-lisp
  (after-load 'company
    (setq company-minimum-prefix-length 0))
#+end_src

Show candidates immediately rather than waiting:

#+begin_src emacs-lisp
  (after-load 'company
    (setq company-echo-delay 0))
#+end_src

Make the lighter shorter:

#+begin_src emacs-lisp
  (after-load 'company
    (after-load 'diminish
      (diminish 'company-mode "com")))
#+end_src

**** enable company mode in programming buffers only

Define a function to enable company-mode and overwrite [[hippie]]'s key binding for
the local buffer only (this means I can use the same key binding for completion
no matter which minor mode I'm using):

#+begin_src emacs-lisp
  (defun smf/enable-company-mode ()
    "Enables company-mode and overloads hippie-expand's binding"
    (company-mode 1)
    (define-key (current-local-map) [remap dabbrev-expand] 'company-complete))
#+end_src

Add this function to any modes derived from =prog-mode=:

#+begin_src emacs-lisp
  (after-load 'company
    (add-hook 'prog-mode-hook 'smf/enable-company-mode))
#+end_src

**** Install and load company

#+begin_src emacs-lisp
  (require-package 'company)
  (require 'company)
#+end_src

*** flycheck

[[https://github.com/flycheck/flycheck][flycheck]] is a modern, more easily customisable version of [[http://www.emacswiki.org/emacs/FlyMake][flymake]]. It's used to
perform on-the-fly syntax checking and linting.

#+begin_src emacs-lisp
  (require-package 'flycheck)
  (after-load 'flycheck
    (setq
     ;; don't show anything in the left fringe
     flycheck-indication-mode nil))
  (require 'flycheck)
#+end_src

Also, we add some keymaps,

#+begin_src emacs-lisp
  (eval-after-load 'flycheck
    '(progn
       (define-key flycheck-mode-map (kbd "H->") 'flycheck-next-error)
       (define-key flycheck-mode-map (kbd "H-<") 'flycheck-previous-error)))
#+end_src

*** puppet-mode

[[https://github.com/lunaryorn/puppet-mode][puppet-mode]] is a major mode for editing =.pp= files.

#+begin_src emacs-lisp
  (require-package 'puppet-mode)
#+end_src

*** markdown-mode

[[http://melpa.milkbox.net/#/markdown-mode][markdown-mode]] is a major mode for editing Markdown files.

#+begin_src emacs-lisp
  (require-package 'markdown-mode)
#+end_src

There's no official Markdown file extension, so support all the unofficial ones:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.ft$" . markdown-mode)) ;; FoldingText
#+end_src

*** web-mode

[[https://github.com/fxbois/web-mode][web-mode]] is a major mode for editing templates and HTML. It supports a very
broad range of template languages and is highly configurable.

#+begin_src emacs-lisp
  (require-package 'web-mode)
#+end_src

[[http://jinja.pocoo.org/docs/][Jinja]] templates are mostly like [[https://docs.djangoproject.com/en/dev/topics/templates/][Django templates]], so just force them to behave
like that:

#+begin_src emacs-lisp
  (after-load 'web-mode
    (setq web-mode-engines-alist
          '(("\\.jinja\\'" . "django"))))
#+end_src

Enable [[web-mode]] by default for several common file extensions:

#+begin_src emacs-lisp
  (dolist (alist '(("\\.html$'" . web-mode)
                   ("\\.html\\.erb$" . web-mode)
                   ("\\.mustache$" . web-mode)
                   ("\\.jinja$" . web-mode)
                   ("\\.php$" . web-mode)))
    (add-to-list 'auto-mode-alist alist))
#+end_src

*** idomenu

[[http://melpa.milkbox.net/#/idomenu][idomenu]] offers [[ido]] completion over [[http://www.emacswiki.org/emacs/ImenuMode][imenu]] candidates. It allows me to navigate
through classes etc. using completion for methods.

#+begin_src emacs-lisp
  (require-package 'idomenu)
#+end_src

Add it to my launcher:

#+begin_src emacs-lisp
  (smf/add-launcher "i" 'idomenu)
#+end_src

Automatically rescan the current file so =imenu= is up to date:

#+begin_src emacs-lisp
  (setq imenu-auto-rescan t)
#+end_src

*** yaml-mode

Regrettably I need to occasionally edit [[http://www.yaml.org][YAML]].

#+begin_src emacs-lisp
  (require-package 'yaml-mode)
#+end_src

*** Whole line or region

It's very convenient to select the whole line when no region is active.

#+begin_src emacs-lisp
  (require-package 'whole-line-or-region)
  (whole-line-or-region-mode)
#+end_src

Also, diminish this mode:

#+begin_src emacs-lisp
  (after-load 'diminish
    (diminish 'whole-line-or-region-mode))
#+end_src


*** cycle buffer

I find cycling buffers with =ctrl-tab= very fast and convenient. For that, I use
[[https://github.com/martinp26/cycbuf][cycbuf]], so let's install and load that. I don't want the default key bindings so
we call 'cycbuf-init'.

#+begin_src emacs-lisp
  (require-package 'cycbuf)
  (require 'cycbuf)
#+end_src

I prefer to just cycle without seeing a list, so set the delay to zero (i.e.
never show it).

#+begin_src emacs-lisp
  (setq cycbuf-clear-delay 0)
#+end_src

Modern OSes sort applications by last recently used, so we also copy that behavior.

#+begin_src emacs-lisp
  (setq cycbuf-buffer-sort-function 'cycbuf-sort-by-recency)
#+end_src

Also, I don't want to cycle through Emacs internal buffers, so I filter out
buffers that start and end with an asterisk.

#+begin_src emacs-lisp
  (setq cycbuf-dont-show-regexp
        '("^ "
          "^\\*cycbuf\\*$"
          "^\\*.*\\*"))
#+end_src

Remap the default keybinding to =ctrl-tab= for next buffer and =ctrl-shift-tab=
for previous buffer.

#+begin_src emacs-lisp
  (global-set-key [(control tab)] 'cycbuf-switch-to-next-buffer)
  (global-set-key [(control shift tab)] 'cycbuf-switch-to-previous-buffer)
#+end_src

Finally, unset =org-mode='s =ctrl-tab= binding.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (define-key org-mode-map [(control tab)] nil)))
#+end_src

*** crosshairs

Highlights both the line and the column.

#+begin_src emacs-lisp
  (require-package 'crosshairs)
#+end_src

Always enable this mode and bind =C-|= to highlight the column

#+begin_src emacs-lisp
  (global-hl-line-mode)
  (global-hl-line-highlight)
  (global-set-key (kbd "C-|") 'column-highlight-mode)
#+end_src

*** hungry-delete

=hungry-delete= will delete all whitespace forward or backward.

#+begin_src emacs-lisp
  (require-package 'hungry-delete)
  (global-set-key (kbd "<H-backspace>") 'hungry-delete-backward)
  (global-set-key (kbd "H-d") 'hungry-delete-forward)
#+end_src

*** alert

A Growl-like alerts notifier for Emacs.

#+begin_src emacs-lisp
  (require-package 'alert)
#+end_src

On the mac, we'll use the [[https://github.com/alloy/terminal-notifier][terminal-notifier]] to integrate with [[http://en.wikipedia.org/wiki/Notification_Center][Notification Center]].

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq alert-default-style 'notifier))
#+end_src

*** sauron

Event log for emacs. We'll use =alert.el= as the backend so it's integrated with
the host system. Also, we'll try to use sauron in a "pop-up" way, i.e. no
separate frame.

#+begin_src emacs-lisp
  (require-package 'sauron)
  (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)
  (setq sauron-separate-frame nil)
  (push #'sauron-start after-init-hook)
  (smf/add-launcher "n" 'sauron-toggle-hide-show)
#+end_src

*** d-mode

An Emacs major mode for editing D code.

#+begin_src emacs-lisp
  (require-package 'd-mode)
  (add-to-list 'auto-mode-alist '("\\.d[i]?\\'" . d-mode))
#+end_src

*** hideshowvis

Enables collapsable regions and diminish the mode:

#+begin_src emacs-lisp
  (require-package 'hideshowvis)
  (defun smf/prog-mode-hook ()
    (hideshowvis-enable)
    (diminish 'hs-minor-mode))
  (add-hook 'prog-mode-hook 'smf/prog-mode-hook)
#+end_src

*** smart-mode-line

Really cool and useful plugin that changes your mode-line into a very readable
information bar. It is unfortunate that this plugin has almost the same initials
as me.

#+begin_src emacs-lisp
  (require-package 'smart-mode-line)
  (require-package 'smart-mode-line-powerline-theme)
#+end_src

Here we set modes that I don't care about and want hidden,

#+begin_src emacs-lisp
  (setq sml/hidden-modes " \\(Projectile.*\\|hs\\|yas\\|Undo-Tree\\|Fly\\|Filladapt\\|WLR\\|AC\\|WS\\|MML\\)")
#+end_src

Also, I don't want to be prompted for trusting the theme to run lisp code,

#+begin_src emacs-lisp
  (setq sml/no-confirm-load-theme t)
#+end_src

I usually alternate between the 'powerline' theme and the 'respectful' theme.
'powerline' has better delimiters but harsher colors. 'respectful' has better
colors integrated with your current theme therefore I can look at it for longer
periods of time.

#+begin_src emacs-lisp
;;  (sml/setup)
;;  (sml/apply-theme 'powerline)
;;  (sml/apply-theme 'respectful)
#+end_src

*** which-func

=which-func= is a handy mode to display which function you're currently in. I
don't like the '[' and ']' brackets around the function, and also like unknown
functions to be an empty string so [[powerline]] looks even better.

#+begin_src emacs-lisp
  (which-function-mode)
  (setq which-func-unknown "")
  (setq which-func-format
        `((:propertize which-func-current local-map ,which-func-keymap
                       face which-func
                       mouse-face mode-line-highlight
                       help-echo "mouse-1: go to beginning\n\
    mouse-2: toggle rest visibility\n\
    mouse-3: go to end")))
#+end_src

Alternately, I could prefix the function name with "ƒₓ" but I defer that for now.

*** powerline

I use [[https://github.com/milkypostman/powerline][powerline]] to format my modeline.

#+begin_src emacs-lisp
  (require-package 'powerline)
#+end_src

First, we add a method for determining if we should ignore a buffer based on
its name,

#+begin_src emacs-lisp
  (defun smf/ignore-buffer (bname)
    (cond
     ((string-match "^\\*.*\\*$" bname) t)
     ((string-match "freenode$" bname) t)
     ((string-match "BitlBee$" bname) t)
     ((string-match "nil$" bname) t)
     ((string-match "^\\*mu4u" bname) t)
     ((string-match "^Upgrade:" bname) t)))
#+end_src

Change =powerline-buffer-id= to include modified and read-only status,

#+begin_src emacs-lisp
  (defpowerline powerline-buffer-id
    (let ((bname (powerline-trim (format-mode-line mode-line-buffer-identification))))
      (concat
       (concat
        (if (buffer-modified-p)
            (cond
             ((smf/ignore-buffer bname) "")
             (t "●"))
          "")
        (if buffer-read-only
            (cond
             ((smf/ignore-buffer bname) "")
             (t "⌀"))
          "")
        bname))))
#+end_src

Add a new method that returns the projectile project name (or an empty string),

#+begin_src emacs-lisp
  (defpowerline powerline-projectile-name
    (let ((pname (powerline-trim (projectile-project-name)))
          (bname (powerline-trim (format-mode-line mode-line-buffer-identification))))
      (cond
       ((string= pname "-") "")
       ((smf/ignore-buffer bname) "")
       (t (format " %s " pname)))))
#+end_src

Define some helper methods and override powerline-vc to display Mercurial
bookmarks (falling back to named branches),

#+begin_src emacs-lisp
  (defun smf/get-string-from-file (filePath)
    "Return filePath's file content."
    ;; NOTE: `insert-file-content' sets `deactivate-mark' to t which makes
    ;; `smf/get-string-from-file' always deactivate the mark after activating it
    ;; as this triggers mode line updates. This has been fixed in emacs as of
    ;; 20150814.
    (let* (deactivate-mark)
      (ignore-errors
        (with-temp-buffer
          (insert-file-contents filePath)
          (buffer-string)))))

  (defun smf/get-hg-branch-bookmark (root)
    (let ((book (smf/get-string-from-file
                 (concat root "/.hg/bookmarks.current")))
          (branch (smf/get-string-from-file
                   (concat root "/.hg/branch"))))
      (cond
       (book book)
       (branch branch)
       ((not root) "")
       (t "default"))))

  (defpowerline powerline-vc
    (when (buffer-file-name (current-buffer))
      (let ((gitbranch (condition-case nil
                           (magit-get-current-branch)
                         (error nil)))
            (hgroot (condition-case nil
                        (ahg-root)
                      (error nil))))
        (when (or gitbranch hgroot)
          (let ((branch (if gitbranch gitbranch
                          (smf/get-hg-branch-bookmark hgroot))))
            (format " %s %s"
                    (char-to-string #xe0a0)
                    (powerline-trim branch)))))))
#+end_src

To add more powerline sections, we need to define some more faces.

#+begin_src emacs-lisp
  (defface powerline-active3 '((t (:background "grey40" :inherit mode-line)))
    "Powerline face 3."
    :group 'powerline)

  (defface powerline-inactive3
    '((t (:background "grey20" :inherit mode-line-inactive)))
    "Powerline face 3."
    :group 'powerline)

  (defface powerline-active4 '((t (:background "grey22" :inherit mode-line)))
    "Powerline face 1."
    :group 'powerline)

  (defface powerline-inactive4
    '((t (:background "grey11" :inherit mode-line-inactive)))
    "Powerline face 1."
    :group 'powerline)
#+end_src

Currently, I just add colors for the blue [[moe-theme]]. This function is a
straight copy from =moe-theme.el= but the 'dark 'blue colors are tweaked.

#+begin_src emacs-lisp
  (defun powerline-moe-theme ()
    "Powerline theme powered by moe-theme.el
  It's recommended use this with `moe-light' or `moe-dark', but it's ok without them,
  as long as setq `moe-theme-mode-line-color' first."
    (interactive)
    (cond ((eq (frame-parameter nil 'background-mode) 'light)
           (set-face-attribute 'mode-line-buffer-id nil :background nil :foreground "#1c1c1c")
           (set-face-attribute 'mode-line-inactive nil :background "#b2b2b2" :foreground "#ffffff")
           (set-face-attribute 'powerline-active2 nil :background "#585858" :foreground "#ffffff")
           (set-face-attribute 'powerline-inactive1 nil :background "#c6c6c6" :foreground "#585858")
           (set-face-attribute 'powerline-inactive2 nil :background "#e4e4e4" :foreground "#585858")
           (cond ((eq moe-theme-mode-line-color 'blue)
                  (set-face-attribute 'mode-line nil :background "#5fafd7" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#afd7ff" :foreground "#005faf"))
                 ((eq moe-theme-mode-line-color 'green)
                  (set-face-attribute 'mode-line nil :background "#a1db00" :foreground "#005f00")
                  (set-face-attribute 'powerline-active1 nil :background "#d7ff87" :foreground "#008700"))
                 ((eq moe-theme-mode-line-color 'orange)
                  (set-face-attribute 'mode-line nil :background "#ff8700" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#ffd787" :foreground "#d75f00"))
                 ((eq moe-theme-mode-line-color 'magenta)
                  (set-face-attribute 'mode-line nil :background "#ff4ea3" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#ffafff" :foreground "#ff1f8b"))
                 ((eq moe-theme-mode-line-color 'yellow)
                  (set-face-attribute 'mode-line nil :background "#fce94f" :foreground "#875f00")
                  (set-face-attribute 'powerline-active1 nil :background "#ffff87" :foreground "#875f00"))
                 ((eq moe-theme-mode-line-color 'purple)
                  (set-face-attribute 'mode-line nil :background "#af5fd7" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#e6a8df" :foreground "#6c0099"))
                 ((eq moe-theme-mode-line-color 'red)
                  (set-face-attribute 'mode-line nil :background "#ff4b4b" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#ffafaf" :foreground "#cc0000"))
                 ((eq moe-theme-mode-line-color 'cyan)
                  (set-face-attribute 'mode-line nil :background "#5faf87" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#87d7af" :foreground "#005f5f"))
                 ((eq moe-theme-mode-line-color 'w/b)
                  (set-face-attribute 'mode-line nil :background "#1c1c1c" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#bcbcbc" :foreground "#3a3a3a")
                  (set-face-attribute 'mode-line-buffer-id nil :background nil :foreground "#ffffff"))))
          ((eq (frame-parameter nil 'background-mode) 'dark)
           (set-face-attribute 'mode-line-buffer-id nil :background nil :foreground "#080808")
           (set-face-attribute 'mode-line-inactive nil :background "#4e4e4e" :foreground "#9e9e9e")
           (set-face-attribute 'powerline-active4 nil :background "#ffffff" :foreground "#3a3a3a")
           (set-face-attribute 'powerline-inactive1 nil :background "#626262" :foreground "#e4e4e4")
           (set-face-attribute 'powerline-inactive2 nil :background "#6c6c6c" :foreground "#eeeeee")
           (set-face-attribute 'powerline-inactive3 nil :background "#767676" :foreground "#d3d3d3")
           (set-face-attribute 'powerline-inactive4 nil :background "#828282" :foreground "#e4e4e4")
           (cond ((eq moe-theme-mode-line-color 'blue)
                  (set-face-attribute 'powerline-active1 nil :background "#87c3eb" :foreground "#005faf")
                  (set-face-attribute 'powerline-active3 nil :background "#d1e9ff" :foreground "#005faf")
                  (set-face-attribute 'mode-line nil :background "#5fafd7" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active2 nil :background "#afd7ff" :foreground "#005faf"))
                 ((eq moe-theme-mode-line-color 'green)
                  (set-face-attribute 'mode-line nil :background "#a1db00" :foreground "#005f00")
                  (set-face-attribute 'powerline-active1 nil :background "#d7ff87" :foreground "#008700"))
                 ((eq moe-theme-mode-line-color 'orange)
                  (set-face-attribute 'mode-line nil :background "#ff8700" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#ffd787" :foreground "#d75f00"))
                 ((eq moe-theme-mode-line-color 'magenta)
                  (set-face-attribute 'mode-line nil :background "#ff4ea3" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#ffafff" :foreground "#ff1f8b"))
                 ((eq moe-theme-mode-line-color 'yellow)
                  (set-face-attribute 'mode-line nil :background "#fce94f" :foreground "#875f00")
                  (set-face-attribute 'powerline-active1 nil :background "#ffff87" :foreground "#875f00"))
                 ((eq moe-theme-mode-line-color 'purple)
                  (set-face-attribute 'mode-line nil :background "#af5fd7" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#e6a8df" :foreground "#6c0099"))
                 ((eq moe-theme-mode-line-color 'red)
                  (set-face-attribute 'mode-line nil :background "#ff4b4b" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#ffafaf" :foreground "#cc0000"))
                 ((eq moe-theme-mode-line-color 'cyan)
                  (set-face-attribute 'mode-line nil :background "#5faf87" :foreground "#ffffff")
                  (set-face-attribute 'powerline-active1 nil :background "#87d7af" :foreground "#005f5f"))
                 ((eq moe-theme-mode-line-color 'w/b)
                  (set-face-attribute 'mode-line nil :background "#ffffff" :foreground "#080808")
                  (set-face-attribute 'powerline-active1 nil :background "#bcbcbc" :foreground "#3a3a3a")
                  (set-face-attribute 'mode-line-buffer-id nil :background nil :foreground "#3a3a3a")))))
    (powerline-default-theme)
    (powerline-reset)
    (setq moe-theme-powerline-enable-p t))
#+end_src

#+begin_src emacs-lisp
  (defun powerline-default-theme ()
    "Setup the default mode-line."
    (interactive)
    (setq-default mode-line-format
                  '("%e"
                    (:eval
                     (let* ((active (powerline-selected-window-active))
                            (mode-line (if active 'mode-line 'mode-line-inactive))
                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                            (face3 (if active 'powerline-active3 'powerline-inactive3))
                            (face4 (if active 'powerline-active4 'powerline-inactive4))
                            (separator-left (intern (format "powerline-%s-%s"
                                                            (powerline-current-separator)
                                                            (car powerline-default-separator-dir))))
                            (separator-right (intern (format "powerline-%s-%s"
                                                             (powerline-current-separator)
                                                             (cdr powerline-default-separator-dir))))
                            (lhs (list (powerline-raw (powerline-projectile-name) mode-line)
                                       (funcall separator-left mode-line face1)
                                       (powerline-buffer-id face1 'l)
                                       (powerline-raw " " face1)
                                       (funcall separator-left face1 face2)
                                       (powerline-major-mode face2 'l)
                                       (powerline-process face2)
                                       (powerline-minor-modes face2 'l)
                                       (powerline-narrow face2 'l)
                                       (powerline-raw " " face2)
                                       (funcall separator-left face2 face3)
                                       (when (and (boundp 'which-func-mode) which-func-mode)
                                         (powerline-raw (which-function) face3 'l))
                                       (powerline-raw " " face3)
                                       (funcall separator-left face3 face4)
                                       (powerline-vc face4 'r)
                                       (when (bound-and-true-p nyan-mode)
                                         (powerline-raw (list (nyan-create)) face4 'l))))
                            (rhs (list (powerline-raw global-mode-string face4 'r)
                                       (funcall separator-right face4 face3)
                                       (powerline-raw (char-to-string #xe0a1) face3 'l)
                                       (powerline-raw "%l:%c " face3 'l)
                                       (funcall separator-right face3 mode-line)
                                       (when (boundp 'erc-modified-channels-object)
                                         (powerline-raw erc-modified-channels-object mode-line))
                                       (when powerline-display-hud
                                         (powerline-hud face4 face2)))))
                       (concat (powerline-render lhs)
                               (powerline-fill face4 (powerline-width rhs))
                               (powerline-render rhs)))))))
#+end_src

*** rainbow-mode

=rainbow-mode= is a minor mode for Emacs which displays strings representing
colors with the color they represent as background.

#+begin_src emacs-lisp
  (require-package 'rainbow-mode)
#+end_src

=rainbow-mode= doesn't have a global method, so we'll add a css hook for it,

#+begin_src emacs-lisp
  (add-hook 'css-mode-hook 'rainbow-mode)
#+end_src

*** less-css-mode

=less-css-mode= is a major mode for Emacs which displays strings representing
colors with the color they represent as background.

#+begin_src emacs-lisp
  (require-package 'less-css-mode)
#+end_src

*** rainbow-delimiters

=rainbow-delimiters= is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their depth.

#+begin_src emacs-lisp
  (require-package 'rainbow-delimiters)
#+end_src

Add =rainbow-delimiters= to all programming modes,

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_src

*** rainbow-blocks

=rainbow-blocks= is an Emacs mode that highlights blocks made of parentheses,
brackets, and braces according to their depth.

#+begin_src emacs-lisp
  (require-package 'rainbow-blocks)
#+end_src

Add =rainbow-blocks= to programming modes,

#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'rainbow-blocks-mode)
  (add-hook 'lisp-interaction-mode-hook 'rainbow-blocks-mode)
#+end_src

and diminish the mode:

#+begin_src emacs-lisp
  (after-load 'rainbow-blocks
    (after-load 'diminish
      (diminish 'rainbow-blocks-mode)))
#+end_src

*** elpy

=elpy= is an Emacs package to bring powerful Python editing to Emacs. It
combines a number of other packages, both written in Emacs Lisp as well as
Python.

To being with, we'll need the following dependecies installed,

#+begin_src sh :tangle no
  # Either of these
  pip install rope
  pip install jedi
  # And flake8 for code checks
  pip install flake8
#+end_src

Now, we install elpy and enable it,

#+begin_src emacs-lisp
  (require-package 'elpy)
  (elpy-enable)
#+end_src

By default, elpy binds M-<left> and M-<right>, which I use for navigation, for
indenting / de-indenting code. Let's change that,

#+begin_src emacs-lisp
  (defun smf/elpy-hook ()
    (define-key elpy-mode-map (kbd "<M-left>") nil)
    (define-key elpy-mode-map (kbd "<M-right>") nil)
    (define-key elpy-mode-map (kbd "<H-M-left>") 'elpy-nav-move-iblock-left)
    (define-key elpy-mode-map (kbd "<H-M-right>") 'elpy-nav-move-iblock-right))
  (add-hook 'elpy-mode-hook 'smf/elpy-hook)
#+end_src

Add [[elpy]] to diminish,

#+begin_src emacs-lisp
    (defun smf/diminish-elpy-hook ()
      (diminish 'highlight-indentation-mode)
      (diminish 'elpy-mode))
    (add-hook 'elpy-mode-hook 'smf/diminish-elpy-hook)
#+end_src

*** yasnippet

YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates. Bundled language templates
include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The
snippet syntax is inspired from [[http://manual.macromates.com/en/snippets][TextMate's]] syntax.

#+begin_src emacs-lisp
  (require-package 'yasnippet)
#+end_src

#+begin_src emacs-lisp
  (setq yas/root-directory (smf/join-dirs smf/dotfiles-dir "snippets"))
  (yas-global-mode 1)
#+end_src

*** smart-tabs-mode

This mode provides code which improves on Emacs’ auto-indenting, so that
whenever you press the <tab> key, the appropriate amount of tabs and spaces is
inserted automatically. You can still use all spaces if you prefer, of course;
the code merely ensures that if you enable tabs (maybe when maintaining legacy
code), the tab size does not matter.

#+begin_src emacs-lisp
  (require-package 'smart-tabs-mode)
#+end_src

Enable smart-tabs-mode automatically for C and Javascript,

#+begin_src emacs-lisp
  (smart-tabs-insinuate 'c 'javascript)
#+end_src

*** guide-key

[[https://github.com/kai2nenobu/guide-key][guide-key]] shows a popup help window after a pressing defined keys for a short
delay.

#+begin_src emacs-lisp
  (require-package 'guide-key)
#+end_src

Enable it for my [[Launcher keymap]] prefix:

#+begin_src emacs-lisp
  (setq guide-key/guide-key-sequence '("C-x C-l" "C-c p" "C-x 4"))
  (guide-key-mode 1)
#+end_src

[[diminish]] =guide-key-mode=:

#+begin_src emacs-lisp
  (after-load 'diminish
    (diminish 'guide-key-mode))
#+end_src

*** browse-kill-ring

[[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]] allows one to browse the kill ring history when yanking.

#+begin_src emacs-lisp
  (require-package 'browse-kill-ring)
#+end_src

remap =yank-pop=:

#+begin_src emacs-lisp
  (define-key (current-global-map) [remap yank-pop] 'browse-kill-ring)
#+end_src

make =browse-kill-ring= act like =yank-pop= by overwriting the previous yank:

#+begin_src emacs-lisp
  (after-load 'browse-kill-ring
    (setq browse-kill-ring-replace-yank t))
#+end_src

*** narrow-indirect

[[http://www.emacswiki.org/emacs/narrow-indirect.el][narrow-indirect]] allows one to focus a buffer onto some particular code in
another window, editing it separately from its original context ([[http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/][a better
description of this workflow]]).

#+begin_src emacs-lisp
  (require-package 'narrow-indirect)
#+end_src

*** dtrt-indent

[[https://github.com/jscheid/dtrt-indent][dtrt-indent]] is an Emacs minor mode that guesses the indentation offset
originally used for creating source code files and transparently adjusts the
corresponding settings in Emacs, making it more convenient to edit foreign
files.

#+begin_src emacs-lisp
  (require-package 'dtrt-indent)
#+end_src

*** editorconfig

[[https://github.com/editorconfig/editorconfig-core-c][EditorConfig]] makes it easy to maintain the correct coding style when switching
between different text editors and between different projects.

#+begin_src emacs-lisp
  (require-package 'editorconfig)
#+end_src

*** js2-mode

Improved JavaScript editing mode for GNU Emacs.

#+begin_src emacs-lisp
  (require-package 'js2-mode)
  (setq js2-basic-offset 2)
#+end_src

*** json-mode

Sure, why not.

#+begin_src emacs-lisp
  (require-package 'json-mode)
  (setq json-reformat:indent-width 2)
#+end_src

*** anzu

[[https://github.com/syohex/emacs-anzu][anzu]] provides enhancements to =isearch= and related tasks, particularly
providing counts and better replacement visualisation.

#+begin_src emacs-lisp
  (require-package 'anzu)
  (require 'anzu)
#+end_src

Enable [[anzu]] globally,

#+begin_src emacs-lisp
  (global-anzu-mode +1)
#+end_src

Use [[anzu]]'s better =query-replace= and =query-replace-regexp=:

#+begin_src emacs-lisp
    (define-key (current-global-map) [remap query-replace] 'anzu-query-replace)
    (define-key (current-global-map) [remap query-replace-regexp]
      'anzu-query-replace-regexp)
#+end_src

Hide [[anzu]]'s mode,

#+begin_src emacs-lisp
  (after-load 'diminish
    (diminish 'anzu-mode))
#+end_src

*** move-text

#+begin_src emacs-lisp
  (require-package 'move-text)
  (move-text-default-bindings)
#+end_src

*** aHg

#+begin_src emacs-lisp
  (if (file-accessible-directory-p "~/projects/ahg")
      (smf/add-to-load-path "~/projects/ahg")
    (require-package 'ahg))
  (require 'ahg)
#+end_src

*** hg-test-mode

A mode for Mercurial test files

#+begin_src emacs-lisp
  (load "~/.emacs.d/hg-test-mode")
#+end_src

*** git-commit

#+begin_src emacs-lisp
(require-package 'git-commit)
(require 'git-commit)
#+end_src

*** magit

[[https://github.com/magit/magit][Magit]] is an Emacs interface to Git. It's very feature-rich and I find it
intuitive.

**** Keyboard shortcuts

=magit-status= is the main command to launch Magit. It's =autoloaded= so I don't
need to load Magit first.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c g") 'magit-status)
#+end_src

=magit-grep= isn't =autoloaded=, so I need to explicitly load it before binding
it:

#+begin_src emacs-lisp
  (autoload 'magit-grep "magit" "Grep for files" t)
  (global-set-key (kbd "C-c f") 'magit-grep)
#+end_src

**** Configuration

When performing a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]] within Magit, I'd like to use IDO:

#+begin_src emacs-lisp
  (setq magit-completing-read-function 'magit-ido-completing-read)
#+end_src

Open the =magit-status= buffer in the same window as the current buffer:

#+begin_src emacs-lisp
  (setq magit-status-buffer-switch-function 'switch-to-buffer)
#+end_src

Highlight individual word and letter changes when showing hunk diff overlays:

#+begin_src emacs-lisp
  (setq magit-diff-refine-hunk t)
#+end_src

Don't tell me when Magit reverts buffers:

#+begin_src emacs-lisp
  (setq magit-revert-buffers 'silent)
#+end_src

When Magit takes a while to call out to Git, pop the process buffer after 10
seconds so I can look for issues:

#+begin_src emacs-lisp
  (setq magit-process-popup-time 10)
#+end_src

Always show the =verbose= diff in commit windows:

#+begin_src emacs-lisp
  (setq magit-commit-arguments '("--verbose"))
#+end_src

Always set the upstream when pushing:

#+begin_src emacs-lisp
  (setq magit-push-arguments '("--set-upstream"))
#+end_src

**** Interaction with fullframe

If =fullframe= is installed (see below), use it to make =magit-status= take over
the entire frame:

#+begin_src emacs-lisp
  (after-load 'fullframe
    (fullframe magit-status magit-mode-quit-window nil))
#+end_src

**** Load Magit

Finally we can install Magit:

#+begin_src emacs-lisp
  (require-package 'magit)
#+end_src

** LaTeX

I love [[http://en.wikipedia.org/wiki/LaTeX][LaTex]]. It's the best way to typeset a document.

*** AucTeX

Let's start by installing some LaTeX specific plugins (mostly AucTex-related)
and initialize them,

#+begin_src emacs-lisp
  (require-package 'auctex)
  (require-package 'auctex-latexmk)
  (require-package 'smartparens)

  (auctex-latexmk-setup)
#+end_src

A few basic settings,

#+begin_src emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq LaTeX-item-indent 0)
  (setq TeX-clean-confirm nil) ;; don't ask me to clean
#+end_src

Who uses dvi?

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

*** SyncTeX

[[http://mactex-wiki.tug.org/wiki/index.php/SyncTeX][SyncTeX]] enables synchronization between source TeX files and the resulting pdf
file.

#+begin_src emacs-lisp
  (setq TeX-source-correlate-method 'synctex)
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
#+end_src

*** Latexmk

[[http://users.phys.psu.edu/~collins/software/latexmk-jcc/][Latexmk]] is a handy way to compile the TeX source the correct number of times.
So, we'll create a convenient binding for that,

#+begin_src emacs-lisp
(defun smf/latexmk-compile ()
      (interactive)
      (save-buffer)
      (TeX-command "LatexMk" 'TeX-master-file -1))
#+end_src

*** =magic-latex-buffer=

Magical syntax highlighting for LaTeX-mode buffers.

#+begin_src emacs-lisp
  (require-package 'magic-latex-buffer)
  (require 'magic-latex-buffer)
#+end_src

*** OS X

Sensible defaults for OS X, other OSes should be covered out-of-the-box,

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq TeX-view-program-selection
          '((output-dvi "DVI Viewer")
            (output-pdf "PDF Viewer")
            (output-html "HTML Viewer")))

    (setq TeX-view-program-list
          '(("DVI Viewer" "$HOME/.edit.sh -n %o")
            ("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b %n %o %b")
            ("HTML Viewer" "open %o"))))
#+end_src

Modes to load,

#+begin_src emacs-lisp
  (defun smf/latex-mode-hook ()
    (turn-on-auto-fill)
    (abbrev-mode +1)
    (smartparens-mode +1)
    (LaTeX-math-mode 1)
    (outline-minor-mode 1)
    (magic-latex-buffer)
    (define-key LaTeX-mode-map (kbd "C-c C-a") 'smf/latexmk-compile)
    (diminish 'magic-latex-buffer)
    (diminish 'iimage-mode)
    (diminish 'outline-minor-mode)
    (diminish 'smartparens-mode)
    (diminish 'auto-fill-function)
    (diminish 'reftex-mode)
    (diminish 'abbrev-mode))

  (add-hook 'LaTeX-mode-hook 'smf/latex-mode-hook)
  (add-hook 'LaTeX-mode-hook 'reftex-mode)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)   ; with AUCTeX LaTeX mode
  (add-hook 'latex-mode-hook 'turn-on-reftex)   ; with Emacs latex mode
#+end_src

*** RefTeX

You know what eles is awesome? [[http://www.gnu.org/software/auctex/reftex.html][RefTeX]].

#+begin_src emacs-lisp
  (autoload 'reftex-mode "reftex" "RefTeX Minor Mode" t)
  (autoload 'reftex-citation "reftex-cite" "Make citation" nil)
  (autoload 'reftex-index-phrase-mode "reftex-index" "Phrase mode" t)
#+end_src

These settings were randomly found,

#+begin_src emacs-lisp
  (setq reftex-enable-partial-scans t)
  (setq reftex-save-parse-info t)
  (setq reftex-use-multiple-selection-buffers t)
  (setq reftex-plug-into-AUCTeX t)

  (setq reftex-cite-prompt-optional-args nil)
  (setq reftex-cite-cleanup-optional-args t)

  (setq reftex-section-levels
   '(("part" . 0) ("chapter" . 1) ("section" . 2) ("subsection" . 3)
     ("frametitle" . 4) ("subsubsection" . 4) ("paragraph" . 5)
     ("subparagraph" . 6) ("addchap" . -1) ("addsec" . -2)))

  (setq reftex-plug-into-AUCTeX t
        reftex-extra-bindings t
        reftex-bibfile-ignore-list nil
        reftex-guess-label-type t
        reftex-revisit-to-follow t
        reftex-use-fonts t   ; make colorful toc
        reftex-toc-follow-mode nil ; don't follow other toc(s)
        reftex-toc-split-windows-horizontally t
        reftex-auto-recenter-toc t
        reftex-enable-partial-scans t
        reftex-save-parse-info t
        reftex-use-multiple-selection-buffers t)
#+end_src

*** Folding

#+begin_src emacs-lisp
  (setq outline-minor-mode-prefix (kbd "\C-co"))

  (setq TeX-fold-env-spec-list
        (quote (("[comment]" ("comment"))
                ("[figure]" ("figure"))
                ("[table]" ("table"))
                ("[itemize]" ("itemize"))
                ("[enumerate]" ("enumerate"))
                ("[description]" ("description"))
                ("[overpic]" ("overpic"))
                ("[tabularx]" ("tabularx"))
                ("[code]" ("code"))
                ("[shell]" ("shell")))))
#+end_src

*** Guessing the master TeX file

Taken from [[http://www.emacswiki.org/AUCTeX#toc19][EmacsWiki]] for automatic detection of the master file,

#+begin_src emacs-lisp
  (defun smf/guess-TeX-master (filename)
     "Guess the master file for FILENAME from currently open .tex files."
     (let ((candidate nil)
           (filename (file-name-nondirectory filename)))
       (save-excursion
         (dolist (buffer (buffer-list))
           (with-current-buffer buffer
             (let ((name (buffer-name))
                   (file buffer-file-name))
               (if (and file (string-match "\\.tex$" file))
                   (progn
                     (goto-char (point-min))
                     (if (re-search-forward (concat "\\\\input{" filename "}") nil t)
                         (setq candidate file))
                     (if (re-search-forward (concat "\\\\include{" (file-name-sans-extension filename) "}") nil t)
                         (setq candidate file))))))))
       (if candidate
           (message "TeX master document: %s" (file-name-nondirectory candidate)))
       candidate))

 (add-hook 'LaTeX-mode-hook
  '(lambda ()
    (setq TeX-master (smf/guess-TeX-master (buffer-file-name)))))
#+end_src

*** company-math

#+begin_src emacs-lisp
  (require-package 'company-auctex)
  (require-package 'company-math)

  (company-auctex-init)
  (add-to-list 'company-backends 'company-math-symbols-unicode)
#+end_src

** Loading Themes

On a GUI Emacs, I want to use the [[zenburn-theme]]. On a terminal I want to use the
[[base16-theme]].

*CAVEAT*

We need to load the theme after AUCTeX but before ERC. Why? I don't really know
but I do know it messes up erc-hl-nicks if I don't do it this way.

#+begin_src emacs-lisp
  ;; (load-theme 'zenburn t)
  ;; (enable-theme 'ample)
  (moe-dark)
  (powerline-moe-theme)
  (moe-theme-set-color 'blue)
#+end_src

** ERC

*** Setup

[[http://en.wikipedia.org/wiki/Internet_Relay_Chat][IRC]] is still popular, so we'll use Emacs IRC.

#+begin_src emacs-lisp
  (require 'tls)
  (require 'erc)
  (require 'erc-join)
  (require 'erc-menu)
  (require-package 'erc-hl-nicks)
  (require-package 'znc)
  (require-package 'erc-image)
#+end_src

I use [[http://wiki.znc.in/ZNC][ZNC]] to always stay connected to IRC channels, so when I close a buffer I
don't want to quit the channel, just detach from my server. Also, we use the
keychain method defined above to get our password.

#+begin_src emacs-lisp
  (setq
   znc-detatch-on-kill t
   znc-servers `(
                 ("smf.io" "6697" t ((freenode "smf/freenode"
                                               ,(smf/get-keychain-password "smf" "smf.io"))))
                 ("smf.io" "6697" t ((bitlbee "smf/bitlbee"
                                              ,(smf/get-keychain-password "smf" "smf.io"))))))
#+end_src

Some basic settings about my IRC setup,

#+begin_src emacs-lisp
  (setq
   erc-prompt ">"
   erc-email-userid "sean.michael.farley@gmail.com"
   erc-autojoin-channels-alist '((".*smf.io.*" "&bitlbee" "#mercurial"))
   erc-prompt-for-password nil
   erc-prompt-for-nickserv-password nil
   erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                             "324" "329" "332" "333" "353" "477")
   erc-hide-list '("JOIN" "PART" "QUIT" "NICK")
   erc-quit-reason 'erc-quit-reason-normal
   erc-track-exclude-server-buffer t)
#+end_src

I found when having a flaky connection that ERC would attempt to reconnect ad
infinitum, so we turn that off,

#+begin_src emacs-lisp
  (setq erc-server-auto-reconnect nil)
#+end_src

The following makes colors look nice with [[zenburn]].

#+begin_src emacs-lisp
  (setq erc-hl-nicks-color-contrast-strategy '(invert contrast))
#+end_src

While we're at it, let's enable [[http://www.emacswiki.org/emacs/ErcDCC][direct client-to-client]],

#+begin_src emacs-lisp
  (add-to-list 'erc-modules 'dcc)
  (add-to-list 'erc-modules 'image)
  (erc-update-modules)
#+end_src

Track mode allows notifications in the mode-line,

#+begin_src emacs-lisp
  (erc-track-mode t)
#+end_src

Spelling mode is exactly what it says it is,

#+begin_src emacs-lisp
  (erc-spelling-mode 1)
#+end_src

*** Query behavior

Button mode allows you to click on a nick and open a new query,

#+begin_src emacs-lisp
  (erc-button-mode 1)
#+end_src

When people send me a message (called 'query' in IRC speak), I want the buffer
to pop up and notify me,

#+begin_src emacs-lisp
  (setq erc-auto-query 'buffer)
  (setq erc-query-display 'buffer)
#+end_src

As a default, only private messages trigger automatic creation of query buffers.
I want the same behavior when I receive all notices (from [[http://www.emacswiki.org/emacs/ErcAutoQuery][EmacsWiki]]),

#+begin_src emacs-lisp
  (add-hook 'erc-after-connect
            (lambda (server nick)
              (add-hook 'erc-server-NOTICE-hook 'erc-auto-query)))
#+end_src

*** Switch to buffer or connect to znc

If I haven't connected to my ZNC server, then we connect to it; otherwise, just
switch to the buffer.

#+begin_src emacs-lisp
  (defun smf/erc-start-or-switch (channel)
    "Connect to ERC, or switch to given channel"
    (interactive)
    (if (get-buffer "*irc-freenode*") ;; ERC already active?
        (progn
          (set-buffer "*irc-freenode*")
          (if (erc-server-process-alive)
              (switch-to-buffer channel) ;; yes: switch to #channel
            (znc-all)))                  ;; no: start ERC
      (znc-all)))                        ;; no: start ERC

  (smf/add-launcher "m" (lambda ()
                          (interactive)
                          (smf/erc-start-or-switch "#mercurial")))

  (smf/add-launcher "k" (lambda ()
                          (interactive)
                          (smf/erc-start-or-switch "#kallithea")))

  (smf/add-launcher "b" (lambda ()
                          (interactive)
                          (smf/erc-start-or-switch "#bitbucket")))

  (smf/add-launcher "h" (lambda ()
                          (interactive)
                          (smf/erc-start-or-switch "#megahg")))

  (smf/add-launcher "r" (lambda ()
                          (interactive)
                          (smf/erc-start-or-switch "#kallithea-private")))
#+end_src

*** Query any user

Below adds the ability to launch a new chat with any nick. It amalgamates all
nicks in all channels because that is simple and hasn't been a problem for me
yet. My [[http://www.bitlbee.org][BitlBee]] server appends "|fb" or "|gtalk" for the corresponding chat
method so that takes care of most potential name conflicts.

#+begin_src emacs-lisp
  (defun smf/user-keys (erc-channel-users)
  "Convert the ERC-CHANNEL-USERS hash into an equivalent list-based form."
  (let ((alist '()))
    (maphash (lambda (key value)
               (push (erc-server-user-nickname (car value)) alist))
             erc-channel-users)
    alist))

  (defun smf/buffer-users (buffer)
    "Return users for a given ERC buffer"
    (set-buffer buffer)
    (smf/user-keys erc-channel-users))

  (defun smf/erc-chat (nick)
    "Start a query with nick"
    (interactive
     (list (completing-read "Nick: "
                            (append (smf/buffer-users "&bitlbee")
                                    (smf/buffer-users "#mercurial")))))
    (if (member nick (smf/buffer-users "&bitlbee")) (set-buffer "&bitlbee")
      (set-buffer "#mercurial"))
    (erc-cmd-QUERY nick))

  (smf/add-launcher "c" 'smf/erc-chat)
#+end_src

*** Change erc-track mouse button

This is annoying as hell but the only way to change the mouse button from the
middle click (mouse-2) to a normal click (mouse-1) is to redefine this [[http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/erc/erc-track.el#n776][whole
damn function]],

#+begin_src emacs-lisp
  (eval-after-load "erc-track"
  '(defun erc-make-mode-line-buffer-name (string buffer &optional faces count)
    (let ((map (make-sparse-keymap))
          (name (if erc-track-showcount
                    (concat string
                            erc-track-showcount-string
                            (int-to-string count))
                  (copy-sequence string))))
      (define-key map (vector 'mode-line 'mouse-1)
        `(lambda (e)
           (interactive "e")
           (save-selected-window
             (select-window
              (posn-window (event-start e)))
             (switch-to-buffer ,buffer))))
      (define-key map (vector 'mode-line 'mouse-3)
        `(lambda (e)
           (interactive "e")
           (save-selected-window
             (select-window
              (posn-window (event-start e)))
             (switch-to-buffer-other-window ,buffer))))
      (put-text-property 0 (length name) 'local-map map name)
      (put-text-property
       0 (length name)
       'help-echo (concat "mouse-1: switch to buffer, "
                          "mouse-3: switch to buffer in other window")
       name)
      (put-text-property 0 (length name) 'mouse-face erc-track-mouse-face name)
      (when (and faces erc-track-use-faces)
        (put-text-property 0 (length name) 'face faces name))
      name)))
#+end_src

** mu4e

[[http://www.djcbsoftware.nl/code/mu/][mu]] is a mail indexer and searching. It comes with an emacs client called [[mu4e]].
We only load it if it exists on the system (by wrapping it with =after-load=).

*** Setup

#+begin_src emacs-lisp
  (autoload 'mu4e "mu4e" t)
  (require 'smtpmail-async)
#+end_src

If available, let's use imagemagick.

#+begin_src emacs-lisp
  (after-load 'mu4e
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types)))
#+end_src

I have many email addresses, so let's set them here:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq
     mu4e-user-mail-address-list '("sean.michael.farley@gmail.com"
                                   "sean@seanfarley.org"
                                   "sean@mcs.anl.gov"
                                   "sean@macports.org"
                                   "sean@lsmsa.net"
                                   "sean@farley.io"
                                   "sfarley@atlassian.com"
                                   "me@smf.io"
                                   "sfarley@iit.edu")

     user-mail-address "sean@farley.io"
     user-full-name  "Sean Farley"))
#+end_src

*** Reply with custom from address

By default, I want my reply email to be the correct one. For example, if I am
replying to an email sent to the MacPorts list then I want =sean@macports.org=
to be used. To achieve this, I wrote a function to handle it:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (defun smf/mu4e-set-from-address ()
      "Set the From address based on the To address of the original."
      (let ((msg mu4e-compose-parent-message))
            (setq user-mail-address
                  (cond
                   ((null msg) "sean@farley.io")
                   ((mu4e-message-contact-field-matches msg :to "sean@seanfarley.org")
                    "sean@seanfarley.org")
                   ((mu4e-message-contact-field-matches msg :to "sean@mcs.anl.gov")
                    "sean@farley.io")
                   ((mu4e-message-contact-field-matches msg :to "sean@macports.org")
                    "sean@macports.org")
                   ((mu4e-message-contact-field-matches msg :to "sean@lsmsa.net")
                    "sean@lsmsa.net")
                   ((mu4e-message-contact-field-matches msg :to "sean@farley.io")
                    "sean@farley.io")
                   ((mu4e-message-contact-field-matches msg :to "me@smf.io")
                    "me@smf.io")
                   ((or
                     (mu4e-message-contact-field-matches msg :from "macports")
                     (mu4e-message-contact-field-matches msg :to "macports"))
                    "sean@macports.org")
                   ((or
                     (mu4e-message-contact-field-matches msg :from "atlassian")
                     (mu4e-message-contact-field-matches msg :to "atlassian"))
                    "sfarley@atlassian.com")
                   (t "sean@farley.io")))))

    (add-hook 'mu4e-compose-pre-hook 'smf/mu4e-set-from-address))
#+end_src

Also, when composing an email, turn on spellchecking:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (add-hook 'mu4e-compose-mode-hook (lambda () (flyspell-mode))))
#+end_src

*** Miscellaneous setting

It's an absolute must to sort the inbox with the date ascending. I would like to
reverse this for searches but don't know if that's possible.

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq mu4e~headers-sort-direction 'ascending))
#+end_src

Set the mail directories I have,

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq
       mu4e-maildir "~/.mail"
       mu4e-attachment-dir  "~/Downloads"
       mu4e-refile-folder "/archive"
       mu4e-drafts-folder "/drafts"
       mu4e-trash-folder "/trash"
       mu4e-sent-folder "/sent"

       mu4e-maildir-shortcuts '(("/inbox"     . ?i)
                                ("/archive"   . ?a)
                                ("/drafts"    . ?d)
                                ("/phd"       . ?p)
                                ("/posterity" . ?t)
                                ("/barryisms" . ?b)
                                ("/spam"      . ?s))
  ))
#+end_src

Set mu4e as default emacs email program,

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq mail-user-agent 'mu4e-user-agent))
#+end_src

Set mbsync to be called for fetching new mail. This allows mail to be
updated from within [[mu4e]] with keyboard shortcuts.

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq mu4e-get-mail-command "mbsync -a"))
#+end_src

Update email every two minutes,

#+begin_src emacs-lisp
;;  (after-load 'mu4e
;;       (setq mu4e-update-interval 120))
#+end_src

Miscellaneous settings: these variable names speak for themselves,

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq
       mu4e-confirm-quit nil
       mu4e-view-show-images t
       mu4e-view-prefer-html nil

       ;; show email address as well as name
       mu4e-view-show-addresses t

       ;; don't use a signature
       mu4e-compose-signature-auto-include nil

       mu4e-headers-date-format "%d %b %Y"
       mu4e-headers-time-format "%H:%M"

       ;; threading and duplicates
       mu4e-headers-show-threads t
       mu4e-headers-results-limit 500
       mu4e-headers-skip-duplicates t
       mu4e-headers-include-related t

       ;; mbsync needs messages to be renamed
       mu4e-change-filenames-when-moving t

       ;; fields on message view
       mu4e-view-fields '(:from :to :cc :subject :mailing-list :tags :flags :date :maildir :attachments :signature)

       ;; smtp mail setting
       send-mail-function    'async-smtpmail-send-it
       message-send-mail-function 'async-smtpmail-send-it
       smtpmail-default-smtp-server "mail.farley.io"
       smtpmail-smtp-server  "mail.farley.io"
       smtpmail-stream-type  'starttls
       smtpmail-smtp-service 587

       ;; don't keep message buffers around
       message-kill-buffer-on-exit t

      ;; fields in list view
      mu4e-headers-fields '((:human-date . 15)
                            (:flags      .  5)
                            (:from       . 30)
                            (:subject    . nil))))
#+end_src

*** HTML emails

[[http://ergoemacs.org/emacs/emacs24.4_features.html][Emacs 24]] comes with a built-in web browser called [[http://ergoemacs.org/emacs/emacs_eww_web_browser.html][eww]]. [[mu4e]] can use this to
render html email:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (require 'mu4e-contrib)
    (setq mu4e-html2text-command 'mu4e-shr2text))
#+end_src

Finally, let's use [[http://pablo.rauzy.name/dev/init.el.html][fancy unicode characters]]:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq
       mu4e-use-fancy-chars t
       mu4e-headers-new-mark            '("N" . "✉")
       mu4e-headers-seen-mark           '("S" . "☑")
       mu4e-headers-replied-mark        '("R" . "↵")
       mu4e-headers-passed-mark         '("P" . "⇉")))
#+end_src

*** Thread Navigation

These functions are copied from [[https://github.com/djcb/mu/blob/master/mu4e/mu4e-headers.el#L1434][mu4e-headers-next-unread]] and just changed to
check the thread level instead of the unread flag. We'll bind them to 'N' and
'P'.

#+begin_src emacs-lisp
  (after-load 'mu4e
    (defun smf/mu4e-headers-next-thread (&optional backwards)
      "Move point to the next thread. If BACKWARDS is non-`nil',
        move backwards."
      (interactive "P")
      (or (mu4e-headers-find-if-next
           (lambda (msg)
             (let ((thread (mu4e-message-field msg :thread)))
               (eq (plist-get thread :level) 0)))
           backwards)
          (mu4e-message (format "No %s thread found"
                                (if backwards "previous" "next")))))

    (defun smf/mu4e-view-headers-next-thread (&optional backwards)
      "Move point to the next or previous (when BACKWARDS is non-`nil')
       unread message header in the headers buffer connected with this
       message view. If this succeeds, return the new docid. Otherwise,
       return nil."
      (interactive "P")
      (mu4e~view-in-headers-context
       (smf/mu4e-headers-next-thread backwards))
      (mu4e-select-other-view)
      (mu4e-headers-view-message))

    (define-key mu4e-headers-mode-map (kbd "N") 'smf/mu4e-headers-next-thread)
    (define-key mu4e-view-mode-map (kbd "N") 'smf/mu4e-view-headers-next-thread)

    ;; override default binding for "P"
    (define-key mu4e-headers-mode-map (kbd "P")
      (lambda() (interactive) (smf/mu4e-headers-next-thread t)))
    (define-key mu4e-view-mode-map (kbd "P")
      (lambda() (interactive) (smf/mu4e-view-headers-next-thread t))))
#+end_src

*** Custom marks

[[mu4e]] has a way to apply arbitrary 'marks' to a message or thread. We will use
these to override default behavior.

#+begin_src emacs-lisp
  (after-load 'mu4e
      (setq mu4e-marks (delq (assoc 'refile mu4e-marks) mu4e-marks))

      (add-to-list 'mu4e-marks
                   '(refile
                     :char       "r"
                     :prompt     "refile"
                     :dyn-target  (lambda (target msg) (mu4e-get-refile-folder msg))
                     :action      (lambda (docid msg target)
                                    (mu4e~proc-move docid
                                      (mu4e~mark-check-target target) "+S-u-N")))))
#+end_src

*** Custom actions

Custom actions allow us to define arbitrary commands to run on a message. We'll
use this to apply a mercurial patch to a working directory:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (defun smf/mu4e-action-hg-import-patch (msg)
      "Import the hg [patch] message."
      (let ((path (read-directory-name "Target directory: " "~/projects/hg" nil nil nil) ))
        (shell-command
         (format "cd %s; hg import %s"
                 path
                 (mu4e-message-field msg :path)))))

      (add-to-list 'mu4e-view-actions '("patch" . smf/mu4e-action-hg-import-patch) t))
#+end_src

Taken from the manual, we'll also add an action to view an html message in the browser (in case the html fails to render within emacs).

#+begin_src emacs-lisp
  (after-load 'mu4e
    (add-to-list 'mu4e-view-actions '("bView in browser" . mu4e-action-view-in-browser) t))
#+end_src

*** Bookmarks

We'll add bookmarks for common "views" of our mailbox:

#+begin_src emacs-lisp
  (after-load 'mu4e
    (setq
     mu4e-bookmarks '(("flag:unread"                      "Unread"    ?u)
                      ("to:sean.michael.farley+self and not maildir:/phd and not maildir:/posterity"      "Notes"     ?n))))
#+end_src

*** Keybinding

Finally, add a keybinding to open our email client:

#+begin_src emacs-lisp
  (smf/add-launcher "e" 'mu4e)
#+end_src

** Local and custom configuration

*** Local overrides

So I can configure my Emacs per computer/user, I attempted to automatically load
some configuration.

First set up a directory to hold the files:

#+begin_src emacs-lisp
  (setq smf/local-dotfiles-dir (smf/join-dirs smf/dotfiles-dir "local"))
#+end_src

Now try to load a file named after the current user:

#+begin_src emacs-lisp
  (load (concat smf/local-dotfiles-dir user-login-name ".el") t)
#+end_src

and try to load a file named after the local system:

#+begin_src emacs-lisp
  (load (concat smf/local-dotfiles-dir system-name ".el") t)
#+end_src

Finally, try loading a default file:

#+begin_src emacs-lisp
  (load (concat smf/local-dotfiles-dir "local-overrides.el") t)
#+end_src

*** =Customize=-d configuration

Make sure anything saved using =customize= goes into a consistent (and ignored)
place:

#+begin_src emacs-lisp
  (load (setq custom-file (concat smf/dotfiles-dir "custom.el")) t)
#+end_src

(note that this works because =setq= returns the value it's set to)
