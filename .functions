# Create a new directory and enter it
unalias md 2>/dev/null
md() {
  mkdir -p "$@" && cd "$@"
}

# Easier navigation: .., ..., etc.
unalias .. 2>/dev/null
..() {
  eval cd ../\""$@"\"
}

_..() {
  local IFS=$'\n'
  COMPREPLY=( $(compgen -W "$(ls -p .. | grep / | sed 's,/,,')" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _.. -o nospace ..

unalias ... 2>/dev/null
...() {
  eval cd ../../\""$@"\"
}

_...() {
  local IFS=$'\n'
  COMPREPLY=( $(compgen -W "$(ls -p ../.. | grep / | sed 's,/,,')" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _... -o nospace ...

unalias .... 2>/dev/null
....() {
  eval cd ../../../\""$@"\"
}

_....() {
  local IFS=$'\n'
  COMPREPLY=( $(compgen -W "$(ls -p ../../.. | grep / | sed 's,/,,')" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _.... -o nospace ....

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
httpcompression() {
  encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# All the dig info
digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

a() {
  ack "$@" .
}

mpcategory() {
  port info $@ 2>/dev/null | head -n 1 | sed -n 's#.*(\(.\{1,\}\)).*#\1#p' | awk -F',' '{print $1}'
}

mpc() {
  local CATEGORY=$(mpcategory $@)
  [[ -n $CATEGORY ]] && echo "$MP/$CATEGORY"
}

mp() {
  local CATEGORY=$(mpcategory $@)
  [[ -n $CATEGORY ]] && echo "$MP/$CATEGORY/$@"
}

psgrep() {
  ps aux | grep -v grep | grep "$@"
}

killgrep() {
  local PROCS=$(psgrep $@ | awk '{print $2;}')
  for p in $PROCS; do
    kill $p
  done
}

d() {
  local GET="curl -O"
  [[ -z "$(which curl 2>/dev/null)" ]] && GET="wget -c"

  for i in $@; do
    $GET $i;
  done;
}

ssh() {
  # system ssh command
  local SSH=$(which ssh)

  # if called from a script return default ssh
  [[ $(echo $@ | grep -ci batch) -gt 0 ]] && $SSH $@ && return $?

  # read from emacs server file what port it is currently listening on
  local PORT=$(egrep  -o '127.0.0.1:([0-9]*)' ~/.emacs.d/server/server | sed 's/127.0.0.1://')

  # read the server file, escaping single quotes that are in the auth string
  local SRV=$(cat ~/.emacs.d/server/server | sed "s/'/\\\\\\'/")

  # When connecting to the remote host, print the server file to the
  # correct location and then invoke my shell.
  local CMD="mkdir -m 700 -p ~/.emacs.d/server; echo $'$SRV' > ~/.emacs.d/server/server; bash -l"

  # -t : allocate a tty so we are there.
  # -R : the remote port forward that lets emacsclient talk back
  # $@ : any other args this script was invoked with should be passed along.
  $SSH -t -R $PORT:127.0.0.1:$PORT $@ "$CMD"
}
