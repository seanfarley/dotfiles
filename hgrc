[ui]
username = Sean Farley <sean@farley.io>
ssh = ssh -C
editor = ~/.edit.sh
ignore = ~/.hgignore
debugger = ipdb

[phases]
publish = False

[experimental]
bundle2-exp = True
crecord = True

[format]
usegeneraldelta = True

[extensions]
transplant =
color =
patchbomb =
parentrevspec =
schemes =
progress =
extdiff =
rebase =
convert =
hgk =
record =
pager =
churn =
histedit =
purge =
strip =
shelve =
# Third-party extensions
debugshell = ~/.debugshell.py
evolve =

[remotenames]
alias.default = True
suppressbranches = True

[schemes]
bb = ssh://hg@bitbucket.org/
git+bb = git+ssh://git@bitbucket.org/
gh = git+ssh://git@github.com/
logilab = ssh://hg-lab@hg-lab.logilab.org/users/

[hgsubversion]
nativerevs = True

[git]
use_namespaces = True

[diff]
git = True
showfunc = True
unified = 5

[pager]
pager = less

[mq]
secret = True

[extdiff]
cmd.sourcetreediff=opendiff
opts.sourcetreediff=
cmd.opendiff = fmdiff
cmd.wdiff = cwdiff
opts.wdiff = --diff --ab

[merge-tools]
emacsclient.executable = ~/.edit.sh
emacsclient.args = "-q --eval '(hg-mergetool-emacsclient-ediff \"$local\" \"$other\" \"$base\" \"$output\")'"
emacsclient.premerge = keep
emacsclient.priority = 1

keepthat.executable = sh
keepthat.args = -c 'cp "$local" "$output.original" && cp "$other" "$output"'
keepthat.premerge = True

keepthis.executable = sh
keepthis.args = -c 'cp "$other" "$output.incoming" && cp "$local" "$output"'
keepthis.premerge = True

sourcetreemerge.gui=False
sourcetreebulkmerge.gui=False
sourcetreemerge.binary=False
sourcetreebulkmerge.executable=/Applications/SourceTree.app/Contents/Resources/hg-merge.sh
sourcetreemerge.args=$local $other -ancestor $base -merge $output
sourcetreemerge.checkconflicts=True
sourcetreemerge.premerge=True
sourcetreemerge.executable=/Applications/SourceTree.app/Contents/Resources/opendiff-w.sh
sourcetreebulkmerge.premerge=False
sourcetreebulkmerge.binary=True

[hostfingerprints]
bitbucket.org = 46:de:34:e7:9b:18:cd:7f:ae:fd:8b:e3:bc:f4:1a:5e:38:d7:ac:24
svn.macports.org = 15:5e:21:55:fe:e3:26:ae:b2:f8:c6:6a:d2:1a:bf:82:74:dd:c9:14
kallithea-scm.org = 53:de:4d:c5:f8:32:6f:26:36:9a:95:86:21:21:4b:6f:99:b2:e4:9a

[email]
method = smtp
from = Sean Farley <sean@farley.io>

[patchbomb]
intro = never

[smtp]
host = mail.farley.io
port = 587
username = sean@farley.io
tls = True
local_hostname = farley.io

[templates]
sl = "{if(svnrev, label('log.changeset', '[r{svnrev}] '))}{label('log.changeset changeset.{phase} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', shortest(node))} {label('log.changeset', author|user)}{tags % \"{ifeq(tag,'tip','',label('log.tag', ' {tag}'))}\"}{ifeq(branch,'default','',label('log.branch', ' {branch}'))}{label('log.bookmark', if(bookmarks,' {bookmarks}'))}{label('log.remotename', if(remotenames, ' {remotenames}'))}{label('log.remoteref', if(remoterefs, ' {remoterefs}'))}\n{label('{ifcontains(rev, revset(\".\"), \"desc.here\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', desc|firstline)}"

gl = "{label('changeset.{phase} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', pad(shortest(node), 7, ' ', True))} {label('log.description', fill(desc|firstline|strip, '80')|firstline|strip)} {ifeq(branch,'default','',label('log.branch', '{branch} '))}{bookmarks % \"{label('log.bookmark', '{bookmark} ')}\"}{label('log.remotebookmark', if(remotebookmarks, '{remotebookmarks} '))}{label('log.remotebranch', if(remotebranches, '{remotebranches} '))}{label('log.remoteref', if(remoterefs, '{remoterefs} '))}{tags % \"{ifeq(tag,'tip','',label('log.tag', '{tag} '))}\"}{label('log.date', date|shortdate)} by {label('log.user', author|person)}\n{label('log.description', sub('^.*\n?\n?', '', '{fill(desc|firstline|strip, \"95\", \"\", sub(\"[0-9]\", \" \", \"        \"))}\n\n'))}"

ll = "{if(svnrev, label('log.changeset', '[r{svnrev}] '))}{label('changeset.{phase} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', '{rev}')}:{label('changeset.{phase} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', '{node|short}')} {label('log.description', \"{fill(desc|firstline|strip, '80')|firstline|strip}\")}{tags % \"{ifeq(tag,'tip','',label('log.tag', ' {tag}'))}\"}{ifeq(branch,'default','',label('log.branch', ' {branch}'))}{label('log.remotebranch', if(remotebranches, ' {remotebranches}'))}{label('log.bookmark', if(bookmarks,' {bookmarks}'))}{label('log.remotebookmark', if(remotebookmarks, ' {remotebookmarks}'))}{label('log.remoteref', if(remoterefs, ' {remoterefs}'))} {label('log.date', date|shortdate)} by {label('log.user', author|person)}\n"

nl = "{if(svnrev, label('log.changeset', '[r{svnrev}] '))}{label('changeset.{phase} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', '{rev}')}:{label('changeset.{phase} {ifcontains(rev, revset(\"merge()\"), \"changeset.merge\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', '{node|short}')}{tags % \"{ifeq(tag,'tip','',label('log.tag', ' {tag}'))}\"}{ifeq(branch,'default','',label('log.branch', ' {branch}'))}{label('log.remotebranch', if(remotebranches, ' {remotebranches}'))}{label('log.bookmark', if(bookmarks,' {bookmarks}'))}{label('log.remotebookmark', if(remotebookmarks, ' {remotebookmarks}'))}{label('log.remoteref', if(remoterefs, ' {remoterefs}'))} {label('log.date', date|isodatesec)} by {label('log.user', author|person)}\n{label('{ifcontains(rev, revset(\".\"), \"desc.here\")} {ifcontains(rev, revset(\"obsolete()\"), \"changeset.obsolete\")}', desc)}\n\n{file_mods % \"{label('status.modified', 'M {file}')}\n\"}{file_adds % \"{label('status.added', 'A {file}')}\n\"}{file_dels % \"{label('status.removed', 'R {file}')}\n\"}\n"

[color]
desc.here = inverse
status.modified = cyan
status.added = green
status.removed = red
status.deleted = yellow bold underline
status.unknown = magenta bold underline
status.ignored = yellow underline
status.copied = green underline
diff.diffline = none
diff.extended = cyan
diff.file_a = red
diff.file_b = green
diff.hunk = yellow bold
diff.deleted = red
diff.inserted = green
diff.changed = white
diff.trailingwhitespace = white_background
qseries.applied = blue bold underline
qseries.unapplied = cyan bold
qseries.missing = red bold
bookmarks.current = magenta bold
tags.normal = green
log.tag = green
log.bookmark = magenta
log.branch = blue bold
log.date = green bold
log.user = yellow
log.manifest = green bold underline
log.extra = yellow bold underline
log.remotename = red
log.remotebookmark = red
log.remoteref = red
log.remotebranch = cyan
changeset.public = blue
changeset.draft = green
changeset.secret = red bold
changeset.merge = dim
changeset.obsolete = italic dim

[revsetalias]
smart = (parents(not public()) or not public() or . or (heads(all()) and not closed())) and (not obsolete() or unstable()^)

[alias]
# always use relative paths
st = st ""

### useful alias to check future amend result
# equivalent to the qdiff command for mq

# diff
pdiff = diff --pager=always --rev .^

# status
pstatus = status --rev .^

# diff with the previous amend
odiff = diff --rev 'limit(precursors(.),1)' --rev .
n = !$HG next || $HG evolve && $HG --color=always show .

he = histedit
l = log --pager=always
p = pull -u
pr = pull --rebase

# by default, don't prompt for cc
email = email --confirm --cc ' '

# Nudge: just push the current branch.
nudge = push -r .

# Some useful little aliases.
? = summary
df = diff
r = record
view = hgview
v = hgview

# Merge with default.
md = merge default

# Commit message shortcuts.

# this blows up when message has a '!' in it?
cm = commit -m
cus = commit -m 'subrepo: update state'
cmm = commit -m 'merge'

# Merge shortcuts.
mergelocal = !$HG --config ui.merge=internal:local merge $@
mergeother = !$HG --config ui.merge=internal:other merge $@
mergefail = !$HG --config ui.merge=internal:fail merge $@

# Shortcuts to resolve merge conflicts by taking one side or the other.
takelocal = !"$HG" revert --rev 'p1()' $@ && "$HG" resolve -m $@
takeother = !"$HG" revert --rev 'p2()' $@ && "$HG" resolve -m $@

# Run a colored diff and pipe it to less.
d = diff -p --pager=always
gd = d

# Log shortcuts --------------------------------------------------------------------

# Simple log commands that don't look bad

ll = log --pager=always -T ll

gll = log -G --pager=always -T sl

gl = gll -r '.%(bookmark()-. or max(public()))^'

gl. = gll -r ::.

sl = log -G --pager=always -r smart -T sl

nll = log -G --pager=always -T nl

nl = nll -r '.%(bookmark()-. or max(public()))^'

# hg show .  -- show a summary of rev . with diff.
show = log --pager=always --stat --hidden -T nl -vpr

# Make a new repo with some sensible defaults.
mkrepo = !$HG init $1 && cd $1 && \
          echo 'syntax: glob'  > .hgignore && \
          echo ''             >> .hgignore && \
          echo '.DS_Store'    >> .hgignore && \
          echo '*.pyc'        >> .hgignore && \
          echo '*.swp'        >> .hgignore && \
          echo '*.swo'        >> .hgignore && \
          echo '*.un~'        >> .hgignore && \
          echo '.ropeproject' >> .hgignore && \
          echo 'tags'         >> .hgignore && \
          echo "[paths]\n" >> .hg/hgrc

# Easily add ignore patterns to .hgignore and commit.
ignore = ![ -n "$@" ] && echo '$@' >> `$HG root`/.hgignore && \
          $HG commit `$HG root`/.hgignore -Am 'Add "$@" to .hgignore.'

# Run hg commands on all subrepos at once.
subs  = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | xargs    -n1  -I SUB $HG -R "`$HG root`/SUB" $@
psubs = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | parallel -j10 -I SUB $HG -R "`$HG root`/SUB" $@

# Run shell commands on all subrepos at once.
subscmd  = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | xargs    -n1  -I SUB sh -c "cd `$HG root`/SUB && $@"
psubscmd = !"$HG" debugsub | grep '^path' | cut -d' ' -f2 | parallel -j10 -I SUB sh -c "cd `$HG root`/SUB && $@"

# Run a command on a subrepo:
#
#     hg sub SUBREPO_REGEX ...command and arguments...
#
# The SUBREPO_REGEX should be a regex that will let grep match one and only one of
# the subrepos in .hgsub.  For example:
#
#     $ cat .hgsub
#     bundled/foo = ...
#     bundled/bar = ...
#
#     $ hg sub fo root
#     .../bundled/foo
#     $ hg sub ar status -m
#     M lol.py
sub = !grep = "`$HG root`/.hgsub" | cut -d' ' -f1 | grep "$1" | tr -d '\n ' | xargs -0 -I SUB $HG -R SUB "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9" "$10" "$11" "$12" "$13" "$14" "$15" "$16" "$17" "$18" "$19" "$20"

pss = !chg status --no-status --clean --modified --added --print0 . | xargs pss $@
wgrep = !chg status --no-status --clean --modified --added --print0 . | xargs -0 grep --binary-files=without-match $@

%include .hgrc.local
